
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

20010000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
20010000:	00000297          	auipc	t0,0x0
20010004:	01028293          	addi	t0,t0,16 # 20010010 <__irq_wrapper>
	csrw mtvec, t0
20010008:	30529073          	csrw	mtvec,t0

	/* Jump to __initialize */
	tail __initialize
2001000c:	1490206f          	j	20012954 <__initialize>

Disassembly of section exceptions:

20010010 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
20010010:	fb010113          	addi	sp,sp,-80
20010014:	00112023          	sw	ra,0(sp)
20010018:	00312223          	sw	gp,4(sp)
2001001c:	00412423          	sw	tp,8(sp)
20010020:	00512623          	sw	t0,12(sp)
20010024:	00612823          	sw	t1,16(sp)
20010028:	00712a23          	sw	t2,20(sp)
2001002c:	01c12c23          	sw	t3,24(sp)
20010030:	01d12e23          	sw	t4,28(sp)
20010034:	03e12023          	sw	t5,32(sp)
20010038:	03f12223          	sw	t6,36(sp)
2001003c:	02a12423          	sw	a0,40(sp)
20010040:	02b12623          	sw	a1,44(sp)
20010044:	02c12823          	sw	a2,48(sp)
20010048:	02d12a23          	sw	a3,52(sp)
2001004c:	02e12c23          	sw	a4,56(sp)
20010050:	02f12e23          	sw	a5,60(sp)
20010054:	05012023          	sw	a6,64(sp)
20010058:	05112223          	sw	a7,68(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
2001005c:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
20010060:	04512423          	sw	t0,72(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
20010064:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
20010068:	04512623          	sw	t0,76(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
2001006c:	21c000ef          	jal	ra,20010288 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
20010070:	00000313          	li	t1,0
	bnez a0, is_interrupt
20010074:	02051e63          	bnez	a0,200100b0 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
20010078:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
2001007c:	800003b7          	lui	t2,0x80000
20010080:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
20010084:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
20010088:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
2001008c:	00628a63          	beq	t0,t1,200100a0 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
20010090:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
20010094:	00000097          	auipc	ra,0x0
20010098:	18408093          	addi	ra,ra,388 # 20010218 <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
2001009c:	7a40206f          	j	20012840 <_Fault>

200100a0 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
200100a0:	04812283          	lw	t0,72(sp)
	addi t0, t0, 4
200100a4:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
200100a8:	04512423          	sw	t0,72(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
200100ac:	0800006f          	j	2001012c <reschedule>

200100b0 <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
200100b0:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
200100b4:	5fff0397          	auipc	t2,0x5fff0
200100b8:	2c838393          	addi	t2,t2,712 # 8000037c <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
200100bc:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
200100c0:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
200100c4:	00512023          	sw	t0,0(sp)

200100c8 <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
200100c8:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
200100cc:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
200100d0:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
200100d4:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
200100d8:	800002b7          	lui	t0,0x80000
200100dc:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
200100e0:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
200100e4:	194000ef          	jal	ra,20010278 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
200100e8:	00005297          	auipc	t0,0x5
200100ec:	bbc28293          	addi	t0,t0,-1092 # 20014ca4 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
200100f0:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
200100f4:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
200100f8:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
200100fc:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1
20010100:	000300e7          	jalr	t1

20010104 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
20010104:	5fff0317          	auipc	t1,0x5fff0
20010108:	27830313          	addi	t1,t1,632 # 8000037c <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
2001010c:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
20010110:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
20010114:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
20010118:	00012283          	lw	t0,0(sp)
	addi sp, t0, 0
2001011c:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
20010120:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
20010124:	02032e03          	lw	t3,32(t1)
	beq t3, t2, no_reschedule
20010128:	0e7e0863          	beq	t3,t2,20010218 <no_reschedule>

2001012c <reschedule>:

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
2001012c:	5fff0297          	auipc	t0,0x5fff0
20010130:	25028293          	addi	t0,t0,592 # 8000037c <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
20010134:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
20010138:	02832a23          	sw	s0,52(t1)
2001013c:	02932c23          	sw	s1,56(t1)
20010140:	03232e23          	sw	s2,60(t1)
20010144:	05332023          	sw	s3,64(t1)
20010148:	05432223          	sw	s4,68(t1)
2001014c:	05532423          	sw	s5,72(t1)
20010150:	05632623          	sw	s6,76(t1)
20010154:	05732823          	sw	s7,80(t1)
20010158:	05832a23          	sw	s8,84(t1)
2001015c:	05932c23          	sw	s9,88(t1)
20010160:	05a32e23          	sw	s10,92(t1)
20010164:	07b32023          	sw	s11,96(t1)

20010168 <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
20010168:	02232823          	sw	sp,48(t1)
	la t2, _k_neg_eagain
2001016c:	00005397          	auipc	t2,0x5
20010170:	d7038393          	addi	t2,t2,-656 # 20014edc <_k_neg_eagain>
	lw t3, 0x00(t2)
20010174:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
20010178:	09c32223          	sw	t3,132(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
2001017c:	0202a303          	lw	t1,32(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
20010180:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
20010184:	03032103          	lw	sp,48(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLER_SAVED(t1)
20010188:	03432403          	lw	s0,52(t1)
2001018c:	03832483          	lw	s1,56(t1)
20010190:	03c32903          	lw	s2,60(t1)
20010194:	04032983          	lw	s3,64(t1)
20010198:	04432a03          	lw	s4,68(t1)
2001019c:	04832a83          	lw	s5,72(t1)
200101a0:	04c32b03          	lw	s6,76(t1)
200101a4:	05032b83          	lw	s7,80(t1)
200101a8:	05432c03          	lw	s8,84(t1)
200101ac:	05832c83          	lw	s9,88(t1)
200101b0:	05c32d03          	lw	s10,92(t1)
200101b4:	06032d83          	lw	s11,96(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
200101b8:	04812283          	lw	t0,72(sp)
	csrw mepc, t0
200101bc:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
200101c0:	04c12283          	lw	t0,76(sp)
	csrw mstatus, t0
200101c4:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLEE_SAVED()
200101c8:	00012083          	lw	ra,0(sp)
200101cc:	00412183          	lw	gp,4(sp)
200101d0:	00812203          	lw	tp,8(sp)
200101d4:	00c12283          	lw	t0,12(sp)
200101d8:	01012303          	lw	t1,16(sp)
200101dc:	01412383          	lw	t2,20(sp)
200101e0:	01812e03          	lw	t3,24(sp)
200101e4:	01c12e83          	lw	t4,28(sp)
200101e8:	02012f03          	lw	t5,32(sp)
200101ec:	02412f83          	lw	t6,36(sp)
200101f0:	02812503          	lw	a0,40(sp)
200101f4:	02c12583          	lw	a1,44(sp)
200101f8:	03012603          	lw	a2,48(sp)
200101fc:	03412683          	lw	a3,52(sp)
20010200:	03812703          	lw	a4,56(sp)
20010204:	03c12783          	lw	a5,60(sp)
20010208:	04012803          	lw	a6,64(sp)
2001020c:	04412883          	lw	a7,68(sp)
20010210:	05010113          	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
20010214:	30200073          	mret

20010218 <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
20010218:	04812283          	lw	t0,72(sp)
	csrw mepc, t0
2001021c:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
20010220:	04c12283          	lw	t0,76(sp)
	csrw mstatus, t0
20010224:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLEE_SAVED()
20010228:	00012083          	lw	ra,0(sp)
2001022c:	00412183          	lw	gp,4(sp)
20010230:	00812203          	lw	tp,8(sp)
20010234:	00c12283          	lw	t0,12(sp)
20010238:	01012303          	lw	t1,16(sp)
2001023c:	01412383          	lw	t2,20(sp)
20010240:	01812e03          	lw	t3,24(sp)
20010244:	01c12e83          	lw	t4,28(sp)
20010248:	02012f03          	lw	t5,32(sp)
2001024c:	02412f83          	lw	t6,36(sp)
20010250:	02812503          	lw	a0,40(sp)
20010254:	02c12583          	lw	a1,44(sp)
20010258:	03012603          	lw	a2,48(sp)
2001025c:	03412683          	lw	a3,52(sp)
20010260:	03812703          	lw	a4,56(sp)
20010264:	03c12783          	lw	a5,60(sp)
20010268:	04012803          	lw	a6,64(sp)
2001026c:	04412883          	lw	a7,68(sp)
20010270:	05010113          	addi	sp,sp,80

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
20010274:	30200073          	mret

20010278 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
20010278:	00100313          	li	t1,1
	sll t0, t1, a0
2001027c:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
20010280:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
20010284:	00008067          	ret

20010288 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
20010288:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
2001028c:	80000337          	lui	t1,0x80000
	and t0, t0, t1
20010290:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
20010294:	00000513          	li	a0,0
	beqz t0, not_interrupt
20010298:	00028463          	beqz	t0,200102a0 <not_interrupt>
	addi a0, a0, 1
2001029c:	00150513          	addi	a0,a0,1

200102a0 <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
200102a0:	00008067          	ret

200102a4 <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
200102a4:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
200102a8:	5fff0297          	auipc	t0,0x5fff0
200102ac:	0d428293          	addi	t0,t0,212 # 8000037c <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
200102b0:	0082a303          	lw	t1,8(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
200102b4:	08432383          	lw	t2,132(t1) # 80000084 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000085>

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
200102b8:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
200102bc:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
200102c0:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
200102c4:	00008067          	ret

Disassembly of section text:

200102c8 <__clzsi2>:
200102c8:	000107b7          	lui	a5,0x10
200102cc:	02f57a63          	bgeu	a0,a5,20010300 <__clzsi2+0x38>
200102d0:	0ff00793          	li	a5,255
200102d4:	00a7b7b3          	sltu	a5,a5,a0
200102d8:	00379793          	slli	a5,a5,0x3
200102dc:	20015737          	lui	a4,0x20015
200102e0:	02000693          	li	a3,32
200102e4:	40f686b3          	sub	a3,a3,a5
200102e8:	00f55533          	srl	a0,a0,a5
200102ec:	ee070793          	addi	a5,a4,-288 # 20014ee0 <__clz_tab>
200102f0:	00a78533          	add	a0,a5,a0
200102f4:	00054503          	lbu	a0,0(a0)
200102f8:	40a68533          	sub	a0,a3,a0
200102fc:	00008067          	ret
20010300:	01000737          	lui	a4,0x1000
20010304:	01000793          	li	a5,16
20010308:	fce56ae3          	bltu	a0,a4,200102dc <__clzsi2+0x14>
2001030c:	01800793          	li	a5,24
20010310:	fcdff06f          	j	200102dc <__clzsi2+0x14>

20010314 <__udivdi3>:
20010314:	00050893          	mv	a7,a0
20010318:	00058793          	mv	a5,a1
2001031c:	00060813          	mv	a6,a2
20010320:	00068513          	mv	a0,a3
20010324:	00088313          	mv	t1,a7
20010328:	28069463          	bnez	a3,200105b0 <__udivdi3+0x29c>
2001032c:	200156b7          	lui	a3,0x20015
20010330:	ee068693          	addi	a3,a3,-288 # 20014ee0 <__clz_tab>
20010334:	0ec5f663          	bgeu	a1,a2,20010420 <__udivdi3+0x10c>
20010338:	00010737          	lui	a4,0x10
2001033c:	0ce67863          	bgeu	a2,a4,2001040c <__udivdi3+0xf8>
20010340:	0ff00713          	li	a4,255
20010344:	00c73733          	sltu	a4,a4,a2
20010348:	00371713          	slli	a4,a4,0x3
2001034c:	00e65533          	srl	a0,a2,a4
20010350:	00a686b3          	add	a3,a3,a0
20010354:	0006c683          	lbu	a3,0(a3)
20010358:	02000513          	li	a0,32
2001035c:	00e68733          	add	a4,a3,a4
20010360:	40e506b3          	sub	a3,a0,a4
20010364:	00e50c63          	beq	a0,a4,2001037c <__udivdi3+0x68>
20010368:	00d795b3          	sll	a1,a5,a3
2001036c:	00e8d733          	srl	a4,a7,a4
20010370:	00d61833          	sll	a6,a2,a3
20010374:	00b765b3          	or	a1,a4,a1
20010378:	00d89333          	sll	t1,a7,a3
2001037c:	01085893          	srli	a7,a6,0x10
20010380:	0315d6b3          	divu	a3,a1,a7
20010384:	01081613          	slli	a2,a6,0x10
20010388:	01065613          	srli	a2,a2,0x10
2001038c:	01035793          	srli	a5,t1,0x10
20010390:	0315f733          	remu	a4,a1,a7
20010394:	00068513          	mv	a0,a3
20010398:	02d605b3          	mul	a1,a2,a3
2001039c:	01071713          	slli	a4,a4,0x10
200103a0:	00f767b3          	or	a5,a4,a5
200103a4:	00b7fe63          	bgeu	a5,a1,200103c0 <__udivdi3+0xac>
200103a8:	010787b3          	add	a5,a5,a6
200103ac:	fff68513          	addi	a0,a3,-1
200103b0:	0107e863          	bltu	a5,a6,200103c0 <__udivdi3+0xac>
200103b4:	00b7f663          	bgeu	a5,a1,200103c0 <__udivdi3+0xac>
200103b8:	ffe68513          	addi	a0,a3,-2
200103bc:	010787b3          	add	a5,a5,a6
200103c0:	40b787b3          	sub	a5,a5,a1
200103c4:	0317f733          	remu	a4,a5,a7
200103c8:	01031313          	slli	t1,t1,0x10
200103cc:	01035313          	srli	t1,t1,0x10
200103d0:	0317d7b3          	divu	a5,a5,a7
200103d4:	01071713          	slli	a4,a4,0x10
200103d8:	00676333          	or	t1,a4,t1
200103dc:	02f606b3          	mul	a3,a2,a5
200103e0:	00078613          	mv	a2,a5
200103e4:	00d37c63          	bgeu	t1,a3,200103fc <__udivdi3+0xe8>
200103e8:	00680333          	add	t1,a6,t1
200103ec:	fff78613          	addi	a2,a5,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
200103f0:	01036663          	bltu	t1,a6,200103fc <__udivdi3+0xe8>
200103f4:	00d37463          	bgeu	t1,a3,200103fc <__udivdi3+0xe8>
200103f8:	ffe78613          	addi	a2,a5,-2
200103fc:	01051513          	slli	a0,a0,0x10
20010400:	00c56533          	or	a0,a0,a2
20010404:	00000593          	li	a1,0
20010408:	0e40006f          	j	200104ec <__udivdi3+0x1d8>
2001040c:	01000537          	lui	a0,0x1000
20010410:	01000713          	li	a4,16
20010414:	f2a66ce3          	bltu	a2,a0,2001034c <__udivdi3+0x38>
20010418:	01800713          	li	a4,24
2001041c:	f31ff06f          	j	2001034c <__udivdi3+0x38>
20010420:	00061663          	bnez	a2,2001042c <__udivdi3+0x118>
20010424:	00100713          	li	a4,1
20010428:	02c75833          	divu	a6,a4,a2
2001042c:	00010737          	lui	a4,0x10
20010430:	0ce87063          	bgeu	a6,a4,200104f0 <__udivdi3+0x1dc>
20010434:	0ff00713          	li	a4,255
20010438:	01077463          	bgeu	a4,a6,20010440 <__udivdi3+0x12c>
2001043c:	00800513          	li	a0,8
20010440:	00a85733          	srl	a4,a6,a0
20010444:	00e686b3          	add	a3,a3,a4
20010448:	0006c703          	lbu	a4,0(a3)
2001044c:	02000613          	li	a2,32
20010450:	00a70733          	add	a4,a4,a0
20010454:	40e606b3          	sub	a3,a2,a4
20010458:	0ae61663          	bne	a2,a4,20010504 <__udivdi3+0x1f0>
2001045c:	410787b3          	sub	a5,a5,a6
20010460:	00100593          	li	a1,1
20010464:	01085893          	srli	a7,a6,0x10
20010468:	01081613          	slli	a2,a6,0x10
2001046c:	01065613          	srli	a2,a2,0x10
20010470:	01035713          	srli	a4,t1,0x10
20010474:	0317f6b3          	remu	a3,a5,a7
20010478:	0317d7b3          	divu	a5,a5,a7
2001047c:	01069693          	slli	a3,a3,0x10
20010480:	00e6e733          	or	a4,a3,a4
20010484:	02f60e33          	mul	t3,a2,a5
20010488:	00078513          	mv	a0,a5
2001048c:	01c77e63          	bgeu	a4,t3,200104a8 <__udivdi3+0x194>
20010490:	01070733          	add	a4,a4,a6
20010494:	fff78513          	addi	a0,a5,-1
20010498:	01076863          	bltu	a4,a6,200104a8 <__udivdi3+0x194>
2001049c:	01c77663          	bgeu	a4,t3,200104a8 <__udivdi3+0x194>
200104a0:	ffe78513          	addi	a0,a5,-2
200104a4:	01070733          	add	a4,a4,a6
200104a8:	41c70733          	sub	a4,a4,t3
200104ac:	031777b3          	remu	a5,a4,a7
200104b0:	01031313          	slli	t1,t1,0x10
200104b4:	01035313          	srli	t1,t1,0x10
200104b8:	03175733          	divu	a4,a4,a7
200104bc:	01079793          	slli	a5,a5,0x10
200104c0:	0067e333          	or	t1,a5,t1
200104c4:	02e606b3          	mul	a3,a2,a4
200104c8:	00070613          	mv	a2,a4
200104cc:	00d37c63          	bgeu	t1,a3,200104e4 <__udivdi3+0x1d0>
200104d0:	00680333          	add	t1,a6,t1
200104d4:	fff70613          	addi	a2,a4,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
200104d8:	01036663          	bltu	t1,a6,200104e4 <__udivdi3+0x1d0>
200104dc:	00d37463          	bgeu	t1,a3,200104e4 <__udivdi3+0x1d0>
200104e0:	ffe70613          	addi	a2,a4,-2
200104e4:	01051513          	slli	a0,a0,0x10
200104e8:	00c56533          	or	a0,a0,a2
200104ec:	00008067          	ret
200104f0:	01000737          	lui	a4,0x1000
200104f4:	01000513          	li	a0,16
200104f8:	f4e864e3          	bltu	a6,a4,20010440 <__udivdi3+0x12c>
200104fc:	01800513          	li	a0,24
20010500:	f41ff06f          	j	20010440 <__udivdi3+0x12c>
20010504:	00d81833          	sll	a6,a6,a3
20010508:	00e7d533          	srl	a0,a5,a4
2001050c:	00d89333          	sll	t1,a7,a3
20010510:	00d797b3          	sll	a5,a5,a3
20010514:	00e8d733          	srl	a4,a7,a4
20010518:	01085893          	srli	a7,a6,0x10
2001051c:	00f76633          	or	a2,a4,a5
20010520:	03157733          	remu	a4,a0,a7
20010524:	01081793          	slli	a5,a6,0x10
20010528:	0107d793          	srli	a5,a5,0x10
2001052c:	01065593          	srli	a1,a2,0x10
20010530:	03155533          	divu	a0,a0,a7
20010534:	01071713          	slli	a4,a4,0x10
20010538:	00b76733          	or	a4,a4,a1
2001053c:	02a786b3          	mul	a3,a5,a0
20010540:	00050593          	mv	a1,a0
20010544:	00d77e63          	bgeu	a4,a3,20010560 <__udivdi3+0x24c>
20010548:	01070733          	add	a4,a4,a6
2001054c:	fff50593          	addi	a1,a0,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fff>
20010550:	01076863          	bltu	a4,a6,20010560 <__udivdi3+0x24c>
20010554:	00d77663          	bgeu	a4,a3,20010560 <__udivdi3+0x24c>
20010558:	ffe50593          	addi	a1,a0,-2
2001055c:	01070733          	add	a4,a4,a6
20010560:	40d706b3          	sub	a3,a4,a3
20010564:	0316f733          	remu	a4,a3,a7
20010568:	01061613          	slli	a2,a2,0x10
2001056c:	01065613          	srli	a2,a2,0x10
20010570:	0316d6b3          	divu	a3,a3,a7
20010574:	01071713          	slli	a4,a4,0x10
20010578:	02d78533          	mul	a0,a5,a3
2001057c:	00c767b3          	or	a5,a4,a2
20010580:	00068713          	mv	a4,a3
20010584:	00a7fe63          	bgeu	a5,a0,200105a0 <__udivdi3+0x28c>
20010588:	010787b3          	add	a5,a5,a6
2001058c:	fff68713          	addi	a4,a3,-1
20010590:	0107e863          	bltu	a5,a6,200105a0 <__udivdi3+0x28c>
20010594:	00a7f663          	bgeu	a5,a0,200105a0 <__udivdi3+0x28c>
20010598:	ffe68713          	addi	a4,a3,-2
2001059c:	010787b3          	add	a5,a5,a6
200105a0:	01059593          	slli	a1,a1,0x10
200105a4:	40a787b3          	sub	a5,a5,a0
200105a8:	00e5e5b3          	or	a1,a1,a4
200105ac:	eb9ff06f          	j	20010464 <__udivdi3+0x150>
200105b0:	18d5e663          	bltu	a1,a3,2001073c <__udivdi3+0x428>
200105b4:	00010737          	lui	a4,0x10
200105b8:	04e6f463          	bgeu	a3,a4,20010600 <__udivdi3+0x2ec>
200105bc:	0ff00713          	li	a4,255
200105c0:	00d735b3          	sltu	a1,a4,a3
200105c4:	00359593          	slli	a1,a1,0x3
200105c8:	20015737          	lui	a4,0x20015
200105cc:	00b6d533          	srl	a0,a3,a1
200105d0:	ee070713          	addi	a4,a4,-288 # 20014ee0 <__clz_tab>
200105d4:	00a70733          	add	a4,a4,a0
200105d8:	00074703          	lbu	a4,0(a4)
200105dc:	02000513          	li	a0,32
200105e0:	00b70733          	add	a4,a4,a1
200105e4:	40e505b3          	sub	a1,a0,a4
200105e8:	02e51663          	bne	a0,a4,20010614 <__udivdi3+0x300>
200105ec:	00100513          	li	a0,1
200105f0:	eef6eee3          	bltu	a3,a5,200104ec <__udivdi3+0x1d8>
200105f4:	00c8b533          	sltu	a0,a7,a2
200105f8:	00154513          	xori	a0,a0,1
200105fc:	ef1ff06f          	j	200104ec <__udivdi3+0x1d8>
20010600:	01000737          	lui	a4,0x1000
20010604:	01000593          	li	a1,16
20010608:	fce6e0e3          	bltu	a3,a4,200105c8 <__udivdi3+0x2b4>
2001060c:	01800593          	li	a1,24
20010610:	fb9ff06f          	j	200105c8 <__udivdi3+0x2b4>
20010614:	00e65833          	srl	a6,a2,a4
20010618:	00b696b3          	sll	a3,a3,a1
2001061c:	00d86833          	or	a6,a6,a3
20010620:	00e7de33          	srl	t3,a5,a4
20010624:	01085e93          	srli	t4,a6,0x10
20010628:	03de76b3          	remu	a3,t3,t4
2001062c:	00b797b3          	sll	a5,a5,a1
20010630:	00e8d733          	srl	a4,a7,a4
20010634:	00b61333          	sll	t1,a2,a1
20010638:	00f76633          	or	a2,a4,a5
2001063c:	01081793          	slli	a5,a6,0x10
20010640:	0107d793          	srli	a5,a5,0x10
20010644:	01065713          	srli	a4,a2,0x10
20010648:	03de5e33          	divu	t3,t3,t4
2001064c:	01069693          	slli	a3,a3,0x10
20010650:	00e6e733          	or	a4,a3,a4
20010654:	03c78f33          	mul	t5,a5,t3
20010658:	000e0513          	mv	a0,t3
2001065c:	01e77e63          	bgeu	a4,t5,20010678 <__udivdi3+0x364>
20010660:	01070733          	add	a4,a4,a6
20010664:	fffe0513          	addi	a0,t3,-1
20010668:	01076863          	bltu	a4,a6,20010678 <__udivdi3+0x364>
2001066c:	01e77663          	bgeu	a4,t5,20010678 <__udivdi3+0x364>
20010670:	ffee0513          	addi	a0,t3,-2
20010674:	01070733          	add	a4,a4,a6
20010678:	41e70733          	sub	a4,a4,t5
2001067c:	03d776b3          	remu	a3,a4,t4
20010680:	03d75733          	divu	a4,a4,t4
20010684:	01069693          	slli	a3,a3,0x10
20010688:	02e78e33          	mul	t3,a5,a4
2001068c:	01061793          	slli	a5,a2,0x10
20010690:	0107d793          	srli	a5,a5,0x10
20010694:	00f6e7b3          	or	a5,a3,a5
20010698:	00070613          	mv	a2,a4
2001069c:	01c7fe63          	bgeu	a5,t3,200106b8 <__udivdi3+0x3a4>
200106a0:	010787b3          	add	a5,a5,a6
200106a4:	fff70613          	addi	a2,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fff>
200106a8:	0107e863          	bltu	a5,a6,200106b8 <__udivdi3+0x3a4>
200106ac:	01c7f663          	bgeu	a5,t3,200106b8 <__udivdi3+0x3a4>
200106b0:	ffe70613          	addi	a2,a4,-2
200106b4:	010787b3          	add	a5,a5,a6
200106b8:	01051513          	slli	a0,a0,0x10
200106bc:	00010eb7          	lui	t4,0x10
200106c0:	00c56533          	or	a0,a0,a2
200106c4:	fffe8693          	addi	a3,t4,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
200106c8:	00d57833          	and	a6,a0,a3
200106cc:	01055613          	srli	a2,a0,0x10
200106d0:	00d376b3          	and	a3,t1,a3
200106d4:	01035313          	srli	t1,t1,0x10
200106d8:	41c787b3          	sub	a5,a5,t3
200106dc:	02d80e33          	mul	t3,a6,a3
200106e0:	02d606b3          	mul	a3,a2,a3
200106e4:	010e5713          	srli	a4,t3,0x10
200106e8:	02680833          	mul	a6,a6,t1
200106ec:	00d80833          	add	a6,a6,a3
200106f0:	01070733          	add	a4,a4,a6
200106f4:	02660633          	mul	a2,a2,t1
200106f8:	00d77463          	bgeu	a4,a3,20010700 <__udivdi3+0x3ec>
200106fc:	01d60633          	add	a2,a2,t4
20010700:	01075693          	srli	a3,a4,0x10
20010704:	00c68633          	add	a2,a3,a2
20010708:	02c7e663          	bltu	a5,a2,20010734 <__udivdi3+0x420>
2001070c:	cec79ce3          	bne	a5,a2,20010404 <__udivdi3+0xf0>
20010710:	000107b7          	lui	a5,0x10
20010714:	fff78793          	addi	a5,a5,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
20010718:	00f77733          	and	a4,a4,a5
2001071c:	01071713          	slli	a4,a4,0x10
20010720:	00fe7e33          	and	t3,t3,a5
20010724:	00b898b3          	sll	a7,a7,a1
20010728:	01c70733          	add	a4,a4,t3
2001072c:	00000593          	li	a1,0
20010730:	dae8fee3          	bgeu	a7,a4,200104ec <__udivdi3+0x1d8>
20010734:	fff50513          	addi	a0,a0,-1
20010738:	ccdff06f          	j	20010404 <__udivdi3+0xf0>
2001073c:	00000593          	li	a1,0
20010740:	00000513          	li	a0,0
20010744:	da9ff06f          	j	200104ec <__udivdi3+0x1d8>

20010748 <__umoddi3>:
20010748:	00050e93          	mv	t4,a0
2001074c:	00058313          	mv	t1,a1
20010750:	00060813          	mv	a6,a2
20010754:	00068793          	mv	a5,a3
20010758:	22069a63          	bnez	a3,2001098c <__umoddi3+0x244>
2001075c:	20015737          	lui	a4,0x20015
20010760:	ee070713          	addi	a4,a4,-288 # 20014ee0 <__clz_tab>
20010764:	0cc5fc63          	bgeu	a1,a2,2001083c <__umoddi3+0xf4>
20010768:	000106b7          	lui	a3,0x10
2001076c:	0ad67e63          	bgeu	a2,a3,20010828 <__umoddi3+0xe0>
20010770:	0ff00693          	li	a3,255
20010774:	00c6f463          	bgeu	a3,a2,2001077c <__umoddi3+0x34>
20010778:	00800793          	li	a5,8
2001077c:	00f656b3          	srl	a3,a2,a5
20010780:	00d70733          	add	a4,a4,a3
20010784:	00074703          	lbu	a4,0(a4)
20010788:	00f707b3          	add	a5,a4,a5
2001078c:	02000713          	li	a4,32
20010790:	40f708b3          	sub	a7,a4,a5
20010794:	00f70c63          	beq	a4,a5,200107ac <__umoddi3+0x64>
20010798:	011315b3          	sll	a1,t1,a7
2001079c:	00fed7b3          	srl	a5,t4,a5
200107a0:	01161833          	sll	a6,a2,a7
200107a4:	00b7e5b3          	or	a1,a5,a1
200107a8:	011e9533          	sll	a0,t4,a7
200107ac:	01085693          	srli	a3,a6,0x10
200107b0:	02d5f7b3          	remu	a5,a1,a3
200107b4:	01081613          	slli	a2,a6,0x10
200107b8:	01065613          	srli	a2,a2,0x10
200107bc:	01055713          	srli	a4,a0,0x10
200107c0:	02d5d5b3          	divu	a1,a1,a3
200107c4:	01079793          	slli	a5,a5,0x10
200107c8:	00e7e733          	or	a4,a5,a4
200107cc:	02b605b3          	mul	a1,a2,a1
200107d0:	00b77a63          	bgeu	a4,a1,200107e4 <__umoddi3+0x9c>
200107d4:	01070733          	add	a4,a4,a6
200107d8:	01076663          	bltu	a4,a6,200107e4 <__umoddi3+0x9c>
200107dc:	00b77463          	bgeu	a4,a1,200107e4 <__umoddi3+0x9c>
200107e0:	01070733          	add	a4,a4,a6
200107e4:	40b70733          	sub	a4,a4,a1
200107e8:	02d777b3          	remu	a5,a4,a3
200107ec:	01051513          	slli	a0,a0,0x10
200107f0:	01055513          	srli	a0,a0,0x10
200107f4:	02d75733          	divu	a4,a4,a3
200107f8:	01079793          	slli	a5,a5,0x10
200107fc:	00a7e533          	or	a0,a5,a0
20010800:	02e60733          	mul	a4,a2,a4
20010804:	00e57a63          	bgeu	a0,a4,20010818 <__umoddi3+0xd0>
20010808:	01050533          	add	a0,a0,a6
2001080c:	01056663          	bltu	a0,a6,20010818 <__umoddi3+0xd0>
20010810:	00e57463          	bgeu	a0,a4,20010818 <__umoddi3+0xd0>
20010814:	01050533          	add	a0,a0,a6
20010818:	40e50533          	sub	a0,a0,a4
2001081c:	01155533          	srl	a0,a0,a7
20010820:	00000593          	li	a1,0
20010824:	00008067          	ret
20010828:	010006b7          	lui	a3,0x1000
2001082c:	01000793          	li	a5,16
20010830:	f4d666e3          	bltu	a2,a3,2001077c <__umoddi3+0x34>
20010834:	01800793          	li	a5,24
20010838:	f45ff06f          	j	2001077c <__umoddi3+0x34>
2001083c:	00061663          	bnez	a2,20010848 <__umoddi3+0x100>
20010840:	00100693          	li	a3,1
20010844:	02c6d833          	divu	a6,a3,a2
20010848:	000106b7          	lui	a3,0x10
2001084c:	12d87663          	bgeu	a6,a3,20010978 <__umoddi3+0x230>
20010850:	0ff00693          	li	a3,255
20010854:	0106f463          	bgeu	a3,a6,2001085c <__umoddi3+0x114>
20010858:	00800793          	li	a5,8
2001085c:	00f856b3          	srl	a3,a6,a5
20010860:	00d70733          	add	a4,a4,a3
20010864:	00074603          	lbu	a2,0(a4)
20010868:	410305b3          	sub	a1,t1,a6
2001086c:	00f60633          	add	a2,a2,a5
20010870:	02000793          	li	a5,32
20010874:	40c788b3          	sub	a7,a5,a2
20010878:	08c78663          	beq	a5,a2,20010904 <__umoddi3+0x1bc>
2001087c:	01181833          	sll	a6,a6,a7
20010880:	00c357b3          	srl	a5,t1,a2
20010884:	011315b3          	sll	a1,t1,a7
20010888:	01085313          	srli	t1,a6,0x10
2001088c:	00ced633          	srl	a2,t4,a2
20010890:	00b66633          	or	a2,a2,a1
20010894:	01081593          	slli	a1,a6,0x10
20010898:	0105d593          	srli	a1,a1,0x10
2001089c:	011e9533          	sll	a0,t4,a7
200108a0:	0267d6b3          	divu	a3,a5,t1
200108a4:	0267f733          	remu	a4,a5,t1
200108a8:	01065793          	srli	a5,a2,0x10
200108ac:	02d586b3          	mul	a3,a1,a3
200108b0:	01071713          	slli	a4,a4,0x10
200108b4:	00f76733          	or	a4,a4,a5
200108b8:	00d77a63          	bgeu	a4,a3,200108cc <__umoddi3+0x184>
200108bc:	01070733          	add	a4,a4,a6
200108c0:	01076663          	bltu	a4,a6,200108cc <__umoddi3+0x184>
200108c4:	00d77463          	bgeu	a4,a3,200108cc <__umoddi3+0x184>
200108c8:	01070733          	add	a4,a4,a6
200108cc:	40d706b3          	sub	a3,a4,a3
200108d0:	0266f733          	remu	a4,a3,t1
200108d4:	01061613          	slli	a2,a2,0x10
200108d8:	01065613          	srli	a2,a2,0x10
200108dc:	0266d6b3          	divu	a3,a3,t1
200108e0:	01071713          	slli	a4,a4,0x10
200108e4:	02d586b3          	mul	a3,a1,a3
200108e8:	00c765b3          	or	a1,a4,a2
200108ec:	00d5fa63          	bgeu	a1,a3,20010900 <__umoddi3+0x1b8>
200108f0:	010585b3          	add	a1,a1,a6
200108f4:	0105e663          	bltu	a1,a6,20010900 <__umoddi3+0x1b8>
200108f8:	00d5f463          	bgeu	a1,a3,20010900 <__umoddi3+0x1b8>
200108fc:	010585b3          	add	a1,a1,a6
20010900:	40d585b3          	sub	a1,a1,a3
20010904:	01085693          	srli	a3,a6,0x10
20010908:	02d5f733          	remu	a4,a1,a3
2001090c:	01081793          	slli	a5,a6,0x10
20010910:	0107d793          	srli	a5,a5,0x10
20010914:	01055613          	srli	a2,a0,0x10
20010918:	02d5d5b3          	divu	a1,a1,a3
2001091c:	01071713          	slli	a4,a4,0x10
20010920:	00c76733          	or	a4,a4,a2
20010924:	02b785b3          	mul	a1,a5,a1
20010928:	00b77a63          	bgeu	a4,a1,2001093c <__umoddi3+0x1f4>
2001092c:	01070733          	add	a4,a4,a6
20010930:	01076663          	bltu	a4,a6,2001093c <__umoddi3+0x1f4>
20010934:	00b77463          	bgeu	a4,a1,2001093c <__umoddi3+0x1f4>
20010938:	01070733          	add	a4,a4,a6
2001093c:	40b705b3          	sub	a1,a4,a1
20010940:	02d5f733          	remu	a4,a1,a3
20010944:	01051513          	slli	a0,a0,0x10
20010948:	01055513          	srli	a0,a0,0x10
2001094c:	02d5d5b3          	divu	a1,a1,a3
20010950:	02b785b3          	mul	a1,a5,a1
20010954:	01071793          	slli	a5,a4,0x10
20010958:	00a7e533          	or	a0,a5,a0
2001095c:	00b57a63          	bgeu	a0,a1,20010970 <__umoddi3+0x228>
20010960:	01050533          	add	a0,a0,a6
20010964:	01056663          	bltu	a0,a6,20010970 <__umoddi3+0x228>
20010968:	00b57463          	bgeu	a0,a1,20010970 <__umoddi3+0x228>
2001096c:	01050533          	add	a0,a0,a6
20010970:	40b50533          	sub	a0,a0,a1
20010974:	ea9ff06f          	j	2001081c <__umoddi3+0xd4>
20010978:	010006b7          	lui	a3,0x1000
2001097c:	01000793          	li	a5,16
20010980:	ecd86ee3          	bltu	a6,a3,2001085c <__umoddi3+0x114>
20010984:	01800793          	li	a5,24
20010988:	ed5ff06f          	j	2001085c <__umoddi3+0x114>
2001098c:	e8d5ece3          	bltu	a1,a3,20010824 <__umoddi3+0xdc>
20010990:	000107b7          	lui	a5,0x10
20010994:	04f6f863          	bgeu	a3,a5,200109e4 <__umoddi3+0x29c>
20010998:	0ff00893          	li	a7,255
2001099c:	00d8b7b3          	sltu	a5,a7,a3
200109a0:	00379793          	slli	a5,a5,0x3
200109a4:	20015737          	lui	a4,0x20015
200109a8:	00f6d833          	srl	a6,a3,a5
200109ac:	ee070713          	addi	a4,a4,-288 # 20014ee0 <__clz_tab>
200109b0:	01070733          	add	a4,a4,a6
200109b4:	00074883          	lbu	a7,0(a4)
200109b8:	00f888b3          	add	a7,a7,a5
200109bc:	02000793          	li	a5,32
200109c0:	41178833          	sub	a6,a5,a7
200109c4:	03179a63          	bne	a5,a7,200109f8 <__umoddi3+0x2b0>
200109c8:	0066e463          	bltu	a3,t1,200109d0 <__umoddi3+0x288>
200109cc:	e4ceece3          	bltu	t4,a2,20010824 <__umoddi3+0xdc>
200109d0:	40ce8533          	sub	a0,t4,a2
200109d4:	40d305b3          	sub	a1,t1,a3
200109d8:	00aebeb3          	sltu	t4,t4,a0
200109dc:	41d585b3          	sub	a1,a1,t4
200109e0:	e45ff06f          	j	20010824 <__umoddi3+0xdc>
200109e4:	01000737          	lui	a4,0x1000
200109e8:	01000793          	li	a5,16
200109ec:	fae6ece3          	bltu	a3,a4,200109a4 <__umoddi3+0x25c>
200109f0:	01800793          	li	a5,24
200109f4:	fb1ff06f          	j	200109a4 <__umoddi3+0x25c>
200109f8:	011657b3          	srl	a5,a2,a7
200109fc:	010696b3          	sll	a3,a3,a6
20010a00:	00d7ee33          	or	t3,a5,a3
20010a04:	01135f33          	srl	t5,t1,a7
20010a08:	011ed7b3          	srl	a5,t4,a7
20010a0c:	010e9533          	sll	a0,t4,a6
20010a10:	010e5e93          	srli	t4,t3,0x10
20010a14:	010315b3          	sll	a1,t1,a6
20010a18:	03df5333          	divu	t1,t5,t4
20010a1c:	00b7e7b3          	or	a5,a5,a1
20010a20:	010e1593          	slli	a1,t3,0x10
20010a24:	0105d593          	srli	a1,a1,0x10
20010a28:	0107d713          	srli	a4,a5,0x10
20010a2c:	01061633          	sll	a2,a2,a6
20010a30:	03df76b3          	remu	a3,t5,t4
20010a34:	02658f33          	mul	t5,a1,t1
20010a38:	01069693          	slli	a3,a3,0x10
20010a3c:	00e6e733          	or	a4,a3,a4
20010a40:	00030693          	mv	a3,t1
20010a44:	01e77e63          	bgeu	a4,t5,20010a60 <__umoddi3+0x318>
20010a48:	01c70733          	add	a4,a4,t3
20010a4c:	fff30693          	addi	a3,t1,-1
20010a50:	01c76863          	bltu	a4,t3,20010a60 <__umoddi3+0x318>
20010a54:	01e77663          	bgeu	a4,t5,20010a60 <__umoddi3+0x318>
20010a58:	ffe30693          	addi	a3,t1,-2
20010a5c:	01c70733          	add	a4,a4,t3
20010a60:	41e70733          	sub	a4,a4,t5
20010a64:	03d77333          	remu	t1,a4,t4
20010a68:	01079793          	slli	a5,a5,0x10
20010a6c:	0107d793          	srli	a5,a5,0x10
20010a70:	03d75733          	divu	a4,a4,t4
20010a74:	01031313          	slli	t1,t1,0x10
20010a78:	00f36333          	or	t1,t1,a5
20010a7c:	02e585b3          	mul	a1,a1,a4
20010a80:	00070793          	mv	a5,a4
20010a84:	00b37e63          	bgeu	t1,a1,20010aa0 <__umoddi3+0x358>
20010a88:	01c30333          	add	t1,t1,t3
20010a8c:	fff70793          	addi	a5,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fff>
20010a90:	01c36863          	bltu	t1,t3,20010aa0 <__umoddi3+0x358>
20010a94:	00b37663          	bgeu	t1,a1,20010aa0 <__umoddi3+0x358>
20010a98:	ffe70793          	addi	a5,a4,-2
20010a9c:	01c30333          	add	t1,t1,t3
20010aa0:	01069693          	slli	a3,a3,0x10
20010aa4:	00010f37          	lui	t5,0x10
20010aa8:	00f6e6b3          	or	a3,a3,a5
20010aac:	40b305b3          	sub	a1,t1,a1
20010ab0:	ffff0313          	addi	t1,t5,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
20010ab4:	0066feb3          	and	t4,a3,t1
20010ab8:	01065713          	srli	a4,a2,0x10
20010abc:	0106d693          	srli	a3,a3,0x10
20010ac0:	00667333          	and	t1,a2,t1
20010ac4:	026e87b3          	mul	a5,t4,t1
20010ac8:	02668333          	mul	t1,a3,t1
20010acc:	02ee8eb3          	mul	t4,t4,a4
20010ad0:	02e686b3          	mul	a3,a3,a4
20010ad4:	006e8eb3          	add	t4,t4,t1
20010ad8:	0107d713          	srli	a4,a5,0x10
20010adc:	01d70733          	add	a4,a4,t4
20010ae0:	00677463          	bgeu	a4,t1,20010ae8 <__umoddi3+0x3a0>
20010ae4:	01e686b3          	add	a3,a3,t5
20010ae8:	01075313          	srli	t1,a4,0x10
20010aec:	00d306b3          	add	a3,t1,a3
20010af0:	00010337          	lui	t1,0x10
20010af4:	fff30313          	addi	t1,t1,-1 # ffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7fff>
20010af8:	00677733          	and	a4,a4,t1
20010afc:	01071713          	slli	a4,a4,0x10
20010b00:	0067f7b3          	and	a5,a5,t1
20010b04:	00f707b3          	add	a5,a4,a5
20010b08:	00d5e663          	bltu	a1,a3,20010b14 <__umoddi3+0x3cc>
20010b0c:	00d59e63          	bne	a1,a3,20010b28 <__umoddi3+0x3e0>
20010b10:	00f57c63          	bgeu	a0,a5,20010b28 <__umoddi3+0x3e0>
20010b14:	40c78633          	sub	a2,a5,a2
20010b18:	00c7b7b3          	sltu	a5,a5,a2
20010b1c:	01c787b3          	add	a5,a5,t3
20010b20:	40f686b3          	sub	a3,a3,a5
20010b24:	00060793          	mv	a5,a2
20010b28:	40f507b3          	sub	a5,a0,a5
20010b2c:	00f53533          	sltu	a0,a0,a5
20010b30:	40d585b3          	sub	a1,a1,a3
20010b34:	40a585b3          	sub	a1,a1,a0
20010b38:	011598b3          	sll	a7,a1,a7
20010b3c:	0107d533          	srl	a0,a5,a6
20010b40:	00a8e533          	or	a0,a7,a0
20010b44:	0105d5b3          	srl	a1,a1,a6
20010b48:	cddff06f          	j	20010824 <__umoddi3+0xdc>

20010b4c <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
20010b4c:	00008067          	ret

20010b50 <__zt_monitor_thread>:
    memcpy(data, meta->channel, meta->channel_size);
    k_sem_give(meta->semaphore);
    return 0;
}
static void __zt_monitor_thread(void)
{
20010b50:	fc010113          	addi	sp,sp,-64
20010b54:	02912a23          	sw	s1,52(sp)
    zt_channel_index_t idx = 0;
    while (1) {
        k_msgq_get(&__zt_channels_changed_msgq, &idx, K_FOREVER);
        printk("idx %d\n", idx);
        if (idx < ZT_CHANNEL_COUNT) {
            struct metadata *meta = __zt_channels_lookup_table[idx];
20010b58:	800024b7          	lui	s1,0x80002
{
20010b5c:	03312623          	sw	s3,44(sp)
20010b60:	03412423          	sw	s4,40(sp)
20010b64:	03512223          	sw	s5,36(sp)
20010b68:	03612023          	sw	s6,32(sp)
20010b6c:	01712e23          	sw	s7,28(sp)
20010b70:	02112e23          	sw	ra,60(sp)
20010b74:	02812c23          	sw	s0,56(sp)
20010b78:	03212823          	sw	s2,48(sp)
    zt_channel_index_t idx = 0;
20010b7c:	000107a3          	sb	zero,15(sp)
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&msgq, *(uintptr_t *)&data, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
20010b80:	80002a37          	lui	s4,0x80002
        printk("idx %d\n", idx);
20010b84:	20015ab7          	lui	s5,0x20015
        if (idx < ZT_CHANNEL_COUNT) {
20010b88:	00200b13          	li	s6,2
                LOG_INF("[ZT-THREAD]: Received pend_callback from a channel(#%d) "
                        "without changes!",
                        idx);
            }
        } else {
            LOG_INF("[ZT-THREAD]: Received an invalid ID channel #%d", idx);
20010b8c:	200159b7          	lui	s3,0x20015
            struct metadata *meta = __zt_channels_lookup_table[idx];
20010b90:	63c48493          	addi	s1,s1,1596 # 8000263c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000263d>
                LOG_INF("[ZT-THREAD]: Received pend_callback from a channel(#%d) "
20010b94:	20015bb7          	lui	s7,0x20015
20010b98:	fff00613          	li	a2,-1
20010b9c:	fff00693          	li	a3,-1
20010ba0:	00f10593          	addi	a1,sp,15
20010ba4:	788a0513          	addi	a0,s4,1928 # 80002788 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002789>
20010ba8:	59d020ef          	jal	ra,20013944 <z_impl_k_msgq_get>
        printk("idx %d\n", idx);
20010bac:	00f14583          	lbu	a1,15(sp)
20010bb0:	fe0a8513          	addi	a0,s5,-32 # 20014fe0 <__clz_tab+0x100>
20010bb4:	484000ef          	jal	ra,20011038 <printk>
        if (idx < ZT_CHANNEL_COUNT) {
20010bb8:	00f14603          	lbu	a2,15(sp)
20010bbc:	04cb6a63          	bltu	s6,a2,20010c10 <__zt_monitor_thread+0xc0>
            struct metadata *meta = __zt_channels_lookup_table[idx];
20010bc0:	00261793          	slli	a5,a2,0x2
20010bc4:	00f487b3          	add	a5,s1,a5
20010bc8:	0007a903          	lw	s2,0(a5) # 10000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x8000>
            if (meta->flag.pend_callback) {
20010bcc:	00494783          	lbu	a5,4(s2)
20010bd0:	02078863          	beqz	a5,20010c00 <__zt_monitor_thread+0xb0>
                struct k_msgq **cursor = meta->subscribers;
20010bd4:	01492403          	lw	s0,20(s2)
                for (struct k_msgq *s = *cursor; s != NULL; ++cursor, s = *cursor) {
20010bd8:	00042503          	lw	a0,0(s0)
20010bdc:	00051663          	bnez	a0,20010be8 <__zt_monitor_thread+0x98>
                meta->flag.pend_callback = false;
20010be0:	00090223          	sb	zero,4(s2)
20010be4:	fb5ff06f          	j	20010b98 <__zt_monitor_thread+0x48>
	return z_impl_k_msgq_put(msgq, data, timeout);
20010be8:	00700613          	li	a2,7
20010bec:	00000693          	li	a3,0
20010bf0:	00f10593          	addi	a1,sp,15
20010bf4:	439020ef          	jal	ra,2001382c <z_impl_k_msgq_put>
                for (struct k_msgq *s = *cursor; s != NULL; ++cursor, s = *cursor) {
20010bf8:	00440413          	addi	s0,s0,4
20010bfc:	fddff06f          	j	20010bd8 <__zt_monitor_thread+0x88>
                LOG_INF("[ZT-THREAD]: Received pend_callback from a channel(#%d) "
20010c00:	04900593          	li	a1,73
20010c04:	fe8b8513          	addi	a0,s7,-24 # 20014fe8 <__clz_tab+0x108>
            LOG_INF("[ZT-THREAD]: Received an invalid ID channel #%d", idx);
20010c08:	5d4010ef          	jal	ra,200121dc <z_log_minimal_printk>
    while (1) {
20010c0c:	f8dff06f          	j	20010b98 <__zt_monitor_thread+0x48>
            LOG_INF("[ZT-THREAD]: Received an invalid ID channel #%d", idx);
20010c10:	04900593          	li	a1,73
20010c14:	03898513          	addi	a0,s3,56 # 20015038 <__clz_tab+0x158>
20010c18:	ff1ff06f          	j	20010c08 <__zt_monitor_thread+0xb8>

20010c1c <zt_channels_instance>:
    return &__zt_channels;
20010c1c:	80002537          	lui	a0,0x80002
}
20010c20:	5e450513          	addi	a0,a0,1508 # 800025e4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800025e5>
20010c24:	00008067          	ret

20010c28 <__zt_chan_pub>:
    if ((meta->channel == NULL) || (data == NULL) || (data_size == 0)) {
20010c28:	00c52783          	lw	a5,12(a0)
{
20010c2c:	fe010113          	addi	sp,sp,-32
20010c30:	00912a23          	sw	s1,20(sp)
20010c34:	00112e23          	sw	ra,28(sp)
20010c38:	00812c23          	sw	s0,24(sp)
20010c3c:	01212823          	sw	s2,16(sp)
20010c40:	01312623          	sw	s3,12(sp)
20010c44:	01412423          	sw	s4,8(sp)
        return -1;
20010c48:	fff00493          	li	s1,-1
    if ((meta->channel == NULL) || (data == NULL) || (data_size == 0)) {
20010c4c:	04078a63          	beqz	a5,20010ca0 <__zt_chan_pub+0x78>
20010c50:	00058913          	mv	s2,a1
        return -1;
20010c54:	fff00493          	li	s1,-1
    if ((meta->channel == NULL) || (data == NULL) || (data_size == 0)) {
20010c58:	04058463          	beqz	a1,20010ca0 <__zt_chan_pub+0x78>
20010c5c:	00060993          	mv	s3,a2
20010c60:	04060063          	beqz	a2,20010ca0 <__zt_chan_pub+0x78>
    if (meta->channel_size != data_size) {
20010c64:	00a55a03          	lhu	s4,10(a0)
20010c68:	00050413          	mv	s0,a0
        return -2;
20010c6c:	ffe00493          	li	s1,-2
    if (meta->channel_size != data_size) {
20010c70:	02ca1863          	bne	s4,a2,20010ca0 <__zt_chan_pub+0x78>
    ZT_CHECK(k_sem_take(meta->semaphore, K_MSEC(200)) != 0, -EBUSY,
20010c74:	01052503          	lw	a0,16(a0)
	return z_impl_k_sem_take(sem, timeout);
20010c78:	01a00593          	li	a1,26
20010c7c:	00000613          	li	a2,0
20010c80:	67d020ef          	jal	ra,20013afc <z_impl_k_sem_take>
20010c84:	00050493          	mv	s1,a0
20010c88:	02050e63          	beqz	a0,20010cc4 <__zt_chan_pub+0x9c>
20010c8c:	20015537          	lui	a0,0x20015
20010c90:	04900593          	li	a1,73
20010c94:	07050513          	addi	a0,a0,112 # 20015070 <__clz_tab+0x190>
20010c98:	544010ef          	jal	ra,200121dc <z_log_minimal_printk>
20010c9c:	ff000493          	li	s1,-16
}
20010ca0:	01c12083          	lw	ra,28(sp)
20010ca4:	01812403          	lw	s0,24(sp)
20010ca8:	01012903          	lw	s2,16(sp)
20010cac:	00c12983          	lw	s3,12(sp)
20010cb0:	00812a03          	lw	s4,8(sp)
20010cb4:	00048513          	mv	a0,s1
20010cb8:	01412483          	lw	s1,20(sp)
20010cbc:	02010113          	addi	sp,sp,32
20010cc0:	00008067          	ret
    if (meta->flag.on_changed) {  // CHANGE
20010cc4:	00544783          	lbu	a5,5(s0)
20010cc8:	02078463          	beqz	a5,20010cf0 <__zt_chan_pub+0xc8>
        if (memcmp(meta->channel, data, data_size) == 0) {
20010ccc:	00c42503          	lw	a0,12(s0)
20010cd0:	000a0613          	mv	a2,s4
20010cd4:	00090593          	mv	a1,s2
20010cd8:	549010ef          	jal	ra,20012a20 <memcmp>
20010cdc:	00051a63          	bnez	a0,20010cf0 <__zt_chan_pub+0xc8>
            meta->flag.pend_callback = false;
20010ce0:	00040223          	sb	zero,4(s0)
    k_sem_give(meta->semaphore);
20010ce4:	01042503          	lw	a0,16(s0)
	z_impl_k_sem_give(sem);
20010ce8:	5a9020ef          	jal	ra,20013a90 <z_impl_k_sem_give>
}
20010cec:	fb5ff06f          	j	20010ca0 <__zt_chan_pub+0x78>
    memcpy(meta->channel, data, data_size);
20010cf0:	00c42503          	lw	a0,12(s0)
20010cf4:	00098613          	mv	a2,s3
20010cf8:	00090593          	mv	a1,s2
20010cfc:	55d010ef          	jal	ra,20012a58 <memcpy>
    meta->flag.pend_callback = true;
20010d00:	00100793          	li	a5,1
20010d04:	00f40223          	sb	a5,4(s0)
	return z_impl_k_msgq_put(msgq, data, timeout);
20010d08:	80002537          	lui	a0,0x80002
20010d0c:	04000613          	li	a2,64
20010d10:	00000693          	li	a3,0
20010d14:	00840593          	addi	a1,s0,8
20010d18:	78850513          	addi	a0,a0,1928 # 80002788 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002789>
20010d1c:	311020ef          	jal	ra,2001382c <z_impl_k_msgq_put>
    if (error != 0) {
20010d20:	fc0502e3          	beqz	a0,20010ce4 <__zt_chan_pub+0xbc>
        LOG_INF("[Channel #%d] Error sending channels change message to ZT "
20010d24:	00845603          	lhu	a2,8(s0)
20010d28:	20015537          	lui	a0,0x20015
20010d2c:	04900593          	li	a1,73
20010d30:	0a450513          	addi	a0,a0,164 # 200150a4 <__clz_tab+0x1c4>
20010d34:	4a8010ef          	jal	ra,200121dc <z_log_minimal_printk>
20010d38:	fadff06f          	j	20010ce4 <__zt_chan_pub+0xbc>

20010d3c <__zt_chan_read>:
    if ((meta->channel == NULL) || (data == NULL) || (data_size == 0)) {
20010d3c:	00c52783          	lw	a5,12(a0)
{
20010d40:	ff010113          	addi	sp,sp,-16
20010d44:	00812423          	sw	s0,8(sp)
20010d48:	00112623          	sw	ra,12(sp)
20010d4c:	00912223          	sw	s1,4(sp)
20010d50:	01212023          	sw	s2,0(sp)
        return -1;
20010d54:	fff00413          	li	s0,-1
    if ((meta->channel == NULL) || (data == NULL) || (data_size == 0)) {
20010d58:	04078863          	beqz	a5,20010da8 <__zt_chan_read+0x6c>
20010d5c:	00058913          	mv	s2,a1
        return -1;
20010d60:	fff00413          	li	s0,-1
    if ((meta->channel == NULL) || (data == NULL) || (data_size == 0)) {
20010d64:	04058263          	beqz	a1,20010da8 <__zt_chan_read+0x6c>
20010d68:	04060063          	beqz	a2,20010da8 <__zt_chan_read+0x6c>
    if (meta->channel_size != data_size) {
20010d6c:	00a55783          	lhu	a5,10(a0)
20010d70:	00050493          	mv	s1,a0
        return -2;
20010d74:	ffe00413          	li	s0,-2
    if (meta->channel_size != data_size) {
20010d78:	02c79863          	bne	a5,a2,20010da8 <__zt_chan_read+0x6c>
    ZT_CHECK(k_sem_take(meta->semaphore, K_MSEC(200)) != 0, -EBUSY,
20010d7c:	01052503          	lw	a0,16(a0)
	return z_impl_k_sem_take(sem, timeout);
20010d80:	01a00593          	li	a1,26
20010d84:	00000613          	li	a2,0
20010d88:	575020ef          	jal	ra,20013afc <z_impl_k_sem_take>
20010d8c:	00050413          	mv	s0,a0
20010d90:	02050a63          	beqz	a0,20010dc4 <__zt_chan_read+0x88>
20010d94:	20015537          	lui	a0,0x20015
20010d98:	04900593          	li	a1,73
20010d9c:	0ec50513          	addi	a0,a0,236 # 200150ec <__clz_tab+0x20c>
20010da0:	43c010ef          	jal	ra,200121dc <z_log_minimal_printk>
20010da4:	ff000413          	li	s0,-16
}
20010da8:	00c12083          	lw	ra,12(sp)
20010dac:	00040513          	mv	a0,s0
20010db0:	00812403          	lw	s0,8(sp)
20010db4:	00412483          	lw	s1,4(sp)
20010db8:	00012903          	lw	s2,0(sp)
20010dbc:	01010113          	addi	sp,sp,16
20010dc0:	00008067          	ret
    memcpy(data, meta->channel, meta->channel_size);
20010dc4:	00a4d603          	lhu	a2,10(s1)
20010dc8:	00c4a583          	lw	a1,12(s1)
20010dcc:	00090513          	mv	a0,s2
20010dd0:	489010ef          	jal	ra,20012a58 <memcpy>
    k_sem_give(meta->semaphore);
20010dd4:	0104a503          	lw	a0,16(s1)
	z_impl_k_sem_give(sem);
20010dd8:	4b9020ef          	jal	ra,20013a90 <z_impl_k_sem_give>
}
20010ddc:	fcdff06f          	j	20010da8 <__zt_chan_read+0x6c>

20010de0 <core_thread>:
#include "zbus.h"

K_MSGQ_DEFINE(core_queue, sizeof(zt_channel_index_t), 10, sizeof(zt_channel_index_t));

void core_thread(void)
{
20010de0:	fe010113          	addi	sp,sp,-32
20010de4:	00812c23          	sw	s0,24(sp)
20010de8:	00912a23          	sw	s1,20(sp)
20010dec:	01212823          	sw	s2,16(sp)
20010df0:	00112e23          	sw	ra,28(sp)
    zt_channel_index_t idx = 0;
20010df4:	000101a3          	sb	zero,3(sp)
	return z_impl_k_msgq_get(msgq, data, timeout);
20010df8:	800024b7          	lui	s1,0x80002
    while (1) {
        if (!k_msgq_get(&core_queue, &idx, K_FOREVER)) {
            struct sensor_data data = {0};
            zt_chan_read(sensor_data, data);
            printk("Core: sensor {a = %d, b = %d}. Sending pkt\n", data.a, data.b);
20010dfc:	20015937          	lui	s2,0x20015
            struct net_pkt pkt = {.x = !(data.a % 2) ? 'P' : 'I',
                                  .y = !(data.b % 3) ? true : false};
20010e00:	00300413          	li	s0,3
20010e04:	fff00613          	li	a2,-1
20010e08:	fff00693          	li	a3,-1
20010e0c:	00310593          	addi	a1,sp,3
20010e10:	7b048513          	addi	a0,s1,1968 # 800027b0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800027b1>
20010e14:	331020ef          	jal	ra,20013944 <z_impl_k_msgq_get>
        if (!k_msgq_get(&core_queue, &idx, K_FOREVER)) {
20010e18:	fe0516e3          	bnez	a0,20010e04 <core_thread+0x24>
            struct sensor_data data = {0};
20010e1c:	00012423          	sw	zero,8(sp)
20010e20:	00012623          	sw	zero,12(sp)
            zt_chan_read(sensor_data, data);
20010e24:	df9ff0ef          	jal	ra,20010c1c <zt_channels_instance>
20010e28:	00800613          	li	a2,8
20010e2c:	00810593          	addi	a1,sp,8
20010e30:	01c50513          	addi	a0,a0,28
20010e34:	f09ff0ef          	jal	ra,20010d3c <__zt_chan_read>
            printk("Core: sensor {a = %d, b = %d}. Sending pkt\n", data.a, data.b);
20010e38:	00c12603          	lw	a2,12(sp)
20010e3c:	00812583          	lw	a1,8(sp)
20010e40:	15c90513          	addi	a0,s2,348 # 2001515c <__clz_tab+0x27c>
20010e44:	1f4000ef          	jal	ra,20011038 <printk>
            struct net_pkt pkt = {.x = !(data.a % 2) ? 'P' : 'I',
20010e48:	00812783          	lw	a5,8(sp)
20010e4c:	05000713          	li	a4,80
20010e50:	0017f793          	andi	a5,a5,1
20010e54:	00078463          	beqz	a5,20010e5c <core_thread+0x7c>
20010e58:	04900713          	li	a4,73
                                  .y = !(data.b % 3) ? true : false};
20010e5c:	00c12783          	lw	a5,12(sp)
            struct net_pkt pkt = {.x = !(data.a % 2) ? 'P' : 'I',
20010e60:	00e10223          	sb	a4,4(sp)
                                  .y = !(data.b % 3) ? true : false};
20010e64:	0287e7b3          	rem	a5,a5,s0
20010e68:	0017b793          	seqz	a5,a5
20010e6c:	00f102a3          	sb	a5,5(sp)
            zt_chan_pub(net_pkt, pkt);
20010e70:	dadff0ef          	jal	ra,20010c1c <zt_channels_instance>
20010e74:	00200613          	li	a2,2
20010e78:	00410593          	addi	a1,sp,4
20010e7c:	03c50513          	addi	a0,a0,60
20010e80:	da9ff0ef          	jal	ra,20010c28 <__zt_chan_pub>
        if (!k_msgq_get(&core_queue, &idx, K_FOREVER)) {
20010e84:	f81ff06f          	j	20010e04 <core_thread+0x24>

20010e88 <main>:
#include "zbus.h"
#include "zeta_messages.h"


int main()
{
20010e88:	fe010113          	addi	sp,sp,-32
20010e8c:	00112e23          	sw	ra,28(sp)
    struct version v = {0};
20010e90:	00012623          	sw	zero,12(sp)
    zt_chan_read(version, v);
20010e94:	d89ff0ef          	jal	ra,20010c1c <zt_channels_instance>
20010e98:	00400613          	li	a2,4
20010e9c:	00c10593          	addi	a1,sp,12
20010ea0:	e9dff0ef          	jal	ra,20010d3c <__zt_chan_read>

    printk("System version: %d.%d.%d\n", v.major, v.minor, v.build);
20010ea4:	00e15683          	lhu	a3,14(sp)
20010ea8:	00d14603          	lbu	a2,13(sp)
20010eac:	00c14583          	lbu	a1,12(sp)
20010eb0:	20015537          	lui	a0,0x20015
20010eb4:	19850513          	addi	a0,a0,408 # 20015198 <__clz_tab+0x2b8>
20010eb8:	180000ef          	jal	ra,20011038 <printk>
	return z_impl_k_sleep(timeout);
20010ebc:	fff00593          	li	a1,-1
20010ec0:	fff00513          	li	a0,-1
20010ec4:	6b0030ef          	jal	ra,20014574 <z_impl_k_sleep>
    while (1) {
20010ec8:	ff5ff06f          	j	20010ebc <main+0x34>

20010ecc <net_thread>:
 * @brief Summary
 * @details Description
 */

void net_thread(void)
{
20010ecc:	fd010113          	addi	sp,sp,-48
20010ed0:	02812423          	sw	s0,40(sp)
20010ed4:	02912223          	sw	s1,36(sp)
    zt_channel_index_t idx = 0;
    while (1) {
        if (!k_msgq_get(&net_queue, &idx, K_FOREVER)) {
            struct net_pkt pkt = {0};
            zt_chan_read(net_pkt, pkt);
            printk("Net: Parity %c, 3 multiple: %s\n", pkt.x, pkt.y ? "true" : "false");
20010ed8:	20015437          	lui	s0,0x20015
20010edc:	200154b7          	lui	s1,0x20015
{
20010ee0:	03212023          	sw	s2,32(sp)
20010ee4:	01312e23          	sw	s3,28(sp)
20010ee8:	02112623          	sw	ra,44(sp)
    zt_channel_index_t idx = 0;
20010eec:	000105a3          	sb	zero,11(sp)
	return z_impl_k_msgq_get(msgq, data, timeout);
20010ef0:	800029b7          	lui	s3,0x80002
            printk("Net: Parity %c, 3 multiple: %s\n", pkt.x, pkt.y ? "true" : "false");
20010ef4:	20015937          	lui	s2,0x20015
20010ef8:	1b440413          	addi	s0,s0,436 # 200151b4 <__clz_tab+0x2d4>
20010efc:	1bc48493          	addi	s1,s1,444 # 200151bc <__clz_tab+0x2dc>
20010f00:	fff00613          	li	a2,-1
20010f04:	fff00693          	li	a3,-1
20010f08:	00b10593          	addi	a1,sp,11
20010f0c:	7d898513          	addi	a0,s3,2008 # 800027d8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800027d9>
20010f10:	235020ef          	jal	ra,20013944 <z_impl_k_msgq_get>
        if (!k_msgq_get(&net_queue, &idx, K_FOREVER)) {
20010f14:	fe0516e3          	bnez	a0,20010f00 <net_thread+0x34>
            struct net_pkt pkt = {0};
20010f18:	00011623          	sh	zero,12(sp)
            zt_chan_read(net_pkt, pkt);
20010f1c:	d01ff0ef          	jal	ra,20010c1c <zt_channels_instance>
20010f20:	00200613          	li	a2,2
20010f24:	00c10593          	addi	a1,sp,12
20010f28:	03c50513          	addi	a0,a0,60
20010f2c:	e11ff0ef          	jal	ra,20010d3c <__zt_chan_read>
            printk("Net: Parity %c, 3 multiple: %s\n", pkt.x, pkt.y ? "true" : "false");
20010f30:	00d14783          	lbu	a5,13(sp)
20010f34:	00c14583          	lbu	a1,12(sp)
20010f38:	00040613          	mv	a2,s0
20010f3c:	00079463          	bnez	a5,20010f44 <net_thread+0x78>
20010f40:	00048613          	mv	a2,s1
20010f44:	1c490513          	addi	a0,s2,452 # 200151c4 <__clz_tab+0x2e4>
20010f48:	0f0000ef          	jal	ra,20011038 <printk>
        if (!k_msgq_get(&net_queue, &idx, K_FOREVER)) {
20010f4c:	fb5ff06f          	j	20010f00 <net_thread+0x34>

20010f50 <peripheral_thread>:
#include <kernel.h>
#include <sys/printk.h>
#include "zbus.h"

void peripheral_thread(void)
{
20010f50:	fd010113          	addi	sp,sp,-48
20010f54:	01412e23          	sw	s4,28(sp)
	return z_impl_k_sleep(timeout);
20010f58:	0009ca37          	lui	s4,0x9c
20010f5c:	02812423          	sw	s0,40(sp)
20010f60:	03212023          	sw	s2,32(sp)
20010f64:	01512c23          	sw	s5,24(sp)
20010f68:	02112623          	sw	ra,44(sp)
20010f6c:	02912223          	sw	s1,36(sp)
    int a                 = 1;
    int b                 = 3;
    struct sensor_data sd = {0, 0};
20010f70:	00012423          	sw	zero,8(sp)
20010f74:	00012623          	sw	zero,12(sp)
    int a                 = 1;
20010f78:	00100413          	li	s0,1
20010f7c:	400a0a13          	addi	s4,s4,1024 # 9c400 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x94400>
20010f80:	00000a93          	li	s5,0
        k_msleep(5000000);
        ++a;
        sd.a = a;
        ++b;
        sd.b = b;
        printk("Peripheral: sending sensor data\n");
20010f84:	20015937          	lui	s2,0x20015
20010f88:	000a8593          	mv	a1,s5
20010f8c:	000a0513          	mv	a0,s4
20010f90:	5e4030ef          	jal	ra,20014574 <z_impl_k_sleep>
        ++a;
20010f94:	00140493          	addi	s1,s0,1
        printk("Peripheral: sending sensor data\n");
20010f98:	1f490513          	addi	a0,s2,500 # 200151f4 <__clz_tab+0x314>
        sd.b = b;
20010f9c:	00340413          	addi	s0,s0,3
20010fa0:	00812623          	sw	s0,12(sp)
        sd.a = a;
20010fa4:	00912423          	sw	s1,8(sp)
        printk("Peripheral: sending sensor data\n");
20010fa8:	090000ef          	jal	ra,20011038 <printk>
        zt_chan_pub(sensor_data, sd);
20010fac:	c71ff0ef          	jal	ra,20010c1c <zt_channels_instance>
20010fb0:	00800613          	li	a2,8
20010fb4:	00810593          	addi	a1,sp,8
20010fb8:	01c50513          	addi	a0,a0,28
20010fbc:	c6dff0ef          	jal	ra,20010c28 <__zt_chan_pub>
        zt_chan_pub(sensor_data, sd);
20010fc0:	c5dff0ef          	jal	ra,20010c1c <zt_channels_instance>
20010fc4:	00800613          	li	a2,8
20010fc8:	00810593          	addi	a1,sp,8
20010fcc:	01c50513          	addi	a0,a0,28
20010fd0:	c59ff0ef          	jal	ra,20010c28 <__zt_chan_pub>
        ++a;
20010fd4:	00048413          	mv	s0,s1
20010fd8:	fb1ff06f          	j	20010f88 <peripheral_thread+0x38>

20010fdc <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
20010fdc:	00000513          	li	a0,0
20010fe0:	00008067          	ret

20010fe4 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
20010fe4:	0005a783          	lw	a5,0(a1)
20010fe8:	00178793          	addi	a5,a5,1
20010fec:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
20010ff0:	800027b7          	lui	a5,0x80002
20010ff4:	6587a783          	lw	a5,1624(a5) # 80002658 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002659>
20010ff8:	00078067          	jr	a5

20010ffc <__printk_hook_install>:
	_char_out = fn;
20010ffc:	800027b7          	lui	a5,0x80002
20011000:	64a7ac23          	sw	a0,1624(a5) # 80002658 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002659>
}
20011004:	00008067          	ret

20011008 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
20011008:	fe010113          	addi	sp,sp,-32
2001100c:	00050613          	mv	a2,a0
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
20011010:	20011537          	lui	a0,0x20011
{
20011014:	00058693          	mv	a3,a1
	cbvprintf(char_out, &ctx, fmt, ap);
20011018:	fe450513          	addi	a0,a0,-28 # 20010fe4 <char_out>
2001101c:	00c10593          	addi	a1,sp,12
{
20011020:	00112e23          	sw	ra,28(sp)
	struct out_context ctx = { 0 };
20011024:	00012623          	sw	zero,12(sp)
	cbvprintf(char_out, &ctx, fmt, ap);
20011028:	5cc000ef          	jal	ra,200115f4 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
2001102c:	01c12083          	lw	ra,28(sp)
20011030:	02010113          	addi	sp,sp,32
20011034:	00008067          	ret

20011038 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
20011038:	fc010113          	addi	sp,sp,-64
2001103c:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
20011040:	02410593          	addi	a1,sp,36
{
20011044:	00112e23          	sw	ra,28(sp)
20011048:	02c12423          	sw	a2,40(sp)
2001104c:	02d12623          	sw	a3,44(sp)
20011050:	02e12823          	sw	a4,48(sp)
20011054:	02f12a23          	sw	a5,52(sp)
20011058:	03012c23          	sw	a6,56(sp)
2001105c:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
20011060:	00b12623          	sw	a1,12(sp)

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
20011064:	fa5ff0ef          	jal	ra,20011008 <vprintk>
	}
	va_end(ap);
}
20011068:	01c12083          	lw	ra,28(sp)
2001106c:	04010113          	addi	sp,sp,64
20011070:	00008067          	ret

20011074 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
20011074:	ff010113          	addi	sp,sp,-16
20011078:	00050793          	mv	a5,a0
2001107c:	00058513          	mv	a0,a1
20011080:	00060593          	mv	a1,a2
	entry(p1, p2, p3);
20011084:	00068613          	mv	a2,a3
{
20011088:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
2001108c:	000780e7          	jalr	a5
	return z_impl_k_current_get();
20011090:	534030ef          	jal	ra,200145c4 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
20011094:	630030ef          	jal	ra,200146c4 <z_impl_k_thread_abort>

20011098 <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
20011098:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
2001109c:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
200110a0:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
200110a4:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
200110a8:	00f76a63          	bltu	a4,a5,200110bc <chunk_field+0x24>
		return ((uint32_t *)cmem)[f];
200110ac:	00261613          	slli	a2,a2,0x2
200110b0:	00c585b3          	add	a1,a1,a2
200110b4:	0005a503          	lw	a0,0(a1)
200110b8:	00008067          	ret
	} else {
		return ((uint16_t *)cmem)[f];
200110bc:	00161613          	slli	a2,a2,0x1
200110c0:	00c585b3          	add	a1,a1,a2
200110c4:	0005d503          	lhu	a0,0(a1)
	}
}
200110c8:	00008067          	ret

200110cc <chunk_set>:
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
200110cc:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
200110d0:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
200110d4:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
200110d8:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
200110dc:	00f76a63          	bltu	a4,a5,200110f0 <chunk_set+0x24>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
200110e0:	00261613          	slli	a2,a2,0x2
200110e4:	00c585b3          	add	a1,a1,a2
200110e8:	00d5a023          	sw	a3,0(a1)
200110ec:	00008067          	ret
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
200110f0:	00161613          	slli	a2,a2,0x1
200110f4:	00c585b3          	add	a1,a1,a2
200110f8:	00d59023          	sh	a3,0(a1)
	}
}
200110fc:	00008067          	ret

20011100 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
20011100:	ff010113          	addi	sp,sp,-16
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
20011104:	00100613          	li	a2,1
{
20011108:	00112623          	sw	ra,12(sp)
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
2001110c:	f8dff0ef          	jal	ra,20011098 <chunk_field>
}
20011110:	00c12083          	lw	ra,12(sp)
20011114:	00155513          	srli	a0,a0,0x1
20011118:	01010113          	addi	sp,sp,16
2001111c:	00008067          	ret

20011120 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
20011120:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
20011124:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
20011128:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
2001112c:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
20011130:	02f76063          	bltu	a4,a5,20011150 <set_chunk_used+0x30>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
20011134:	0045a783          	lw	a5,4(a1)
		if (used) {
20011138:	00060863          	beqz	a2,20011148 <set_chunk_used+0x28>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
2001113c:	0017e793          	ori	a5,a5,1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
20011140:	00f5a223          	sw	a5,4(a1)
20011144:	00008067          	ret
20011148:	ffe7f793          	andi	a5,a5,-2
2001114c:	ff5ff06f          	j	20011140 <set_chunk_used+0x20>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
20011150:	0025d783          	lhu	a5,2(a1)
		if (used) {
20011154:	00060863          	beqz	a2,20011164 <set_chunk_used+0x44>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
20011158:	0017e793          	ori	a5,a5,1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
2001115c:	00f59123          	sh	a5,2(a1)
		}
	}
}
20011160:	00008067          	ret
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
20011164:	ffe7f793          	andi	a5,a5,-2
20011168:	ff5ff06f          	j	2001115c <set_chunk_used+0x3c>

2001116c <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
2001116c:	00161693          	slli	a3,a2,0x1
20011170:	00100613          	li	a2,1
20011174:	f59ff06f          	j	200110cc <chunk_set>

20011178 <bucket_idx.isra.0>:
static inline size_t chunksz_to_bytes(struct z_heap *h, chunksz_t chunksz_in)
{
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
20011178:	ff010113          	addi	sp,sp,-16
2001117c:	00112623          	sw	ra,12(sp)
	return big_heap(h) ? 8 : 4;
20011180:	000087b7          	lui	a5,0x8
20011184:	02f57863          	bgeu	a0,a5,200111b4 <bucket_idx.isra.0+0x3c>
20011188:	00400793          	li	a5,4
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
2001118c:	00878793          	addi	a5,a5,8 # 8008 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x8>
20011190:	0037d793          	srli	a5,a5,0x3
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
20011194:	00158593          	addi	a1,a1,1
	return 31 - __builtin_clz(usable_sz);
20011198:	40f58533          	sub	a0,a1,a5
2001119c:	92cff0ef          	jal	ra,200102c8 <__clzsi2>
}
200111a0:	00c12083          	lw	ra,12(sp)
200111a4:	01f00793          	li	a5,31
200111a8:	40a78533          	sub	a0,a5,a0
200111ac:	01010113          	addi	sp,sp,16
200111b0:	00008067          	ret
	return big_heap(h) ? 8 : 4;
200111b4:	00800793          	li	a5,8
200111b8:	fd5ff06f          	j	2001118c <bucket_idx.isra.0+0x14>

200111bc <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
200111bc:	fe010113          	addi	sp,sp,-32
200111c0:	01212823          	sw	s2,16(sp)
	return big_heap_chunks(h->end_chunk);
200111c4:	00852903          	lw	s2,8(a0)
200111c8:	00812c23          	sw	s0,24(sp)
200111cc:	00912a23          	sw	s1,20(sp)
200111d0:	00112e23          	sw	ra,28(sp)
200111d4:	00058493          	mv	s1,a1
200111d8:	01312623          	sw	s3,12(sp)
200111dc:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
200111e0:	f21ff0ef          	jal	ra,20011100 <chunk_size>
200111e4:	000087b7          	lui	a5,0x8
200111e8:	00050593          	mv	a1,a0
200111ec:	00f96663          	bltu	s2,a5,200111f8 <free_list_add+0x3c>
	if (!solo_free_header(h, c)) {
200111f0:	00100793          	li	a5,1
200111f4:	0cf50a63          	beq	a0,a5,200112c8 <free_list_add+0x10c>
		int bidx = bucket_idx(h, chunk_size(h, c));
200111f8:	00090513          	mv	a0,s2
200111fc:	f7dff0ef          	jal	ra,20011178 <bucket_idx.isra.0>
	if (b->next == 0U) {
20011200:	00251793          	slli	a5,a0,0x2
20011204:	00f407b3          	add	a5,s0,a5
20011208:	0107a903          	lw	s2,16(a5) # 8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
2001120c:	04091e63          	bnez	s2,20011268 <free_list_add+0xac>
		h->avail_buckets |= (1 << bidx);
20011210:	00100713          	li	a4,1
20011214:	00a71733          	sll	a4,a4,a0
20011218:	00c42503          	lw	a0,12(s0)
	chunk_set(h, c, FREE_PREV, prev);
2001121c:	00048693          	mv	a3,s1
20011220:	00200613          	li	a2,2
20011224:	00e56533          	or	a0,a0,a4
20011228:	00a42623          	sw	a0,12(s0)
2001122c:	00048593          	mv	a1,s1
		b->next = c;
20011230:	0097a823          	sw	s1,16(a5)
20011234:	00040513          	mv	a0,s0
20011238:	e95ff0ef          	jal	ra,200110cc <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
2001123c:	00048693          	mv	a3,s1
20011240:	00300613          	li	a2,3
20011244:	00048593          	mv	a1,s1
	chunk_set(h, c, FREE_PREV, prev);
20011248:	00040513          	mv	a0,s0
		free_list_add_bidx(h, c, bidx);
	}
}
2001124c:	01812403          	lw	s0,24(sp)
20011250:	01c12083          	lw	ra,28(sp)
20011254:	01412483          	lw	s1,20(sp)
20011258:	01012903          	lw	s2,16(sp)
2001125c:	00c12983          	lw	s3,12(sp)
20011260:	02010113          	addi	sp,sp,32
20011264:	e69ff06f          	j	200110cc <chunk_set>
	return chunk_field(h, c, FREE_PREV);
20011268:	00200613          	li	a2,2
2001126c:	00090593          	mv	a1,s2
20011270:	00040513          	mv	a0,s0
20011274:	e25ff0ef          	jal	ra,20011098 <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
20011278:	00050693          	mv	a3,a0
	return chunk_field(h, c, FREE_PREV);
2001127c:	00050993          	mv	s3,a0
	chunk_set(h, c, FREE_PREV, prev);
20011280:	00200613          	li	a2,2
20011284:	00048593          	mv	a1,s1
20011288:	00040513          	mv	a0,s0
2001128c:	e41ff0ef          	jal	ra,200110cc <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
20011290:	00090693          	mv	a3,s2
20011294:	00300613          	li	a2,3
20011298:	00048593          	mv	a1,s1
2001129c:	00040513          	mv	a0,s0
200112a0:	e2dff0ef          	jal	ra,200110cc <chunk_set>
200112a4:	00048693          	mv	a3,s1
200112a8:	00300613          	li	a2,3
200112ac:	00098593          	mv	a1,s3
200112b0:	00040513          	mv	a0,s0
200112b4:	e19ff0ef          	jal	ra,200110cc <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
200112b8:	00048693          	mv	a3,s1
200112bc:	00200613          	li	a2,2
200112c0:	00090593          	mv	a1,s2
200112c4:	f85ff06f          	j	20011248 <free_list_add+0x8c>
200112c8:	01c12083          	lw	ra,28(sp)
200112cc:	01812403          	lw	s0,24(sp)
200112d0:	01412483          	lw	s1,20(sp)
200112d4:	01012903          	lw	s2,16(sp)
200112d8:	00c12983          	lw	s3,12(sp)
200112dc:	02010113          	addi	sp,sp,32
200112e0:	00008067          	ret

200112e4 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
200112e4:	fe010113          	addi	sp,sp,-32
200112e8:	00812c23          	sw	s0,24(sp)
200112ec:	00112e23          	sw	ra,28(sp)
200112f0:	00912a23          	sw	s1,20(sp)
200112f4:	01212823          	sw	s2,16(sp)
200112f8:	01312623          	sw	s3,12(sp)
	return big_heap_bytes(size) ? 8 : 4;
200112fc:	000407b7          	lui	a5,0x40
20011300:	00400413          	li	s0,4
20011304:	00f66463          	bltu	a2,a5,2001130c <sys_heap_init+0x28>
20011308:	00800413          	li	s0,8
	/* Must fit in a 31 bit count of HUNK_UNIT */
	__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
2001130c:	40860433          	sub	s0,a2,s0

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
20011310:	00758493          	addi	s1,a1,7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
20011314:	00858433          	add	s0,a1,s0
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
20011318:	ff84f493          	andi	s1,s1,-8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
2001131c:	ff847413          	andi	s0,s0,-8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
20011320:	40940433          	sub	s0,s0,s1

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
20011324:	00952023          	sw	s1,0(a0)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
20011328:	00345413          	srli	s0,s0,0x3
	h->end_chunk = heap_sz;
2001132c:	0084a423          	sw	s0,8(s1)
	h->avail_buckets = 0;
20011330:	0004a623          	sw	zero,12(s1)

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
20011334:	00040593          	mv	a1,s0
20011338:	00040513          	mv	a0,s0
2001133c:	e3dff0ef          	jal	ra,20011178 <bucket_idx.isra.0>
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
20011340:	00251913          	slli	s2,a0,0x2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
20011344:	01b90913          	addi	s2,s2,27
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
20011348:	00150693          	addi	a3,a0,1
2001134c:	00395913          	srli	s2,s2,0x3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
20011350:	01048713          	addi	a4,s1,16
20011354:	00000793          	li	a5,0
20011358:	0ad7cc63          	blt	a5,a3,20011410 <sys_heap_init+0x12c>
		h->buckets[i].next = 0;
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
2001135c:	00090613          	mv	a2,s2
20011360:	00048513          	mv	a0,s1
20011364:	00000593          	li	a1,0
20011368:	e05ff0ef          	jal	ra,2001116c <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
2001136c:	00000693          	li	a3,0
20011370:	00048513          	mv	a0,s1
20011374:	00000613          	li	a2,0
20011378:	00000593          	li	a1,0
2001137c:	d51ff0ef          	jal	ra,200110cc <chunk_set>
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
20011380:	00048513          	mv	a0,s1
20011384:	00100613          	li	a2,1
20011388:	00000593          	li	a1,0
2001138c:	d95ff0ef          	jal	ra,20011120 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
20011390:	412409b3          	sub	s3,s0,s2
20011394:	00098613          	mv	a2,s3
20011398:	00090593          	mv	a1,s2
2001139c:	00048513          	mv	a0,s1
200113a0:	dcdff0ef          	jal	ra,2001116c <set_chunk_size>
200113a4:	00090693          	mv	a3,s2
200113a8:	00090593          	mv	a1,s2
200113ac:	00048513          	mv	a0,s1
200113b0:	00000613          	li	a2,0
200113b4:	d19ff0ef          	jal	ra,200110cc <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
200113b8:	00040593          	mv	a1,s0
200113bc:	00048513          	mv	a0,s1
200113c0:	00000613          	li	a2,0
200113c4:	da9ff0ef          	jal	ra,2001116c <set_chunk_size>
200113c8:	00098693          	mv	a3,s3
200113cc:	00040593          	mv	a1,s0
200113d0:	00048513          	mv	a0,s1
200113d4:	00000613          	li	a2,0
200113d8:	cf5ff0ef          	jal	ra,200110cc <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
200113dc:	00040593          	mv	a1,s0
200113e0:	00048513          	mv	a0,s1
200113e4:	00100613          	li	a2,1
200113e8:	d39ff0ef          	jal	ra,20011120 <set_chunk_used>

	free_list_add(h, chunk0_size);
}
200113ec:	01812403          	lw	s0,24(sp)
200113f0:	01c12083          	lw	ra,28(sp)
200113f4:	00c12983          	lw	s3,12(sp)
	free_list_add(h, chunk0_size);
200113f8:	00090593          	mv	a1,s2
200113fc:	00048513          	mv	a0,s1
}
20011400:	01012903          	lw	s2,16(sp)
20011404:	01412483          	lw	s1,20(sp)
20011408:	02010113          	addi	sp,sp,32
	free_list_add(h, chunk0_size);
2001140c:	db1ff06f          	j	200111bc <free_list_add>
		h->buckets[i].next = 0;
20011410:	00072023          	sw	zero,0(a4)
	for (int i = 0; i < nb_buckets; i++) {
20011414:	00178793          	addi	a5,a5,1 # 40001 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x38001>
20011418:	00470713          	addi	a4,a4,4
2001141c:	f3dff06f          	j	20011358 <sys_heap_init+0x74>

20011420 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
20011420:	fd010113          	addi	sp,sp,-48
20011424:	02812423          	sw	s0,40(sp)
20011428:	02912223          	sw	s1,36(sp)
2001142c:	03212023          	sw	s2,32(sp)
20011430:	01312e23          	sw	s3,28(sp)
20011434:	01712623          	sw	s7,12(sp)
20011438:	01812423          	sw	s8,8(sp)
2001143c:	01912223          	sw	s9,4(sp)
20011440:	02112623          	sw	ra,44(sp)
20011444:	01412c23          	sw	s4,24(sp)
20011448:	01512a23          	sw	s5,20(sp)
2001144c:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
20011450:	00364783          	lbu	a5,3(a2)
{
20011454:	00070413          	mv	s0,a4
	switch (specifier) {
20011458:	06f00713          	li	a4,111
{
2001145c:	00050c13          	mv	s8,a0
20011460:	00058c93          	mv	s9,a1
20011464:	00060b93          	mv	s7,a2
20011468:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
2001146c:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
20011470:	00800493          	li	s1,8
20011474:	00e78c63          	beq	a5,a4,2001148c <encode_uint+0x6c>
20011478:	0cf76263          	bltu	a4,a5,2001153c <encode_uint+0x11c>
2001147c:	05800713          	li	a4,88
		return 10;
20011480:	00a00493          	li	s1,10
	switch (specifier) {
20011484:	00e79463          	bne	a5,a4,2001148c <encode_uint+0x6c>
		return 16;
20011488:	01000493          	li	s1,16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
2001148c:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
20011490:	00900a13          	li	s4,9
20011494:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
20011498:	00048613          	mv	a2,s1
2001149c:	00000693          	li	a3,0
200114a0:	000c0513          	mv	a0,s8
200114a4:	000c8593          	mv	a1,s9
200114a8:	aa0ff0ef          	jal	ra,20010748 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
200114ac:	0ff57793          	andi	a5,a0,255
200114b0:	0aaa6263          	bltu	s4,a0,20011554 <encode_uint+0x134>
200114b4:	03078793          	addi	a5,a5,48
200114b8:	0ff7f793          	andi	a5,a5,255
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
200114bc:	00048613          	mv	a2,s1
200114c0:	00000693          	li	a3,0
200114c4:	000c0513          	mv	a0,s8
200114c8:	000c8593          	mv	a1,s9
		*--bp = (lsv <= 9) ? ('0' + lsv)
200114cc:	fef40fa3          	sb	a5,-1(s0)
200114d0:	fff40413          	addi	s0,s0,-1
		value /= radix;
200114d4:	e41fe0ef          	jal	ra,20010314 <__udivdi3>
	} while ((value != 0) && (bps < bp));
200114d8:	019a9463          	bne	s5,s9,200114e0 <encode_uint+0xc0>
200114dc:	009c6463          	bltu	s8,s1,200114e4 <encode_uint+0xc4>
200114e0:	06896463          	bltu	s2,s0,20011548 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
200114e4:	000bd783          	lhu	a5,0(s7)
200114e8:	0207f793          	andi	a5,a5,32
200114ec:	00078c63          	beqz	a5,20011504 <encode_uint+0xe4>
		if (radix == 8) {
200114f0:	00800793          	li	a5,8
200114f4:	06f49a63          	bne	s1,a5,20011568 <encode_uint+0x148>
			conv->altform_0 = true;
200114f8:	002bc783          	lbu	a5,2(s7)
200114fc:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
20011500:	00fb8123          	sb	a5,2(s7)
			;
		}
	}

	return bp;
}
20011504:	02c12083          	lw	ra,44(sp)
20011508:	00040513          	mv	a0,s0
2001150c:	02812403          	lw	s0,40(sp)
20011510:	02412483          	lw	s1,36(sp)
20011514:	02012903          	lw	s2,32(sp)
20011518:	01c12983          	lw	s3,28(sp)
2001151c:	01812a03          	lw	s4,24(sp)
20011520:	01412a83          	lw	s5,20(sp)
20011524:	01012b03          	lw	s6,16(sp)
20011528:	00c12b83          	lw	s7,12(sp)
2001152c:	00812c03          	lw	s8,8(sp)
20011530:	00412c83          	lw	s9,4(sp)
20011534:	03010113          	addi	sp,sp,48
20011538:	00008067          	ret
	switch (specifier) {
2001153c:	0f77f793          	andi	a5,a5,247
20011540:	07000713          	li	a4,112
20011544:	f3dff06f          	j	20011480 <encode_uint+0x60>
		value /= radix;
20011548:	00050c13          	mv	s8,a0
2001154c:	00058c93          	mv	s9,a1
20011550:	f49ff06f          	j	20011498 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
20011554:	013b6663          	bltu	s6,s3,20011560 <encode_uint+0x140>
20011558:	03778793          	addi	a5,a5,55
2001155c:	f5dff06f          	j	200114b8 <encode_uint+0x98>
20011560:	05778793          	addi	a5,a5,87
20011564:	f55ff06f          	j	200114b8 <encode_uint+0x98>
		} else if (radix == 16) {
20011568:	01000793          	li	a5,16
2001156c:	f8f49ce3          	bne	s1,a5,20011504 <encode_uint+0xe4>
			conv->altform_0c = true;
20011570:	002bc783          	lbu	a5,2(s7)
20011574:	0107e793          	ori	a5,a5,16
20011578:	f89ff06f          	j	20011500 <encode_uint+0xe0>

2001157c <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
2001157c:	fe010113          	addi	sp,sp,-32
20011580:	00812c23          	sw	s0,24(sp)
20011584:	00912a23          	sw	s1,20(sp)
20011588:	01212823          	sw	s2,16(sp)
2001158c:	01312623          	sw	s3,12(sp)
20011590:	01412423          	sw	s4,8(sp)
20011594:	00112e23          	sw	ra,28(sp)
20011598:	00050993          	mv	s3,a0
2001159c:	00058a13          	mv	s4,a1
200115a0:	00060493          	mv	s1,a2
200115a4:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
200115a8:	00060413          	mv	s0,a2
200115ac:	40940533          	sub	a0,s0,s1
200115b0:	01246863          	bltu	s0,s2,200115c0 <outs+0x44>
200115b4:	02091063          	bnez	s2,200115d4 <outs+0x58>
200115b8:	00044783          	lbu	a5,0(s0)
200115bc:	00078c63          	beqz	a5,200115d4 <outs+0x58>
		int rc = out((int)*sp++, ctx);
200115c0:	00044503          	lbu	a0,0(s0)
200115c4:	000a0593          	mv	a1,s4
200115c8:	00140413          	addi	s0,s0,1
200115cc:	000980e7          	jalr	s3

		if (rc < 0) {
200115d0:	fc055ee3          	bgez	a0,200115ac <outs+0x30>
		}
		++count;
	}

	return (int)count;
}
200115d4:	01c12083          	lw	ra,28(sp)
200115d8:	01812403          	lw	s0,24(sp)
200115dc:	01412483          	lw	s1,20(sp)
200115e0:	01012903          	lw	s2,16(sp)
200115e4:	00c12983          	lw	s3,12(sp)
200115e8:	00812a03          	lw	s4,8(sp)
200115ec:	02010113          	addi	sp,sp,32
200115f0:	00008067          	ret

200115f4 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
200115f4:	f7010113          	addi	sp,sp,-144
200115f8:	07512a23          	sw	s5,116(sp)
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
200115fc:	20015ab7          	lui	s5,0x20015
20011600:	2bca8793          	addi	a5,s5,700 # 200152bc <__clz_tab+0x3dc>
{
20011604:	07612823          	sw	s6,112(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
20011608:	20015b37          	lui	s6,0x20015
{
2001160c:	07712623          	sw	s7,108(sp)
20011610:	07812423          	sw	s8,104(sp)
		switch (conv->specifier) {
20011614:	00f12223          	sw	a5,4(sp)
				conv->specifier = 'x';

				goto prec_int_pad0;
			}

			bps = "(nil)";
20011618:	20015bb7          	lui	s7,0x20015
	switch ((enum length_mod_enum)conv->length_mod) {
2001161c:	314b0793          	addi	a5,s6,788 # 20015314 <__clz_tab+0x434>
			bpe = bps + 5;
20011620:	20015c37          	lui	s8,0x20015
{
20011624:	09212023          	sw	s2,128(sp)
20011628:	07312e23          	sw	s3,124(sp)
2001162c:	07912223          	sw	s9,100(sp)
20011630:	07a12023          	sw	s10,96(sp)
20011634:	05b12e23          	sw	s11,92(sp)
20011638:	08112623          	sw	ra,140(sp)
2001163c:	08812423          	sw	s0,136(sp)
20011640:	08912223          	sw	s1,132(sp)
20011644:	07412c23          	sw	s4,120(sp)
20011648:	00050913          	mv	s2,a0
2001164c:	00058993          	mv	s3,a1
20011650:	00060d13          	mv	s10,a2
20011654:	00068c93          	mv	s9,a3
	size_t count = 0;
20011658:	00000d93          	li	s11,0
	switch ((enum length_mod_enum)conv->length_mod) {
2001165c:	00f12423          	sw	a5,8(sp)
			bps = "(nil)";
20011660:	230b8b93          	addi	s7,s7,560 # 20015230 <__clz_tab+0x350>
			bpe = bps + 5;
20011664:	235c0c13          	addi	s8,s8,565 # 20015235 <__clz_tab+0x355>
	while (*fp != 0) {
20011668:	000d4403          	lbu	s0,0(s10)
2001166c:	00041663          	bnez	s0,20011678 <cbvprintf+0x84>
			OUTC(' ');
			--width;
		}
	}

	return count;
20011670:	000d8513          	mv	a0,s11
20011674:	2290006f          	j	2001209c <cbvprintf+0xaa8>
		if (*fp != '%') {
20011678:	02500793          	li	a5,37
			OUTC(*fp++);
2001167c:	001d0a13          	addi	s4,s10,1
		if (*fp != '%') {
20011680:	02f40463          	beq	s0,a5,200116a8 <cbvprintf+0xb4>
			OUTC(*fp++);
20011684:	00098593          	mv	a1,s3
20011688:	00040513          	mv	a0,s0
2001168c:	000900e7          	jalr	s2
20011690:	200546e3          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011694:	001d8d93          	addi	s11,s11,1
			continue;
20011698:	000c8413          	mv	s0,s9
2001169c:	00040c93          	mv	s9,s0
200116a0:	000a0d13          	mv	s10,s4
200116a4:	fc5ff06f          	j	20011668 <cbvprintf+0x74>
		} state = {
200116a8:	02000613          	li	a2,32
200116ac:	00000593          	li	a1,0
200116b0:	03010513          	addi	a0,sp,48
200116b4:	444010ef          	jal	ra,20012af8 <memset>
	if (*sp == '%') {
200116b8:	001d4783          	lbu	a5,1(s10)
200116bc:	0e879263          	bne	a5,s0,200117a0 <cbvprintf+0x1ac>
		conv->specifier = *sp++;
200116c0:	002d0a13          	addi	s4,s10,2
200116c4:	04f101a3          	sb	a5,67(sp)
		if (conv->width_star) {
200116c8:	04015783          	lhu	a5,64(sp)
200116cc:	1007f713          	andi	a4,a5,256
200116d0:	52070e63          	beqz	a4,20011c0c <cbvprintf+0x618>
			width = va_arg(ap, int);
200116d4:	000ca483          	lw	s1,0(s9)
200116d8:	004c8413          	addi	s0,s9,4
			if (width < 0) {
200116dc:	0004d863          	bgez	s1,200116ec <cbvprintf+0xf8>
				conv->flag_dash = true;
200116e0:	0047e793          	ori	a5,a5,4
200116e4:	04f11023          	sh	a5,64(sp)
				width = -width;
200116e8:	409004b3          	neg	s1,s1
		if (conv->prec_star) {
200116ec:	04015703          	lhu	a4,64(sp)
200116f0:	40077793          	andi	a5,a4,1024
200116f4:	52078c63          	beqz	a5,20011c2c <cbvprintf+0x638>
			int arg = va_arg(ap, int);
200116f8:	00042a83          	lw	s5,0(s0)
200116fc:	00440413          	addi	s0,s0,4
			if (arg < 0) {
20011700:	000ad863          	bgez	s5,20011710 <cbvprintf+0x11c>
				conv->prec_present = false;
20011704:	dff77713          	andi	a4,a4,-513
20011708:	04e11023          	sh	a4,64(sp)
		int precision = -1;
2001170c:	fff00a93          	li	s5,-1
			= (enum specifier_cat_enum)conv->specifier_cat;
20011710:	04012583          	lw	a1,64(sp)
		conv->pad0_value = 0;
20011714:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
20011718:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
2001171c:	0105d693          	srli	a3,a1,0x10
			= (enum length_mod_enum)conv->length_mod;
20011720:	00b5d713          	srli	a4,a1,0xb
		enum specifier_cat_enum specifier_cat
20011724:	0076f693          	andi	a3,a3,7
		if (specifier_cat == SPECIFIER_SINT) {
20011728:	00100613          	li	a2,1
			= (enum length_mod_enum)conv->length_mod;
2001172c:	00f77713          	andi	a4,a4,15
		if (specifier_cat == SPECIFIER_SINT) {
20011730:	56c69263          	bne	a3,a2,20011c94 <cbvprintf+0x6a0>
			switch (length_mod) {
20011734:	00500613          	li	a2,5
20011738:	50c70e63          	beq	a4,a2,20011c54 <cbvprintf+0x660>
2001173c:	00e66a63          	bltu	a2,a4,20011750 <cbvprintf+0x15c>
20011740:	00300693          	li	a3,3
20011744:	4ed70e63          	beq	a4,a3,20011c40 <cbvprintf+0x64c>
20011748:	00400693          	li	a3,4
2001174c:	50d70463          	beq	a4,a3,20011c54 <cbvprintf+0x660>
					(sint_value_type)va_arg(ap, ptrdiff_t);
20011750:	00042683          	lw	a3,0(s0)
20011754:	00440413          	addi	s0,s0,4
20011758:	02d12823          	sw	a3,48(sp)
2001175c:	41f6d693          	srai	a3,a3,0x1f
20011760:	02d12a23          	sw	a3,52(sp)
			if (length_mod == LENGTH_HH) {
20011764:	00100693          	li	a3,1
20011768:	50d71863          	bne	a4,a3,20011c78 <cbvprintf+0x684>
				value->uint = (unsigned char)value->uint;
2001176c:	03014683          	lbu	a3,48(sp)
				value->uint = (unsigned short)value->uint;
20011770:	02d12823          	sw	a3,48(sp)
20011774:	02012a23          	sw	zero,52(sp)
		if (conv->invalid || conv->unsupported) {
20011778:	0035f593          	andi	a1,a1,3
2001177c:	5e058863          	beqz	a1,20011d6c <cbvprintf+0x778>
			OUTS(sp, fp);
20011780:	000a0693          	mv	a3,s4
20011784:	000d0613          	mv	a2,s10
20011788:	00098593          	mv	a1,s3
2001178c:	00090513          	mv	a0,s2
20011790:	dedff0ef          	jal	ra,2001157c <outs>
20011794:	100544e3          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011798:	00ad8db3          	add	s11,s11,a0
			continue;
2001179c:	f01ff06f          	j	2001169c <cbvprintf+0xa8>
200117a0:	00000513          	li	a0,0
200117a4:	00000693          	li	a3,0
200117a8:	00000593          	li	a1,0
200117ac:	00000613          	li	a2,0
200117b0:	00000713          	li	a4,0
		switch (*sp) {
200117b4:	02b00813          	li	a6,43
200117b8:	02d00893          	li	a7,45
200117bc:	03000313          	li	t1,48
200117c0:	02000e13          	li	t3,32
200117c4:	02300e93          	li	t4,35
200117c8:	000a4783          	lbu	a5,0(s4)
200117cc:	13078863          	beq	a5,a6,200118fc <cbvprintf+0x308>
200117d0:	10f86e63          	bltu	a6,a5,200118ec <cbvprintf+0x2f8>
200117d4:	13c78a63          	beq	a5,t3,20011908 <cbvprintf+0x314>
200117d8:	13d78c63          	beq	a5,t4,20011910 <cbvprintf+0x31c>
200117dc:	00070863          	beqz	a4,200117ec <cbvprintf+0x1f8>
200117e0:	04015703          	lhu	a4,64(sp)
200117e4:	00476713          	ori	a4,a4,4
200117e8:	04e11023          	sh	a4,64(sp)
200117ec:	00060863          	beqz	a2,200117fc <cbvprintf+0x208>
200117f0:	04015703          	lhu	a4,64(sp)
200117f4:	00876713          	ori	a4,a4,8
200117f8:	04e11023          	sh	a4,64(sp)
200117fc:	00058863          	beqz	a1,2001180c <cbvprintf+0x218>
20011800:	04015703          	lhu	a4,64(sp)
20011804:	01076713          	ori	a4,a4,16
20011808:	04e11023          	sh	a4,64(sp)
2001180c:	00068863          	beqz	a3,2001181c <cbvprintf+0x228>
20011810:	04015703          	lhu	a4,64(sp)
20011814:	02076713          	ori	a4,a4,32
20011818:	04e11023          	sh	a4,64(sp)
2001181c:	00050863          	beqz	a0,2001182c <cbvprintf+0x238>
20011820:	04015703          	lhu	a4,64(sp)
20011824:	04076713          	ori	a4,a4,64
20011828:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
2001182c:	04012703          	lw	a4,64(sp)
20011830:	04400693          	li	a3,68
20011834:	04477713          	andi	a4,a4,68
20011838:	00d71863          	bne	a4,a3,20011848 <cbvprintf+0x254>
		conv->flag_zero = false;
2001183c:	04015703          	lhu	a4,64(sp)
20011840:	fbf77713          	andi	a4,a4,-65
20011844:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
20011848:	04015703          	lhu	a4,64(sp)
2001184c:	08076693          	ori	a3,a4,128
20011850:	04d11023          	sh	a3,64(sp)
	if (*sp == '*') {
20011854:	02a00693          	li	a3,42
20011858:	10d79463          	bne	a5,a3,20011960 <cbvprintf+0x36c>
			++sp;
2001185c:	001a0793          	addi	a5,s4,1
		conv->width_star = true;
20011860:	18076713          	ori	a4,a4,384
		conv->unsupported |= ((conv->width_value < 0)
20011864:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
20011868:	0007c603          	lbu	a2,0(a5)
2001186c:	fd260713          	addi	a4,a2,-46
20011870:	00173713          	seqz	a4,a4
20011874:	00971693          	slli	a3,a4,0x9
20011878:	04015703          	lhu	a4,64(sp)
2001187c:	dff77713          	andi	a4,a4,-513
20011880:	00d76733          	or	a4,a4,a3
20011884:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
20011888:	02e00693          	li	a3,46
2001188c:	0ed61a63          	bne	a2,a3,20011980 <cbvprintf+0x38c>
	if (*sp == '*') {
20011890:	0017c603          	lbu	a2,1(a5)
20011894:	02a00693          	li	a3,42
20011898:	0cd60e63          	beq	a2,a3,20011974 <cbvprintf+0x380>
	++sp;
2001189c:	00178793          	addi	a5,a5,1
	size_t val = 0;
200118a0:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
200118a4:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
200118a8:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
200118ac:	0007c683          	lbu	a3,0(a5)
200118b0:	00178513          	addi	a0,a5,1
200118b4:	fd068593          	addi	a1,a3,-48 # ffffd0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xff7fd0>
	while (isdigit((int)(unsigned char)*sp)) {
200118b8:	16b67463          	bgeu	a2,a1,20011a20 <cbvprintf+0x42c>
	conv->unsupported |= ((conv->prec_value < 0)
200118bc:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
200118c0:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
200118c4:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
200118c8:	0016d693          	srli	a3,a3,0x1
200118cc:	0016f693          	andi	a3,a3,1
200118d0:	00e6e733          	or	a4,a3,a4
200118d4:	04015683          	lhu	a3,64(sp)
200118d8:	00171713          	slli	a4,a4,0x1
200118dc:	ffd6f693          	andi	a3,a3,-3
200118e0:	00e6e733          	or	a4,a3,a4
200118e4:	04e11023          	sh	a4,64(sp)
	return sp;
200118e8:	0980006f          	j	20011980 <cbvprintf+0x38c>
		switch (*sp) {
200118ec:	03178663          	beq	a5,a7,20011918 <cbvprintf+0x324>
200118f0:	ee6796e3          	bne	a5,t1,200117dc <cbvprintf+0x1e8>
			conv->flag_zero = true;
200118f4:	00100513          	li	a0,1
200118f8:	0080006f          	j	20011900 <cbvprintf+0x30c>
			conv->flag_plus = true;
200118fc:	00100613          	li	a2,1
			++sp;
20011900:	001a0a13          	addi	s4,s4,1
	} while (loop);
20011904:	ec5ff06f          	j	200117c8 <cbvprintf+0x1d4>
			conv->flag_space = true;
20011908:	00100593          	li	a1,1
2001190c:	ff5ff06f          	j	20011900 <cbvprintf+0x30c>
			conv->flag_hash = true;
20011910:	00100693          	li	a3,1
20011914:	fedff06f          	j	20011900 <cbvprintf+0x30c>
		switch (*sp) {
20011918:	00100713          	li	a4,1
2001191c:	fe5ff06f          	j	20011900 <cbvprintf+0x30c>
		val = 10U * val + *sp++ - '0';
20011920:	03070733          	mul	a4,a4,a6
20011924:	00050793          	mv	a5,a0
20011928:	fd070713          	addi	a4,a4,-48
2001192c:	00d70733          	add	a4,a4,a3
20011930:	0007c683          	lbu	a3,0(a5)
20011934:	00178513          	addi	a0,a5,1
20011938:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp)) {
2001193c:	feb672e3          	bgeu	a2,a1,20011920 <cbvprintf+0x32c>
	if (sp != wp) {
20011940:	f2fa04e3          	beq	s4,a5,20011868 <cbvprintf+0x274>
		conv->unsupported |= ((conv->width_value < 0)
20011944:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
20011948:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
2001194c:	01f75713          	srli	a4,a4,0x1f
20011950:	00171713          	slli	a4,a4,0x1
20011954:	ffd6f693          	andi	a3,a3,-3
20011958:	00e6e733          	or	a4,a3,a4
2001195c:	f09ff06f          	j	20011864 <cbvprintf+0x270>
20011960:	000a0793          	mv	a5,s4
	size_t val = 0;
20011964:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
20011968:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
2001196c:	00a00813          	li	a6,10
20011970:	fc1ff06f          	j	20011930 <cbvprintf+0x33c>
		conv->prec_star = true;
20011974:	40076713          	ori	a4,a4,1024
20011978:	04e11023          	sh	a4,64(sp)
		return ++sp;
2001197c:	00278793          	addi	a5,a5,2
	switch (*sp) {
20011980:	0007c603          	lbu	a2,0(a5)
20011984:	06c00713          	li	a4,108
		if (*++sp == 'h') {
20011988:	00178593          	addi	a1,a5,1
	switch (*sp) {
2001198c:	10e60c63          	beq	a2,a4,20011aa4 <cbvprintf+0x4b0>
20011990:	0ac76263          	bltu	a4,a2,20011a34 <cbvprintf+0x440>
20011994:	06800713          	li	a4,104
20011998:	0ce60663          	beq	a2,a4,20011a64 <cbvprintf+0x470>
2001199c:	06a00713          	li	a4,106
200119a0:	12e60863          	beq	a2,a4,20011ad0 <cbvprintf+0x4dc>
200119a4:	04c00713          	li	a4,76
200119a8:	14e60e63          	beq	a2,a4,20011b04 <cbvprintf+0x510>
200119ac:	00078593          	mv	a1,a5
	conv->specifier = *sp++;
200119b0:	0005c703          	lbu	a4,0(a1)
	switch (conv->specifier) {
200119b4:	07800793          	li	a5,120
	conv->specifier = *sp++;
200119b8:	00158a13          	addi	s4,a1,1
200119bc:	04e101a3          	sb	a4,67(sp)
	switch (conv->specifier) {
200119c0:	22e7ec63          	bltu	a5,a4,20011bf8 <cbvprintf+0x604>
200119c4:	05700793          	li	a5,87
200119c8:	14e7ec63          	bltu	a5,a4,20011b20 <cbvprintf+0x52c>
200119cc:	04100793          	li	a5,65
200119d0:	00f70a63          	beq	a4,a5,200119e4 <cbvprintf+0x3f0>
200119d4:	fbb70713          	addi	a4,a4,-69
200119d8:	0ff77713          	andi	a4,a4,255
200119dc:	00200793          	li	a5,2
200119e0:	20e7ec63          	bltu	a5,a4,20011bf8 <cbvprintf+0x604>
		conv->specifier_cat = SPECIFIER_FP;
200119e4:	04214783          	lbu	a5,66(sp)
200119e8:	ff87f793          	andi	a5,a5,-8
200119ec:	0047e793          	ori	a5,a5,4
200119f0:	04f10123          	sb	a5,66(sp)
			unsupported = true;
200119f4:	00100793          	li	a5,1
	conv->unsupported |= unsupported;
200119f8:	04012703          	lw	a4,64(sp)
200119fc:	00175713          	srli	a4,a4,0x1
20011a00:	00177713          	andi	a4,a4,1
20011a04:	00e7e7b3          	or	a5,a5,a4
20011a08:	04015703          	lhu	a4,64(sp)
20011a0c:	00179793          	slli	a5,a5,0x1
20011a10:	ffd77713          	andi	a4,a4,-3
20011a14:	00f767b3          	or	a5,a4,a5
20011a18:	04f11023          	sh	a5,64(sp)
	return sp;
20011a1c:	cadff06f          	j	200116c8 <cbvprintf+0xd4>
		val = 10U * val + *sp++ - '0';
20011a20:	03070733          	mul	a4,a4,a6
20011a24:	00050793          	mv	a5,a0
20011a28:	fd070713          	addi	a4,a4,-48
20011a2c:	00e68733          	add	a4,a3,a4
20011a30:	e7dff06f          	j	200118ac <cbvprintf+0x2b8>
	switch (*sp) {
20011a34:	07400713          	li	a4,116
20011a38:	0ae60a63          	beq	a2,a4,20011aec <cbvprintf+0x4f8>
20011a3c:	07a00713          	li	a4,122
20011a40:	f6e616e3          	bne	a2,a4,200119ac <cbvprintf+0x3b8>
		conv->length_mod = LENGTH_Z;
20011a44:	04015783          	lhu	a5,64(sp)
20011a48:	ffff8737          	lui	a4,0xffff8
20011a4c:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
20011a50:	00e7f7b3          	and	a5,a5,a4
20011a54:	00003737          	lui	a4,0x3
		conv->unsupported = true;
20011a58:	00e7e7b3          	or	a5,a5,a4
20011a5c:	04f11023          	sh	a5,64(sp)
		break;
20011a60:	f51ff06f          	j	200119b0 <cbvprintf+0x3bc>
		if (*++sp == 'h') {
20011a64:	04015503          	lhu	a0,64(sp)
20011a68:	0017c803          	lbu	a6,1(a5)
20011a6c:	ffff86b7          	lui	a3,0xffff8
20011a70:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
20011a74:	00a77733          	and	a4,a4,a0
		if (*++sp == 'h') {
20011a78:	00c81e63          	bne	a6,a2,20011a94 <cbvprintf+0x4a0>
			conv->length_mod = LENGTH_HH;
20011a7c:	000016b7          	lui	a3,0x1
20011a80:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
20011a84:	00d76733          	or	a4,a4,a3
20011a88:	04e11023          	sh	a4,64(sp)
			++sp;
20011a8c:	00278593          	addi	a1,a5,2
20011a90:	f21ff06f          	j	200119b0 <cbvprintf+0x3bc>
			conv->length_mod = LENGTH_H;
20011a94:	000017b7          	lui	a5,0x1
			conv->length_mod = LENGTH_L;
20011a98:	00f76733          	or	a4,a4,a5
20011a9c:	04e11023          	sh	a4,64(sp)
20011aa0:	f11ff06f          	j	200119b0 <cbvprintf+0x3bc>
		if (*++sp == 'l') {
20011aa4:	04015503          	lhu	a0,64(sp)
20011aa8:	0017c803          	lbu	a6,1(a5) # 1001 <CONFIG_ISR_STACK_SIZE+0x801>
20011aac:	ffff86b7          	lui	a3,0xffff8
20011ab0:	7ff68713          	addi	a4,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
20011ab4:	00a77733          	and	a4,a4,a0
		if (*++sp == 'l') {
20011ab8:	00c81663          	bne	a6,a2,20011ac4 <cbvprintf+0x4d0>
			conv->length_mod = LENGTH_LL;
20011abc:	000026b7          	lui	a3,0x2
20011ac0:	fc5ff06f          	j	20011a84 <cbvprintf+0x490>
			conv->length_mod = LENGTH_L;
20011ac4:	000027b7          	lui	a5,0x2
20011ac8:	80078793          	addi	a5,a5,-2048 # 1800 <CONFIG_ISR_STACK_SIZE+0x1000>
20011acc:	fcdff06f          	j	20011a98 <cbvprintf+0x4a4>
		conv->length_mod = LENGTH_J;
20011ad0:	04015783          	lhu	a5,64(sp)
20011ad4:	ffff8737          	lui	a4,0xffff8
20011ad8:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
20011adc:	00e7f7b3          	and	a5,a5,a4
20011ae0:	00003737          	lui	a4,0x3
		conv->length_mod = LENGTH_T;
20011ae4:	80070713          	addi	a4,a4,-2048 # 2800 <CONFIG_ISR_STACK_SIZE+0x2000>
20011ae8:	f71ff06f          	j	20011a58 <cbvprintf+0x464>
20011aec:	04015783          	lhu	a5,64(sp)
20011af0:	ffff8737          	lui	a4,0xffff8
20011af4:	7ff70713          	addi	a4,a4,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
20011af8:	00e7f7b3          	and	a5,a5,a4
20011afc:	00004737          	lui	a4,0x4
20011b00:	fe5ff06f          	j	20011ae4 <cbvprintf+0x4f0>
		conv->unsupported = true;
20011b04:	04015783          	lhu	a5,64(sp)
20011b08:	ffff8737          	lui	a4,0xffff8
20011b0c:	7fd70713          	addi	a4,a4,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
20011b10:	00e7f7b3          	and	a5,a5,a4
20011b14:	00004737          	lui	a4,0x4
20011b18:	00270713          	addi	a4,a4,2 # 4002 <__kernel_ram_size+0x17d2>
20011b1c:	f3dff06f          	j	20011a58 <cbvprintf+0x464>
	switch (conv->specifier) {
20011b20:	fa870793          	addi	a5,a4,-88
20011b24:	0ff7f793          	andi	a5,a5,255
20011b28:	02000693          	li	a3,32
20011b2c:	0cf6e663          	bltu	a3,a5,20011bf8 <cbvprintf+0x604>
20011b30:	200156b7          	lui	a3,0x20015
20011b34:	00279793          	slli	a5,a5,0x2
20011b38:	23868693          	addi	a3,a3,568 # 20015238 <__clz_tab+0x358>
20011b3c:	00d787b3          	add	a5,a5,a3
20011b40:	0007a783          	lw	a5,0(a5)
20011b44:	00078067          	jr	a5
		conv->specifier_cat = SPECIFIER_SINT;
20011b48:	04214783          	lbu	a5,66(sp)
20011b4c:	ff87f793          	andi	a5,a5,-8
20011b50:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
20011b54:	04015683          	lhu	a3,64(sp)
		conv->specifier_cat = SPECIFIER_UINT;
20011b58:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20011b5c:	000087b7          	lui	a5,0x8
20011b60:	80078793          	addi	a5,a5,-2048 # 7800 <_image_rom_size+0x1f48>
20011b64:	00f6f7b3          	and	a5,a3,a5
20011b68:	01079793          	slli	a5,a5,0x10
20011b6c:	0107d793          	srli	a5,a5,0x10
20011b70:	00004637          	lui	a2,0x4
20011b74:	00c79663          	bne	a5,a2,20011b80 <cbvprintf+0x58c>
			conv->invalid = true;
20011b78:	0016e693          	ori	a3,a3,1
20011b7c:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
20011b80:	06300693          	li	a3,99
	bool unsupported = false;
20011b84:	00000793          	li	a5,0
		if (conv->specifier == 'c') {
20011b88:	e6d718e3          	bne	a4,a3,200119f8 <cbvprintf+0x404>
		if (conv->length_mod != LENGTH_NONE) {
20011b8c:	04015703          	lhu	a4,64(sp)
20011b90:	000087b7          	lui	a5,0x8
20011b94:	80078793          	addi	a5,a5,-2048 # 7800 <_image_rom_size+0x1f48>
20011b98:	00e7f7b3          	and	a5,a5,a4
20011b9c:	00f037b3          	snez	a5,a5
20011ba0:	e59ff06f          	j	200119f8 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_UINT;
20011ba4:	04214783          	lbu	a5,66(sp)
20011ba8:	ff87f793          	andi	a5,a5,-8
20011bac:	0027e793          	ori	a5,a5,2
20011bb0:	fa5ff06f          	j	20011b54 <cbvprintf+0x560>
		conv->specifier_cat = SPECIFIER_PTR;
20011bb4:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20011bb8:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_PTR;
20011bbc:	ff87f793          	andi	a5,a5,-8
20011bc0:	0037e793          	ori	a5,a5,3
20011bc4:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
20011bc8:	000087b7          	lui	a5,0x8
20011bcc:	80078793          	addi	a5,a5,-2048 # 7800 <_image_rom_size+0x1f48>
20011bd0:	00e7f7b3          	and	a5,a5,a4
20011bd4:	ffffc737          	lui	a4,0xffffc
20011bd8:	00e787b3          	add	a5,a5,a4
20011bdc:	0017b793          	seqz	a5,a5
20011be0:	e19ff06f          	j	200119f8 <cbvprintf+0x404>
		conv->specifier_cat = SPECIFIER_PTR;
20011be4:	04214783          	lbu	a5,66(sp)
20011be8:	ff87f793          	andi	a5,a5,-8
20011bec:	0037e793          	ori	a5,a5,3
20011bf0:	04f10123          	sb	a5,66(sp)
20011bf4:	f99ff06f          	j	20011b8c <cbvprintf+0x598>
		conv->invalid = true;
20011bf8:	04015783          	lhu	a5,64(sp)
20011bfc:	0017e793          	ori	a5,a5,1
20011c00:	04f11023          	sh	a5,64(sp)
	bool unsupported = false;
20011c04:	00000793          	li	a5,0
		break;
20011c08:	df1ff06f          	j	200119f8 <cbvprintf+0x404>
		} else if (conv->width_present) {
20011c0c:	0807f793          	andi	a5,a5,128
20011c10:	00078863          	beqz	a5,20011c20 <cbvprintf+0x62c>
			width = conv->width_value;
20011c14:	04412483          	lw	s1,68(sp)
20011c18:	000c8413          	mv	s0,s9
20011c1c:	ad1ff06f          	j	200116ec <cbvprintf+0xf8>
20011c20:	000c8413          	mv	s0,s9
		int width = -1;
20011c24:	fff00493          	li	s1,-1
20011c28:	ac5ff06f          	j	200116ec <cbvprintf+0xf8>
		} else if (conv->prec_present) {
20011c2c:	20077713          	andi	a4,a4,512
		int precision = -1;
20011c30:	fff00a93          	li	s5,-1
		} else if (conv->prec_present) {
20011c34:	ac070ee3          	beqz	a4,20011710 <cbvprintf+0x11c>
			precision = conv->prec_value;
20011c38:	04812a83          	lw	s5,72(sp)
20011c3c:	ad5ff06f          	j	20011710 <cbvprintf+0x11c>
					value->sint = va_arg(ap, long);
20011c40:	00440513          	addi	a0,s0,4
					value->uint = (wchar_t)va_arg(ap,
20011c44:	00042683          	lw	a3,0(s0)
20011c48:	02d12823          	sw	a3,48(sp)
20011c4c:	41f6d693          	srai	a3,a3,0x1f
20011c50:	01c0006f          	j	20011c6c <cbvprintf+0x678>
					(sint_value_type)va_arg(ap, long long);
20011c54:	00740413          	addi	s0,s0,7
20011c58:	ff847413          	andi	s0,s0,-8
				value->sint =
20011c5c:	00042603          	lw	a2,0(s0)
20011c60:	00442683          	lw	a3,4(s0)
					(sint_value_type)va_arg(ap, long long);
20011c64:	00840513          	addi	a0,s0,8
				value->sint =
20011c68:	02c12823          	sw	a2,48(sp)
20011c6c:	02d12a23          	sw	a3,52(sp)
					(uint_value_type)va_arg(ap, size_t);
20011c70:	00050413          	mv	s0,a0
20011c74:	b05ff06f          	j	20011778 <cbvprintf+0x184>
			} else if (length_mod == LENGTH_H) {
20011c78:	00200693          	li	a3,2
20011c7c:	aed71ee3          	bne	a4,a3,20011778 <cbvprintf+0x184>
				value->sint = (short)value->sint;
20011c80:	03011683          	lh	a3,48(sp)
20011c84:	02d12823          	sw	a3,48(sp)
20011c88:	41f6d693          	srai	a3,a3,0x1f
				value->dbl = va_arg(ap, double);
20011c8c:	02d12a23          	sw	a3,52(sp)
20011c90:	ae9ff06f          	j	20011778 <cbvprintf+0x184>
		} else if (specifier_cat == SPECIFIER_UINT) {
20011c94:	00200513          	li	a0,2
20011c98:	06a69463          	bne	a3,a0,20011d00 <cbvprintf+0x70c>
			switch (length_mod) {
20011c9c:	00500693          	li	a3,5
20011ca0:	fad70ae3          	beq	a4,a3,20011c54 <cbvprintf+0x660>
20011ca4:	00e6ea63          	bltu	a3,a4,20011cb8 <cbvprintf+0x6c4>
20011ca8:	00300693          	li	a3,3
20011cac:	02d70a63          	beq	a4,a3,20011ce0 <cbvprintf+0x6ec>
20011cb0:	00400693          	li	a3,4
20011cb4:	fad700e3          	beq	a4,a3,20011c54 <cbvprintf+0x660>
					(uint_value_type)va_arg(ap, size_t);
20011cb8:	00042683          	lw	a3,0(s0)
20011cbc:	02012a23          	sw	zero,52(sp)
20011cc0:	00440413          	addi	s0,s0,4
20011cc4:	02d12823          	sw	a3,48(sp)
			if (length_mod == LENGTH_HH) {
20011cc8:	00100693          	li	a3,1
20011ccc:	aad700e3          	beq	a4,a3,2001176c <cbvprintf+0x178>
			} else if (length_mod == LENGTH_H) {
20011cd0:	00200693          	li	a3,2
20011cd4:	aad712e3          	bne	a4,a3,20011778 <cbvprintf+0x184>
				value->uint = (unsigned short)value->uint;
20011cd8:	03015683          	lhu	a3,48(sp)
20011cdc:	a95ff06f          	j	20011770 <cbvprintf+0x17c>
				if ((!WCHAR_IS_SIGNED)
20011ce0:	04314603          	lbu	a2,67(sp)
20011ce4:	06300693          	li	a3,99
				value->sint = va_arg(ap, int);
20011ce8:	00440513          	addi	a0,s0,4
				if ((!WCHAR_IS_SIGNED)
20011cec:	f4d60ce3          	beq	a2,a3,20011c44 <cbvprintf+0x650>
					value->uint = va_arg(ap, unsigned long);
20011cf0:	00042683          	lw	a3,0(s0)
20011cf4:	02012a23          	sw	zero,52(sp)
20011cf8:	02d12823          	sw	a3,48(sp)
20011cfc:	f75ff06f          	j	20011c70 <cbvprintf+0x67c>
		} else if (specifier_cat == SPECIFIER_FP) {
20011d00:	00400613          	li	a2,4
20011d04:	04c69a63          	bne	a3,a2,20011d58 <cbvprintf+0x764>
			if (length_mod == LENGTH_UPPER_L) {
20011d08:	00800693          	li	a3,8
20011d0c:	02d71863          	bne	a4,a3,20011d3c <cbvprintf+0x748>
				value->ldbl = va_arg(ap, long double);
20011d10:	00042683          	lw	a3,0(s0)
20011d14:	0006a803          	lw	a6,0(a3)
20011d18:	0046a503          	lw	a0,4(a3)
20011d1c:	0086a603          	lw	a2,8(a3)
20011d20:	00c6a683          	lw	a3,12(a3)
20011d24:	03012823          	sw	a6,48(sp)
20011d28:	02a12a23          	sw	a0,52(sp)
20011d2c:	02c12c23          	sw	a2,56(sp)
20011d30:	02d12e23          	sw	a3,60(sp)
			value->ptr = va_arg(ap, void *);
20011d34:	00440413          	addi	s0,s0,4
20011d38:	a41ff06f          	j	20011778 <cbvprintf+0x184>
				value->dbl = va_arg(ap, double);
20011d3c:	00740693          	addi	a3,s0,7
20011d40:	ff86f693          	andi	a3,a3,-8
20011d44:	0006a603          	lw	a2,0(a3)
20011d48:	00868413          	addi	s0,a3,8
20011d4c:	0046a683          	lw	a3,4(a3)
20011d50:	02c12823          	sw	a2,48(sp)
20011d54:	f39ff06f          	j	20011c8c <cbvprintf+0x698>
		} else if (specifier_cat == SPECIFIER_PTR) {
20011d58:	00300613          	li	a2,3
20011d5c:	a0c69ee3          	bne	a3,a2,20011778 <cbvprintf+0x184>
			value->ptr = va_arg(ap, void *);
20011d60:	00042683          	lw	a3,0(s0)
20011d64:	02d12823          	sw	a3,48(sp)
20011d68:	fcdff06f          	j	20011d34 <cbvprintf+0x740>
		switch (conv->specifier) {
20011d6c:	04314683          	lbu	a3,67(sp)
20011d70:	07800613          	li	a2,120
20011d74:	92d664e3          	bltu	a2,a3,2001169c <cbvprintf+0xa8>
20011d78:	06200613          	li	a2,98
20011d7c:	00d66e63          	bltu	a2,a3,20011d98 <cbvprintf+0x7a4>
20011d80:	02500713          	li	a4,37
20011d84:	02e68c63          	beq	a3,a4,20011dbc <cbvprintf+0x7c8>
20011d88:	05800713          	li	a4,88
20011d8c:	90e698e3          	bne	a3,a4,2001169c <cbvprintf+0xa8>
20011d90:	00000b13          	li	s6,0
20011d94:	2080006f          	j	20011f9c <cbvprintf+0x9a8>
20011d98:	f9d68693          	addi	a3,a3,-99
20011d9c:	0ff6f693          	andi	a3,a3,255
20011da0:	01500613          	li	a2,21
20011da4:	8ed66ce3          	bltu	a2,a3,2001169c <cbvprintf+0xa8>
20011da8:	00412783          	lw	a5,4(sp)
20011dac:	00269693          	slli	a3,a3,0x2
20011db0:	00f686b3          	add	a3,a3,a5
20011db4:	0006a683          	lw	a3,0(a3)
20011db8:	00068067          	jr	a3
			OUTC('%');
20011dbc:	00098593          	mv	a1,s3
20011dc0:	02500513          	li	a0,37
20011dc4:	000900e7          	jalr	s2
20011dc8:	2c054a63          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011dcc:	001d8d93          	addi	s11,s11,1
			break;
20011dd0:	8cdff06f          	j	2001169c <cbvprintf+0xa8>
			bps = (const char *)value->ptr;
20011dd4:	03012c83          	lw	s9,48(sp)
			if (precision >= 0) {
20011dd8:	160ac063          	bltz	s5,20011f38 <cbvprintf+0x944>
				len = strnlen(bps, precision);
20011ddc:	000a8593          	mv	a1,s5
20011de0:	000c8513          	mv	a0,s9
20011de4:	3f5000ef          	jal	ra,200129d8 <strnlen>
			bpe = bps + len;
20011de8:	00ac8d33          	add	s10,s9,a0
		char sign = 0;
20011dec:	00000b13          	li	s6,0
		if (bps == NULL) {
20011df0:	8a0c86e3          	beqz	s9,2001169c <cbvprintf+0xa8>
		size_t nj_len = (bpe - bps);
20011df4:	419d07b3          	sub	a5,s10,s9
		if (sign != 0) {
20011df8:	000b0463          	beqz	s6,20011e00 <cbvprintf+0x80c>
			nj_len += 1U;
20011dfc:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
20011e00:	04214703          	lbu	a4,66(sp)
20011e04:	01077693          	andi	a3,a4,16
20011e08:	26068663          	beqz	a3,20012074 <cbvprintf+0xa80>
			nj_len += 2U;
20011e0c:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
20011e10:	04412683          	lw	a3,68(sp)
		if (conv->pad_fp) {
20011e14:	04077713          	andi	a4,a4,64
		nj_len += conv->pad0_value;
20011e18:	00d787b3          	add	a5,a5,a3
		if (conv->pad_fp) {
20011e1c:	00070663          	beqz	a4,20011e28 <cbvprintf+0x834>
			nj_len += conv->pad0_pre_exp;
20011e20:	04812703          	lw	a4,72(sp)
20011e24:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
20011e28:	04905c63          	blez	s1,20011e80 <cbvprintf+0x88c>
			width -= (int)nj_len;
20011e2c:	40f484b3          	sub	s1,s1,a5
			if (!conv->flag_dash) {
20011e30:	04012783          	lw	a5,64(sp)
20011e34:	0027d793          	srli	a5,a5,0x2
20011e38:	0017f793          	andi	a5,a5,1
20011e3c:	04079263          	bnez	a5,20011e80 <cbvprintf+0x88c>
				if (conv->flag_zero) {
20011e40:	04015783          	lhu	a5,64(sp)
20011e44:	0407f793          	andi	a5,a5,64
20011e48:	28078863          	beqz	a5,200120d8 <cbvprintf+0xae4>
					if (sign != 0) {
20011e4c:	280b0a63          	beqz	s6,200120e0 <cbvprintf+0xaec>
						OUTC(sign);
20011e50:	00098593          	mv	a1,s3
20011e54:	000b0513          	mv	a0,s6
20011e58:	000900e7          	jalr	s2
20011e5c:	24054063          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011e60:	001d8d93          	addi	s11,s11,1
					pad = '0';
20011e64:	03000793          	li	a5,48
						sign = 0;
20011e68:	00000b13          	li	s6,0
20011e6c:	01b48ab3          	add	s5,s1,s11
20011e70:	00048713          	mv	a4,s1
20011e74:	409a8db3          	sub	s11,s5,s1
				while (width-- > 0) {
20011e78:	fff48493          	addi	s1,s1,-1
20011e7c:	20e04463          	bgtz	a4,20012084 <cbvprintf+0xa90>
		if (sign != 0) {
20011e80:	000b0c63          	beqz	s6,20011e98 <cbvprintf+0x8a4>
			OUTC(sign);
20011e84:	00098593          	mv	a1,s3
20011e88:	000b0513          	mv	a0,s6
20011e8c:	000900e7          	jalr	s2
20011e90:	20054663          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011e94:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c | conv->altform_0) {
20011e98:	04012783          	lw	a5,64(sp)
20011e9c:	0147d713          	srli	a4,a5,0x14
20011ea0:	00177713          	andi	a4,a4,1
20011ea4:	00071863          	bnez	a4,20011eb4 <cbvprintf+0x8c0>
20011ea8:	0137d793          	srli	a5,a5,0x13
20011eac:	0017f793          	andi	a5,a5,1
20011eb0:	00078c63          	beqz	a5,20011ec8 <cbvprintf+0x8d4>
				OUTC('0');
20011eb4:	00098593          	mv	a1,s3
20011eb8:	03000513          	li	a0,48
20011ebc:	000900e7          	jalr	s2
20011ec0:	1c054e63          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011ec4:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c) {
20011ec8:	04214783          	lbu	a5,66(sp)
20011ecc:	0107f793          	andi	a5,a5,16
20011ed0:	00078c63          	beqz	a5,20011ee8 <cbvprintf+0x8f4>
				OUTC(conv->specifier);
20011ed4:	04314503          	lbu	a0,67(sp)
20011ed8:	00098593          	mv	a1,s3
20011edc:	000900e7          	jalr	s2
20011ee0:	1a054e63          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011ee4:	001d8d93          	addi	s11,s11,1
			while (pad_len-- > 0) {
20011ee8:	04412783          	lw	a5,68(sp)
20011eec:	01b78ab3          	add	s5,a5,s11
20011ef0:	41ba8733          	sub	a4,s5,s11
20011ef4:	1ee04a63          	bgtz	a4,200120e8 <cbvprintf+0xaf4>
			OUTS(bps, bpe);
20011ef8:	000d0693          	mv	a3,s10
20011efc:	000c8613          	mv	a2,s9
20011f00:	00098593          	mv	a1,s3
20011f04:	00090513          	mv	a0,s2
20011f08:	e74ff0ef          	jal	ra,2001157c <outs>
20011f0c:	18054863          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011f10:	01b50db3          	add	s11,a0,s11
		while (width > 0) {
20011f14:	01b484b3          	add	s1,s1,s11
20011f18:	41b487b3          	sub	a5,s1,s11
20011f1c:	f8f05063          	blez	a5,2001169c <cbvprintf+0xa8>
			OUTC(' ');
20011f20:	00098593          	mv	a1,s3
20011f24:	02000513          	li	a0,32
20011f28:	000900e7          	jalr	s2
20011f2c:	16054863          	bltz	a0,2001209c <cbvprintf+0xaa8>
20011f30:	001d8d93          	addi	s11,s11,1
			--width;
20011f34:	fe5ff06f          	j	20011f18 <cbvprintf+0x924>
				len = strlen(bps);
20011f38:	000c8513          	mv	a0,s9
20011f3c:	27d000ef          	jal	ra,200129b8 <strlen>
20011f40:	ea9ff06f          	j	20011de8 <cbvprintf+0x7f4>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
20011f44:	03012783          	lw	a5,48(sp)
			bps = buf;
20011f48:	01810c93          	addi	s9,sp,24
			bpe = buf + 1;
20011f4c:	01910d13          	addi	s10,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
20011f50:	00f10c23          	sb	a5,24(sp)
			break;
20011f54:	00000b13          	li	s6,0
20011f58:	e9dff06f          	j	20011df4 <cbvprintf+0x800>
			if (conv->flag_plus) {
20011f5c:	04015703          	lhu	a4,64(sp)
				sign = '+';
20011f60:	02b00b13          	li	s6,43
			if (conv->flag_plus) {
20011f64:	00877693          	andi	a3,a4,8
20011f68:	00069663          	bnez	a3,20011f74 <cbvprintf+0x980>
				sign = ' ';
20011f6c:	00171b13          	slli	s6,a4,0x1
20011f70:	020b7b13          	andi	s6,s6,32
			sint = value->sint;
20011f74:	03412703          	lw	a4,52(sp)
20011f78:	03012683          	lw	a3,48(sp)
			if (sint < 0) {
20011f7c:	02075063          	bgez	a4,20011f9c <cbvprintf+0x9a8>
				value->uint = (uint_value_type)-sint;
20011f80:	40d00633          	neg	a2,a3
20011f84:	40e00733          	neg	a4,a4
20011f88:	00d036b3          	snez	a3,a3
20011f8c:	40d70733          	sub	a4,a4,a3
20011f90:	02c12823          	sw	a2,48(sp)
20011f94:	02e12a23          	sw	a4,52(sp)
				sign = '-';
20011f98:	02d00b13          	li	s6,45
			bps = encode_uint(value->uint, conv, buf, bpe);
20011f9c:	03012503          	lw	a0,48(sp)
20011fa0:	03412583          	lw	a1,52(sp)
20011fa4:	02e10713          	addi	a4,sp,46
20011fa8:	01810693          	addi	a3,sp,24
20011fac:	04010613          	addi	a2,sp,64
20011fb0:	c70ff0ef          	jal	ra,20011420 <encode_uint>
20011fb4:	00050c93          	mv	s9,a0
			if (precision >= 0) {
20011fb8:	02e10d13          	addi	s10,sp,46
20011fbc:	e20acae3          	bltz	s5,20011df0 <cbvprintf+0x7fc>
				conv->flag_zero = false;
20011fc0:	04015683          	lhu	a3,64(sp)
				size_t len = bpe - bps;
20011fc4:	419d0733          	sub	a4,s10,s9
				conv->flag_zero = false;
20011fc8:	fbf6f693          	andi	a3,a3,-65
20011fcc:	04d11023          	sh	a3,64(sp)
				if (len < (size_t)precision) {
20011fd0:	e35770e3          	bgeu	a4,s5,20011df0 <cbvprintf+0x7fc>
					conv->pad0_value = precision - (int)len;
20011fd4:	40ea87b3          	sub	a5,s5,a4
20011fd8:	04f12223          	sw	a5,68(sp)
20011fdc:	e15ff06f          	j	20011df0 <cbvprintf+0x7fc>
			if (value->ptr != NULL) {
20011fe0:	03012503          	lw	a0,48(sp)
20011fe4:	08050263          	beqz	a0,20012068 <cbvprintf+0xa74>
				bps = encode_uint((uintptr_t)value->ptr, conv,
20011fe8:	02e10713          	addi	a4,sp,46
20011fec:	01810693          	addi	a3,sp,24
20011ff0:	04010613          	addi	a2,sp,64
20011ff4:	00000593          	li	a1,0
20011ff8:	c28ff0ef          	jal	ra,20011420 <encode_uint>
				conv->altform_0c = true;
20011ffc:	04215703          	lhu	a4,66(sp)
20012000:	000086b7          	lui	a3,0x8
20012004:	81068693          	addi	a3,a3,-2032 # 7810 <_image_rom_size+0x1f58>
20012008:	0ef77713          	andi	a4,a4,239
2001200c:	00d76733          	or	a4,a4,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
20012010:	00050c93          	mv	s9,a0
				conv->altform_0c = true;
20012014:	04e11123          	sh	a4,66(sp)
		char sign = 0;
20012018:	00000b13          	li	s6,0
				goto prec_int_pad0;
2001201c:	f9dff06f          	j	20011fb8 <cbvprintf+0x9c4>
	switch ((enum length_mod_enum)conv->length_mod) {
20012020:	00700693          	li	a3,7
				store_count(conv, value->ptr, count);
20012024:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
20012028:	e6e6ea63          	bltu	a3,a4,2001169c <cbvprintf+0xa8>
2001202c:	00812683          	lw	a3,8(sp)
20012030:	00271713          	slli	a4,a4,0x2
20012034:	00d70733          	add	a4,a4,a3
20012038:	00072703          	lw	a4,0(a4) # ffffc000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffffc001>
2001203c:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
20012040:	01b78023          	sb	s11,0(a5)
		break;
20012044:	e58ff06f          	j	2001169c <cbvprintf+0xa8>
		*(short *)dp = (short)count;
20012048:	01b79023          	sh	s11,0(a5)
		break;
2001204c:	e50ff06f          	j	2001169c <cbvprintf+0xa8>
		*(intmax_t *)dp = (intmax_t)count;
20012050:	41fdd713          	srai	a4,s11,0x1f
20012054:	01b7a023          	sw	s11,0(a5)
20012058:	00e7a223          	sw	a4,4(a5)
		break;
2001205c:	e40ff06f          	j	2001169c <cbvprintf+0xa8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
20012060:	01b7a023          	sw	s11,0(a5)
		break;
20012064:	e38ff06f          	j	2001169c <cbvprintf+0xa8>
			bps = "(nil)";
20012068:	000b8c93          	mv	s9,s7
			bpe = bps + 5;
2001206c:	000c0d13          	mv	s10,s8
20012070:	ee5ff06f          	j	20011f54 <cbvprintf+0x960>
		} else if (conv->altform_0) {
20012074:	00877693          	andi	a3,a4,8
20012078:	d8068ce3          	beqz	a3,20011e10 <cbvprintf+0x81c>
			nj_len += 1U;
2001207c:	00178793          	addi	a5,a5,1
20012080:	d91ff06f          	j	20011e10 <cbvprintf+0x81c>
					OUTC(pad);
20012084:	00078513          	mv	a0,a5
20012088:	00098593          	mv	a1,s3
2001208c:	00f12623          	sw	a5,12(sp)
20012090:	000900e7          	jalr	s2
20012094:	00c12783          	lw	a5,12(sp)
20012098:	dc055ce3          	bgez	a0,20011e70 <cbvprintf+0x87c>
#undef OUTS
#undef OUTC
}
2001209c:	08c12083          	lw	ra,140(sp)
200120a0:	08812403          	lw	s0,136(sp)
200120a4:	08412483          	lw	s1,132(sp)
200120a8:	08012903          	lw	s2,128(sp)
200120ac:	07c12983          	lw	s3,124(sp)
200120b0:	07812a03          	lw	s4,120(sp)
200120b4:	07412a83          	lw	s5,116(sp)
200120b8:	07012b03          	lw	s6,112(sp)
200120bc:	06c12b83          	lw	s7,108(sp)
200120c0:	06812c03          	lw	s8,104(sp)
200120c4:	06412c83          	lw	s9,100(sp)
200120c8:	06012d03          	lw	s10,96(sp)
200120cc:	05c12d83          	lw	s11,92(sp)
200120d0:	09010113          	addi	sp,sp,144
200120d4:	00008067          	ret
				char pad = ' ';
200120d8:	02000793          	li	a5,32
200120dc:	d91ff06f          	j	20011e6c <cbvprintf+0x878>
					pad = '0';
200120e0:	03000793          	li	a5,48
200120e4:	d89ff06f          	j	20011e6c <cbvprintf+0x878>
				OUTC('0');
200120e8:	00098593          	mv	a1,s3
200120ec:	03000513          	li	a0,48
200120f0:	000900e7          	jalr	s2
200120f4:	fa0544e3          	bltz	a0,2001209c <cbvprintf+0xaa8>
200120f8:	001d8d93          	addi	s11,s11,1
200120fc:	df5ff06f          	j	20011ef0 <cbvprintf+0x8fc>

20012100 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
20012100:	00008067          	ret

20012104 <arch_cpu_idle>:
 * '_pm_save_flag' variable is non-zero.
 *
 * @return N/A
 */
void arch_cpu_idle(void)
{
20012104:	ff010113          	addi	sp,sp,-16
20012108:	00112623          	sw	ra,12(sp)
	sys_trace_idle();
2001210c:	10c000ef          	jal	ra,20012218 <sys_trace_idle>
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
20012110:	00800793          	li	a5,8
20012114:	3007a7f3          	csrrs	a5,mstatus,a5
	__asm__ volatile("wfi");
20012118:	10500073          	wfi
	riscv_idle(MSTATUS_IEN);
}
2001211c:	00c12083          	lw	ra,12(sp)
20012120:	01010113          	addi	sp,sp,16
20012124:	00008067          	ret

20012128 <arch_irq_enable>:
{
#if defined(CONFIG_3RD_LEVEL_INTERRUPTS)
	return ((irq >> 16) & 0xFF) != 0 ? 3 :
		(((irq >> 8) & 0xFF) == 0 ? 1 : 2);
#elif defined(CONFIG_2ND_LEVEL_INTERRUPTS)
	return ((irq >> 8) & 0xFF) == 0 ? 1 : 2;
20012128:	00855793          	srli	a5,a0,0x8
2001212c:	0ff7f713          	andi	a4,a5,255
20012130:	00071a63          	bnez	a4,20012144 <arch_irq_enable+0x1c>
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
20012134:	00100793          	li	a5,1
20012138:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
2001213c:	30452573          	csrrs	a0,mie,a0
}
20012140:	00008067          	ret
		riscv_plic_irq_enable(irq);
20012144:	fff78513          	addi	a0,a5,-1
20012148:	24c0006f          	j	20012394 <riscv_plic_irq_enable>

2001214c <arch_irq_disable>:
2001214c:	00855793          	srli	a5,a0,0x8
20012150:	0ff7f713          	andi	a4,a5,255
20012154:	00071a63          	bnez	a4,20012168 <arch_irq_disable+0x1c>
	 * Use atomic instruction csrrc to disable device interrupt in mie CSR.
	 * (atomic read and clear bits in CSR register)
	 */
	__asm__ volatile ("csrrc %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
20012158:	00100793          	li	a5,1
2001215c:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrc %0, mie, %1\n"
20012160:	30453573          	csrrc	a0,mie,a0
};
20012164:	00008067          	ret
		riscv_plic_irq_disable(irq);
20012168:	fff78513          	addi	a0,a5,-1
2001216c:	2600006f          	j	200123cc <riscv_plic_irq_disable>

20012170 <arch_irq_priority_set>:
20012170:	00855513          	srli	a0,a0,0x8
20012174:	0ff57793          	andi	a5,a0,255
20012178:	00078663          	beqz	a5,20012184 <arch_irq_priority_set+0x14>
#if defined(CONFIG_RISCV_HAS_PLIC)
	unsigned int level = irq_get_level(irq);

	if (level == 2) {
		irq = irq_from_level_2(irq);
		riscv_plic_set_priority(irq, prio);
2001217c:	fff50513          	addi	a0,a0,-1
20012180:	2880006f          	j	20012408 <riscv_plic_set_priority>
	}
#endif

	return ;
}
20012184:	00008067          	ret

20012188 <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20012188:	00800793          	li	a5,8
2001218c:	3007b7f3          	csrrc	a5,mstatus,a5
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
20012190:	30405073          	csrwi	mie,0
20012194:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
20012198:	00008067          	ret

2001219c <fe310_clock_init>:
 */
static int fe310_clock_init(const struct device *dev)
{
	ARG_UNUSED(dev);

	PRCI_REG(PRCI_PLLCFG) = PLL_REFSEL(1) | PLL_BYPASS(1);
2001219c:	100087b7          	lui	a5,0x10008
200121a0:	00060737          	lui	a4,0x60
200121a4:	00e7a423          	sw	a4,8(a5) # 10008008 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10000008>
	PRCI_REG(PRCI_PLLDIV) = (PLL_FINAL_DIV_BY_1(1) | PLL_FINAL_DIV(0));
200121a8:	10000713          	li	a4,256
200121ac:	00e7a623          	sw	a4,12(a5)
	PRCI_REG(PRCI_PLLCFG) |= PLL_SEL(1);
200121b0:	0087a703          	lw	a4,8(a5)
200121b4:	000106b7          	lui	a3,0x10
	PRCI_REG(PRCI_HFROSCCFG) &= ~ROSC_EN(1);
	return 0;
}
200121b8:	00000513          	li	a0,0
	PRCI_REG(PRCI_PLLCFG) |= PLL_SEL(1);
200121bc:	00d76733          	or	a4,a4,a3
200121c0:	00e7a423          	sw	a4,8(a5)
	PRCI_REG(PRCI_HFROSCCFG) &= ~ROSC_EN(1);
200121c4:	0007a703          	lw	a4,0(a5)
200121c8:	c00006b7          	lui	a3,0xc0000
200121cc:	fff68693          	addi	a3,a3,-1 # bfffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc0000000>
200121d0:	00d77733          	and	a4,a4,a3
200121d4:	00e7a023          	sw	a4,0(a5)
}
200121d8:	00008067          	ret

200121dc <z_log_minimal_printk>:
#include <sys/printk.h>

#define HEXDUMP_BYTES_IN_LINE 8U

void z_log_minimal_printk(const char *fmt, ...)
{
200121dc:	fc010113          	addi	sp,sp,-64
200121e0:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
200121e4:	02410593          	addi	a1,sp,36
{
200121e8:	00112e23          	sw	ra,28(sp)
200121ec:	02c12423          	sw	a2,40(sp)
200121f0:	02d12623          	sw	a3,44(sp)
200121f4:	02e12823          	sw	a4,48(sp)
200121f8:	02f12a23          	sw	a5,52(sp)
200121fc:	03012c23          	sw	a6,56(sp)
20012200:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
20012204:	00b12623          	sw	a1,12(sp)
	vprintk(fmt, ap);
20012208:	e01fe0ef          	jal	ra,20011008 <vprintk>
	va_end(ap);
}
2001220c:	01c12083          	lw	ra,28(sp)
20012210:	04010113          	addi	sp,sp,64
20012214:	00008067          	ret

20012218 <sys_trace_idle>:
20012218:	00008067          	ret

2001221c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
2001221c:	ff010113          	addi	sp,sp,-16
20012220:	00112623          	sw	ra,12(sp)
20012224:	00812423          	sw	s0,8(sp)
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
20012228:	20015537          	lui	a0,0x20015
2001222c:	33450513          	addi	a0,a0,820 # 20015334 <__clz_tab+0x454>
20012230:	0c4010ef          	jal	ra,200132f4 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
20012234:	800007b7          	lui	a5,0x80000
	__stdout_hook_install(console_out);
20012238:	20012437          	lui	s0,0x20012
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
2001223c:	00a7aa23          	sw	a0,20(a5) # 80000014 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000015>
	__stdout_hook_install(console_out);
20012240:	26440513          	addi	a0,s0,612 # 20012264 <console_out>
20012244:	145000ef          	jal	ra,20012b88 <__stdout_hook_install>
	__printk_hook_install(console_out);
20012248:	26440513          	addi	a0,s0,612
2001224c:	db1fe0ef          	jal	ra,20010ffc <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
20012250:	00c12083          	lw	ra,12(sp)
20012254:	00812403          	lw	s0,8(sp)
20012258:	00000513          	li	a0,0
2001225c:	01010113          	addi	sp,sp,16
20012260:	00008067          	ret

20012264 <console_out>:
{
20012264:	ff010113          	addi	sp,sp,-16
20012268:	00812423          	sw	s0,8(sp)
2001226c:	00912223          	sw	s1,4(sp)
20012270:	00112623          	sw	ra,12(sp)
20012274:	800004b7          	lui	s1,0x80000
	if ('\n' == c) {
20012278:	00a00793          	li	a5,10
{
2001227c:	00050413          	mv	s0,a0
20012280:	01448493          	addi	s1,s1,20 # 80000014 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000015>
	if ('\n' == c) {
20012284:	00f51c63          	bne	a0,a5,2001229c <console_out+0x38>
		uart_poll_out(uart_console_dev, '\r');
20012288:	0004a503          	lw	a0,0(s1)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
2001228c:	00852783          	lw	a5,8(a0)
20012290:	00d00593          	li	a1,13
20012294:	0047a783          	lw	a5,4(a5)
20012298:	000780e7          	jalr	a5
	uart_poll_out(uart_console_dev, c);
2001229c:	0004a503          	lw	a0,0(s1)
200122a0:	00852783          	lw	a5,8(a0)
200122a4:	0ff47593          	andi	a1,s0,255
200122a8:	0047a783          	lw	a5,4(a5)
200122ac:	000780e7          	jalr	a5
}
200122b0:	00c12083          	lw	ra,12(sp)
200122b4:	00040513          	mv	a0,s0
200122b8:	00812403          	lw	s0,8(sp)
200122bc:	00412483          	lw	s1,4(sp)
200122c0:	01010113          	addi	sp,sp,16
200122c4:	00008067          	ret

200122c8 <plic_init>:
 *
 * @brief Initialize the Platform Level Interrupt Controller
 * @return N/A
 */
static int plic_init(const struct device *dev)
{
200122c8:	ff010113          	addi	sp,sp,-16
	    (volatile struct plic_regs_t *)PLIC_REG;
	int i;

	/* Ensure that all interrupts are disabled initially */
	for (i = 0; i < PLIC_EN_SIZE; i++) {
		*en = 0U;
200122cc:	0c0027b7          	lui	a5,0xc002
{
200122d0:	00112623          	sw	ra,12(sp)
		*en = 0U;
200122d4:	0007a023          	sw	zero,0(a5) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbffa000>
200122d8:	0007a223          	sw	zero,4(a5)
	volatile uint32_t *prio = (volatile uint32_t *)PLIC_PRIO;
200122dc:	0c0007b7          	lui	a5,0xc000
		en++;
	}

	/* Set priority of each interrupt line to 0 initially */
	for (i = 0; i < PLIC_IRQS; i++) {
200122e0:	0d078713          	addi	a4,a5,208 # c0000d0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbff80d0>
		*prio = 0U;
200122e4:	0007a023          	sw	zero,0(a5)
		prio++;
200122e8:	00478793          	addi	a5,a5,4
	for (i = 0; i < PLIC_IRQS; i++) {
200122ec:	fee79ce3          	bne	a5,a4,200122e4 <plic_init+0x1c>
	}

	/* Set threshold priority to 0 */
	regs->threshold_prio = 0U;
200122f0:	0c2007b7          	lui	a5,0xc200
200122f4:	0007a023          	sw	zero,0(a5) # c200000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc1f8000>

	/* Setup IRQ handler for PLIC driver */
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ,
200122f8:	00000593          	li	a1,0
200122fc:	00b00513          	li	a0,11
20012300:	e71ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
		    plic_irq_handler,
		    NULL,
		    0);

	/* Enable IRQ for PLIC driver */
	irq_enable(RISCV_MACHINE_EXT_IRQ);
20012304:	00b00513          	li	a0,11
20012308:	e21ff0ef          	jal	ra,20012128 <arch_irq_enable>

	return 0;
}
2001230c:	00c12083          	lw	ra,12(sp)
20012310:	00000513          	li	a0,0
20012314:	01010113          	addi	sp,sp,16
20012318:	00008067          	ret

2001231c <plic_irq_handler>:
{
2001231c:	ff010113          	addi	sp,sp,-16
	irq = regs->claim_complete;
20012320:	0c2007b7          	lui	a5,0xc200
{
20012324:	00812423          	sw	s0,8(sp)
	irq = regs->claim_complete;
20012328:	0047a403          	lw	s0,4(a5) # c200004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc1f8004>
	save_irq = irq;
2001232c:	800007b7          	lui	a5,0x80000
{
20012330:	00912223          	sw	s1,4(sp)
20012334:	00112623          	sw	ra,12(sp)
	save_irq = irq;
20012338:	0087ac23          	sw	s0,24(a5) # 80000018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000019>
	if (irq == 0U || irq >= PLIC_IRQS)
2001233c:	fff40693          	addi	a3,s0,-1
20012340:	03200713          	li	a4,50
20012344:	01878493          	addi	s1,a5,24
20012348:	00d77663          	bgeu	a4,a3,20012354 <plic_irq_handler+0x38>
		z_irq_spurious(NULL);
2001234c:	00000513          	li	a0,0
20012350:	594000ef          	jal	ra,200128e4 <z_irq_spurious>
	irq += CONFIG_2ND_LVL_ISR_TBL_OFFSET;
20012354:	00c40413          	addi	s0,s0,12
	ite->isr(ite->arg);
20012358:	200157b7          	lui	a5,0x20015
2001235c:	ca478793          	addi	a5,a5,-860 # 20014ca4 <_sw_isr_table>
20012360:	00341413          	slli	s0,s0,0x3
20012364:	00878433          	add	s0,a5,s0
20012368:	00442783          	lw	a5,4(s0)
2001236c:	00042503          	lw	a0,0(s0)
20012370:	000780e7          	jalr	a5
	regs->claim_complete = save_irq;
20012374:	0004a703          	lw	a4,0(s1)
}
20012378:	00c12083          	lw	ra,12(sp)
2001237c:	00812403          	lw	s0,8(sp)
	regs->claim_complete = save_irq;
20012380:	0c2007b7          	lui	a5,0xc200
20012384:	00e7a223          	sw	a4,4(a5) # c200004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc1f8004>
}
20012388:	00412483          	lw	s1,4(sp)
2001238c:	01010113          	addi	sp,sp,16
20012390:	00008067          	ret

20012394 <riscv_plic_irq_enable>:
20012394:	00800793          	li	a5,8
20012398:	3007b7f3          	csrrc	a5,mstatus,a5
	en += (irq >> 5);
2001239c:	00555693          	srli	a3,a0,0x5
200123a0:	00269713          	slli	a4,a3,0x2
200123a4:	0c0026b7          	lui	a3,0xc002
200123a8:	00e686b3          	add	a3,a3,a4
	*en |= (1 << (irq & 31));
200123ac:	0006a603          	lw	a2,0(a3) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbffa000>
200123b0:	00100713          	li	a4,1
200123b4:	00a71533          	sll	a0,a4,a0
200123b8:	00c56533          	or	a0,a0,a2
200123bc:	00a6a023          	sw	a0,0(a3)
	key = (mstatus & MSTATUS_IEN);
200123c0:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
200123c4:	3007a7f3          	csrrs	a5,mstatus,a5
}
200123c8:	00008067          	ret

200123cc <riscv_plic_irq_disable>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
200123cc:	00800713          	li	a4,8
200123d0:	30073773          	csrrc	a4,mstatus,a4
	en += (irq >> 5);
200123d4:	00555693          	srli	a3,a0,0x5
200123d8:	00269793          	slli	a5,a3,0x2
200123dc:	0c0026b7          	lui	a3,0xc002
200123e0:	00f686b3          	add	a3,a3,a5
	*en &= ~(1 << (irq & 31));
200123e4:	0006a603          	lw	a2,0(a3) # c002000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xbffa000>
200123e8:	00100793          	li	a5,1
200123ec:	00a797b3          	sll	a5,a5,a0
200123f0:	fff7c793          	not	a5,a5
200123f4:	00c7f7b3          	and	a5,a5,a2
200123f8:	00f6a023          	sw	a5,0(a3)
	key = (mstatus & MSTATUS_IEN);
200123fc:	00877793          	andi	a5,a4,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20012400:	3007a7f3          	csrrs	a5,mstatus,a5
}
20012404:	00008067          	ret

20012408 <riscv_plic_set_priority>:
	if (priority > PLIC_MAX_PRIO)
20012408:	00700793          	li	a5,7
2001240c:	00b7f463          	bgeu	a5,a1,20012414 <riscv_plic_set_priority+0xc>
20012410:	00700593          	li	a1,7
	prio += irq;
20012414:	00251513          	slli	a0,a0,0x2
20012418:	0c0007b7          	lui	a5,0xc000
2001241c:	00a78533          	add	a0,a5,a0
	*prio = priority;
20012420:	00b52023          	sw	a1,0(a0)
}
20012424:	00008067          	ret

20012428 <riscv_plic_get_irq>:
}
20012428:	800007b7          	lui	a5,0x80000
2001242c:	0187a503          	lw	a0,24(a5) # 80000018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000019>
20012430:	00008067          	ret

20012434 <pinmux_sifive_set>:
	((struct pinmux_sifive_regs_t *)(DEV_CFG(dev))->base)

static int pinmux_sifive_set(const struct device *dev, uint32_t pin,
			     uint32_t func)
{
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
20012434:	00452783          	lw	a5,4(a0)

	if (func > SIFIVE_PINMUX_IOF1 ||
20012438:	00100713          	li	a4,1
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
2001243c:	0007a783          	lw	a5,0(a5)
	if (func > SIFIVE_PINMUX_IOF1 ||
20012440:	04c76463          	bltu	a4,a2,20012488 <pinmux_sifive_set+0x54>
20012444:	01f00693          	li	a3,31
	    pin >= SIFIVE_PINMUX_PINS)
		return -EINVAL;
20012448:	fea00513          	li	a0,-22
	if (func > SIFIVE_PINMUX_IOF1 ||
2001244c:	04b6e063          	bltu	a3,a1,2001248c <pinmux_sifive_set+0x58>

	if (func == SIFIVE_PINMUX_IOF1)
		pinmux->iof_sel |= (SIFIVE_PINMUX_IOF1 << pin);
20012450:	00b715b3          	sll	a1,a4,a1
	if (func == SIFIVE_PINMUX_IOF1)
20012454:	02e61263          	bne	a2,a4,20012478 <pinmux_sifive_set+0x44>
		pinmux->iof_sel |= (SIFIVE_PINMUX_IOF1 << pin);
20012458:	0047a703          	lw	a4,4(a5)
2001245c:	00b76733          	or	a4,a4,a1
	else
		pinmux->iof_sel &= ~(SIFIVE_PINMUX_IOF1 << pin);
20012460:	00e7a223          	sw	a4,4(a5)

	/* Enable IO function for this pin */
	pinmux->iof_en |= (1 << pin);
20012464:	0007a703          	lw	a4,0(a5)

	return 0;
20012468:	00000513          	li	a0,0
	pinmux->iof_en |= (1 << pin);
2001246c:	00b765b3          	or	a1,a4,a1
20012470:	00b7a023          	sw	a1,0(a5)
	return 0;
20012474:	00008067          	ret
		pinmux->iof_sel &= ~(SIFIVE_PINMUX_IOF1 << pin);
20012478:	0047a683          	lw	a3,4(a5)
2001247c:	fff5c713          	not	a4,a1
20012480:	00d77733          	and	a4,a4,a3
20012484:	fddff06f          	j	20012460 <pinmux_sifive_set+0x2c>
		return -EINVAL;
20012488:	fea00513          	li	a0,-22
}
2001248c:	00008067          	ret

20012490 <pinmux_sifive_get>:

static int pinmux_sifive_get(const struct device *dev, uint32_t pin,
			     uint32_t *func)
{
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
20012490:	00452783          	lw	a5,4(a0)

	if (pin >= SIFIVE_PINMUX_PINS ||
20012494:	01f00713          	li	a4,31
	    func == NULL)
		return -EINVAL;
20012498:	fea00513          	li	a0,-22
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
2001249c:	0007a783          	lw	a5,0(a5)
	if (pin >= SIFIVE_PINMUX_PINS ||
200124a0:	02b76463          	bltu	a4,a1,200124c8 <pinmux_sifive_get+0x38>
200124a4:	02060263          	beqz	a2,200124c8 <pinmux_sifive_get+0x38>

	*func = (pinmux->iof_sel & (SIFIVE_PINMUX_IOF1 << pin)) ?
200124a8:	0047a703          	lw	a4,4(a5)
200124ac:	00100793          	li	a5,1
200124b0:	00b797b3          	sll	a5,a5,a1
200124b4:	00e7f7b3          	and	a5,a5,a4
		SIFIVE_PINMUX_IOF1 : SIFIVE_PINMUX_IOF0;
200124b8:	00f037b3          	snez	a5,a5
	*func = (pinmux->iof_sel & (SIFIVE_PINMUX_IOF1 << pin)) ?
200124bc:	00f62023          	sw	a5,0(a2) # 4000 <__kernel_ram_size+0x17d0>

	return 0;
200124c0:	00000513          	li	a0,0
200124c4:	00008067          	ret
}
200124c8:	00008067          	ret

200124cc <pinmux_sifive_pullup>:

static int pinmux_sifive_pullup(const struct device *dev, uint32_t pin,
				uint8_t func)
{
	return -ENOTSUP;
}
200124cc:	f7a00513          	li	a0,-134
200124d0:	00008067          	ret

200124d4 <pinmux_sifive_init>:
	return -ENOTSUP;
}

static int pinmux_sifive_init(const struct device *dev)
{
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
200124d4:	00452783          	lw	a5,4(a0)

	/* Ensure that all pins are disabled initially */
	pinmux->iof_en = 0x0;

	return 0;
}
200124d8:	00000513          	li	a0,0
	volatile struct pinmux_sifive_regs_t *pinmux = DEV_PINMUX(dev);
200124dc:	0007a783          	lw	a5,0(a5)
	pinmux->iof_en = 0x0;
200124e0:	0007a023          	sw	zero,0(a5)
}
200124e4:	00008067          	ret

200124e8 <pinmux_sifive_input>:
200124e8:	f7a00513          	li	a0,-134
200124ec:	00008067          	ret

200124f0 <mtime>:
	volatile uint32_t *r = (uint32_t *)RISCV_MTIME_BASE;
	uint32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
200124f0:	0200c7b7          	lui	a5,0x200c
200124f4:	ffc7a703          	lw	a4,-4(a5) # 200bffc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2003ffc>
		lo = r[0];
200124f8:	ff87a503          	lw	a0,-8(a5)
	} while (r[1] != hi);
200124fc:	ffc7a583          	lw	a1,-4(a5)
20012500:	fee59ae3          	bne	a1,a4,200124f4 <mtime+0x4>

	return (((uint64_t)hi) << 32) | lo;
#endif
}
20012504:	00008067          	ret

20012508 <timer_isr>:

static void timer_isr(const void *arg)
{
20012508:	ff010113          	addi	sp,sp,-16
2001250c:	00812423          	sw	s0,8(sp)
20012510:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20012514:	00800413          	li	s0,8
20012518:	30043473          	csrrc	s0,mstatus,s0
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
2001251c:	fd5ff0ef          	jal	ra,200124f0 <mtime>
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
20012520:	80000737          	lui	a4,0x80000
20012524:	00070713          	mv	a4,a4
20012528:	00072683          	lw	a3,0(a4) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
2001252c:	00472603          	lw	a2,4(a4)
	key = (mstatus & MSTATUS_IEN);
20012530:	00847413          	andi	s0,s0,8
20012534:	40d507b3          	sub	a5,a0,a3
20012538:	00f53533          	sltu	a0,a0,a5
2001253c:	40c585b3          	sub	a1,a1,a2
20012540:	40a585b3          	sub	a1,a1,a0
20012544:	01859593          	slli	a1,a1,0x18
20012548:	0087d513          	srli	a0,a5,0x8
2001254c:	00a5e533          	or	a0,a1,a0

	last_count += dticks * CYC_PER_TICK;
20012550:	00851793          	slli	a5,a0,0x8
20012554:	00d786b3          	add	a3,a5,a3
20012558:	00f6b7b3          	sltu	a5,a3,a5
2001255c:	00c787b3          	add	a5,a5,a2
20012560:	00d72023          	sw	a3,0(a4)
20012564:	00f72223          	sw	a5,4(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
20012568:	30042473          	csrrs	s0,mstatus,s0
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
2001256c:	00812403          	lw	s0,8(sp)
20012570:	00c12083          	lw	ra,12(sp)
20012574:	01010113          	addi	sp,sp,16
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
20012578:	4c00206f          	j	20014a38 <sys_clock_announce>

2001257c <sys_clock_driver_init>:

int sys_clock_driver_init(const struct device *dev)
{
2001257c:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(dev);

	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
20012580:	00000593          	li	a1,0
20012584:	00700513          	li	a0,7
{
20012588:	00112623          	sw	ra,12(sp)
	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
2001258c:	be5ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
	last_count = mtime();
20012590:	f61ff0ef          	jal	ra,200124f0 <mtime>
20012594:	800007b7          	lui	a5,0x80000
20012598:	00078793          	mv	a5,a5
2001259c:	00a7a023          	sw	a0,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
200125a0:	00b7a223          	sw	a1,4(a5)
	set_mtimecmp(last_count + CYC_PER_TICK);
200125a4:	10050713          	addi	a4,a0,256
	r[1] = 0xffffffff;
200125a8:	020047b7          	lui	a5,0x2004
200125ac:	fff00693          	li	a3,-1
200125b0:	00d7a223          	sw	a3,4(a5) # 2004004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ffc004>
	set_mtimecmp(last_count + CYC_PER_TICK);
200125b4:	00a73533          	sltu	a0,a4,a0
200125b8:	00b50533          	add	a0,a0,a1
	r[0] = (uint32_t)time;
200125bc:	00e7a023          	sw	a4,0(a5)
	r[1] = (uint32_t)(time >> 32);
200125c0:	00a7a223          	sw	a0,4(a5)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
200125c4:	00700513          	li	a0,7
200125c8:	b61ff0ef          	jal	ra,20012128 <arch_irq_enable>
	return 0;
}
200125cc:	00c12083          	lw	ra,12(sp)
200125d0:	00000513          	li	a0,0
200125d4:	01010113          	addi	sp,sp,16
200125d8:	00008067          	ret

200125dc <sys_clock_set_timeout>:
	 * logic below to reset the comparator, we'll always bump it
	 * forward to the "next tick" due to MIN_DELAY handling and
	 * the interrupt will never fire!  Just rely on the fact that
	 * the OS gave us the proper timeout already.
	 */
	if (idle) {
200125dc:	0c059c63          	bnez	a1,200126b4 <sys_clock_set_timeout+0xd8>
{
200125e0:	ff010113          	addi	sp,sp,-16
200125e4:	00112623          	sw	ra,12(sp)
200125e8:	00812423          	sw	s0,8(sp)
200125ec:	00912223          	sw	s1,4(sp)
		return;
	}

	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
200125f0:	fff00793          	li	a5,-1
200125f4:	0af51463          	bne	a0,a5,2001269c <sys_clock_set_timeout+0xc0>
200125f8:	00800437          	lui	s0,0x800
200125fc:	ffd40413          	addi	s0,s0,-3 # 7ffffd <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7f7ffd>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
20012600:	008007b7          	lui	a5,0x800
20012604:	ffd78713          	addi	a4,a5,-3 # 7ffffd <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7f7ffd>
20012608:	0a874263          	blt	a4,s0,200126ac <sys_clock_set_timeout+0xd0>
	__asm__ volatile ("csrrc %0, mstatus, %1"
2001260c:	00800493          	li	s1,8
20012610:	3004b4f3          	csrrc	s1,mstatus,s1

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
20012614:	eddff0ef          	jal	ra,200124f0 <mtime>
	uint32_t adj, cyc = ticks * CYC_PER_TICK;

	/* Round up to next tick boundary. */
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
20012618:	800007b7          	lui	a5,0x80000
2001261c:	00078793          	mv	a5,a5
20012620:	0007a703          	lw	a4,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
20012624:	0047a603          	lw	a2,4(a5)
	if (cyc <= MAX_CYC - adj) {
20012628:	800007b7          	lui	a5,0x80000
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
2001262c:	40e506b3          	sub	a3,a0,a4
20012630:	0ff68693          	addi	a3,a3,255
	if (cyc <= MAX_CYC - adj) {
20012634:	fff7c793          	not	a5,a5
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
20012638:	00841413          	slli	s0,s0,0x8
	if (cyc <= MAX_CYC - adj) {
2001263c:	40d785b3          	sub	a1,a5,a3
	key = (mstatus & MSTATUS_IEN);
20012640:	0084f493          	andi	s1,s1,8
20012644:	0085e463          	bltu	a1,s0,2001264c <sys_clock_set_timeout+0x70>
		cyc += adj;
20012648:	00d407b3          	add	a5,s0,a3
	} else {
		cyc = MAX_CYC;
	}
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
2001264c:	f007f793          	andi	a5,a5,-256

	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
20012650:	40a70533          	sub	a0,a4,a0
20012654:	00f50533          	add	a0,a0,a5
20012658:	3e700693          	li	a3,999
2001265c:	00a6c463          	blt	a3,a0,20012664 <sys_clock_set_timeout+0x88>
		cyc += CYC_PER_TICK;
20012660:	10078793          	addi	a5,a5,256 # 80000100 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000101>
	}

	set_mtimecmp(cyc + last_count);
20012664:	00e78733          	add	a4,a5,a4
20012668:	00f737b3          	sltu	a5,a4,a5
	r[1] = 0xffffffff;
2001266c:	020046b7          	lui	a3,0x2004
	set_mtimecmp(cyc + last_count);
20012670:	00c787b3          	add	a5,a5,a2
	r[1] = 0xffffffff;
20012674:	fff00613          	li	a2,-1
20012678:	00c6a223          	sw	a2,4(a3) # 2004004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ffc004>
	r[0] = (uint32_t)time;
2001267c:	00e6a023          	sw	a4,0(a3)
	r[1] = (uint32_t)(time >> 32);
20012680:	00f6a223          	sw	a5,4(a3)
	__asm__ volatile ("csrrs %0, mstatus, %1"
20012684:	3004a4f3          	csrrs	s1,mstatus,s1
	k_spin_unlock(&lock, key);
#endif
}
20012688:	00c12083          	lw	ra,12(sp)
2001268c:	00812403          	lw	s0,8(sp)
20012690:	00412483          	lw	s1,4(sp)
20012694:	01010113          	addi	sp,sp,16
20012698:	00008067          	ret
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
2001269c:	fff50413          	addi	s0,a0,-1
200126a0:	f68040e3          	bgtz	s0,20012600 <sys_clock_set_timeout+0x24>
200126a4:	00000413          	li	s0,0
200126a8:	f65ff06f          	j	2001260c <sys_clock_set_timeout+0x30>
200126ac:	ffe78413          	addi	s0,a5,-2
200126b0:	f5dff06f          	j	2001260c <sys_clock_set_timeout+0x30>
200126b4:	00008067          	ret

200126b8 <sys_clock_elapsed>:

uint32_t sys_clock_elapsed(void)
{
200126b8:	ff010113          	addi	sp,sp,-16
200126bc:	00812423          	sw	s0,8(sp)
200126c0:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
200126c4:	00800413          	li	s0,8
200126c8:	30043473          	csrrc	s0,mstatus,s0
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;
200126cc:	e25ff0ef          	jal	ra,200124f0 <mtime>
200126d0:	800007b7          	lui	a5,0x80000
200126d4:	0007a783          	lw	a5,0(a5) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	key = (mstatus & MSTATUS_IEN);
200126d8:	00847413          	andi	s0,s0,8
200126dc:	40f50533          	sub	a0,a0,a5
200126e0:	00855513          	srli	a0,a0,0x8
	__asm__ volatile ("csrrs %0, mstatus, %1"
200126e4:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&lock, key);
	return ret;
}
200126e8:	00c12083          	lw	ra,12(sp)
200126ec:	00812403          	lw	s0,8(sp)
200126f0:	01010113          	addi	sp,sp,16
200126f4:	00008067          	ret

200126f8 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
200126f8:	ff010113          	addi	sp,sp,-16
200126fc:	00812423          	sw	s0,8(sp)
20012700:	00912223          	sw	s1,4(sp)
20012704:	00112623          	sw	ra,12(sp)
20012708:	00050493          	mv	s1,a0
2001270c:	00058413          	mv	s0,a1
	if (esf != NULL) {
20012710:	12058263          	beqz	a1,20012834 <z_riscv_fatal_error+0x13c>
		LOG_ERR("     a0: " PR_REG "    t0: " PR_REG, esf->a0, esf->t0);
20012714:	00c5a683          	lw	a3,12(a1)
20012718:	0285a603          	lw	a2,40(a1)
2001271c:	20015537          	lui	a0,0x20015
20012720:	04500593          	li	a1,69
20012724:	36c50513          	addi	a0,a0,876 # 2001536c <pinmux_sifive_driver_api+0x1c>
20012728:	ab5ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a1: " PR_REG "    t1: " PR_REG, esf->a1, esf->t1);
2001272c:	01042683          	lw	a3,16(s0)
20012730:	02c42603          	lw	a2,44(s0)
20012734:	20015537          	lui	a0,0x20015
20012738:	04500593          	li	a1,69
2001273c:	39050513          	addi	a0,a0,912 # 20015390 <pinmux_sifive_driver_api+0x40>
20012740:	a9dff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a2: " PR_REG "    t2: " PR_REG, esf->a2, esf->t2);
20012744:	01442683          	lw	a3,20(s0)
20012748:	03042603          	lw	a2,48(s0)
2001274c:	20015537          	lui	a0,0x20015
20012750:	04500593          	li	a1,69
20012754:	3b450513          	addi	a0,a0,948 # 200153b4 <pinmux_sifive_driver_api+0x64>
20012758:	a85ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a3: " PR_REG "    t3: " PR_REG, esf->a3, esf->t3);
2001275c:	01842683          	lw	a3,24(s0)
20012760:	03442603          	lw	a2,52(s0)
20012764:	20015537          	lui	a0,0x20015
20012768:	04500593          	li	a1,69
2001276c:	3d850513          	addi	a0,a0,984 # 200153d8 <pinmux_sifive_driver_api+0x88>
20012770:	a6dff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a4: " PR_REG "    t4: " PR_REG, esf->a4, esf->t4);
20012774:	01c42683          	lw	a3,28(s0)
20012778:	03842603          	lw	a2,56(s0)
2001277c:	20015537          	lui	a0,0x20015
20012780:	04500593          	li	a1,69
20012784:	3fc50513          	addi	a0,a0,1020 # 200153fc <pinmux_sifive_driver_api+0xac>
20012788:	a55ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a5: " PR_REG "    t5: " PR_REG, esf->a5, esf->t5);
2001278c:	02042683          	lw	a3,32(s0)
20012790:	03c42603          	lw	a2,60(s0)
20012794:	20015537          	lui	a0,0x20015
20012798:	04500593          	li	a1,69
2001279c:	42050513          	addi	a0,a0,1056 # 20015420 <pinmux_sifive_driver_api+0xd0>
200127a0:	a3dff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a6: " PR_REG "    t6: " PR_REG, esf->a6, esf->t6);
200127a4:	02442683          	lw	a3,36(s0)
200127a8:	04042603          	lw	a2,64(s0)
200127ac:	20015537          	lui	a0,0x20015
200127b0:	04500593          	li	a1,69
200127b4:	44450513          	addi	a0,a0,1092 # 20015444 <pinmux_sifive_driver_api+0xf4>
200127b8:	a25ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     a7: " PR_REG, esf->a7);
200127bc:	04442603          	lw	a2,68(s0)
200127c0:	20015537          	lui	a0,0x20015
200127c4:	04500593          	li	a1,69
200127c8:	46850513          	addi	a0,a0,1128 # 20015468 <pinmux_sifive_driver_api+0x118>
200127cc:	a11ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("         " NO_REG "    tp: " PR_REG, esf->tp);
200127d0:	00842603          	lw	a2,8(s0)
200127d4:	20015537          	lui	a0,0x20015
200127d8:	04500593          	li	a1,69
200127dc:	47c50513          	addi	a0,a0,1148 # 2001547c <pinmux_sifive_driver_api+0x12c>
200127e0:	9fdff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("     ra: " PR_REG "    gp: " PR_REG, esf->ra, esf->gp);
200127e4:	00442683          	lw	a3,4(s0)
200127e8:	00042603          	lw	a2,0(s0)
200127ec:	20015537          	lui	a0,0x20015
200127f0:	04500593          	li	a1,69
200127f4:	4a050513          	addi	a0,a0,1184 # 200154a0 <pinmux_sifive_driver_api+0x150>
200127f8:	9e5ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
200127fc:	04842603          	lw	a2,72(s0)
20012800:	20015537          	lui	a0,0x20015
20012804:	04500593          	li	a1,69
20012808:	4c450513          	addi	a0,a0,1220 # 200154c4 <pinmux_sifive_driver_api+0x174>
2001280c:	9d1ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
20012810:	04c42603          	lw	a2,76(s0)
20012814:	20015537          	lui	a0,0x20015
20012818:	04500593          	li	a1,69
2001281c:	4d850513          	addi	a0,a0,1240 # 200154d8 <pinmux_sifive_driver_api+0x188>
20012820:	9bdff0ef          	jal	ra,200121dc <z_log_minimal_printk>
		LOG_ERR("");
20012824:	20015537          	lui	a0,0x20015
20012828:	04500593          	li	a1,69
2001282c:	4ec50513          	addi	a0,a0,1260 # 200154ec <pinmux_sifive_driver_api+0x19c>
20012830:	9adff0ef          	jal	ra,200121dc <z_log_minimal_printk>
	}

	z_fatal_error(reason, esf);
20012834:	00040593          	mv	a1,s0
20012838:	00048513          	mv	a0,s1
2001283c:	39d000ef          	jal	ra,200133d8 <z_fatal_error>

20012840 <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
20012840:	fd010113          	addi	sp,sp,-48
20012844:	03212023          	sw	s2,32(sp)
20012848:	02112623          	sw	ra,44(sp)
2001284c:	02812423          	sw	s0,40(sp)
20012850:	02912223          	sw	s1,36(sp)
20012854:	01312e23          	sw	s3,28(sp)
20012858:	00050913          	mv	s2,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
2001285c:	34202473          	csrr	s0,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	ulong_t mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
20012860:	343029f3          	csrr	s3,mtval
#endif

	mcause &= SOC_MCAUSE_EXP_MASK;
20012864:	800004b7          	lui	s1,0x80000
20012868:	fff4c613          	not	a2,s1
	LOG_ERR("");
2001286c:	20015537          	lui	a0,0x20015
	mcause &= SOC_MCAUSE_EXP_MASK;
20012870:	00c47633          	and	a2,s0,a2
	LOG_ERR("");
20012874:	04500593          	li	a1,69
20012878:	4ec50513          	addi	a0,a0,1260 # 200154ec <pinmux_sifive_driver_api+0x19c>
2001287c:	ff04c493          	xori	s1,s1,-16
	mcause &= SOC_MCAUSE_EXP_MASK;
20012880:	00c12623          	sw	a2,12(sp)
	z_log_minimal_printk("\n"); \
} while (false)

static inline char z_log_minimal_level_to_char(int level)
{
	switch (level) {
20012884:	00947433          	and	s0,s0,s1
	LOG_ERR("");
20012888:	955ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
	switch (cause) {
2001288c:	00c12603          	lw	a2,12(sp)
20012890:	04041463          	bnez	s0,200128d8 <_Fault+0x98>
20012894:	20015737          	lui	a4,0x20015
20012898:	00261793          	slli	a5,a2,0x2
2001289c:	68870713          	addi	a4,a4,1672 # 20015688 <CSWTCH.915>
200128a0:	00f707b3          	add	a5,a4,a5
200128a4:	0007a683          	lw	a3,0(a5)
	LOG_ERR(" mcause: %ld, %s", mcause, cause_str(mcause));
200128a8:	20015537          	lui	a0,0x20015
200128ac:	04500593          	li	a1,69
200128b0:	4fc50513          	addi	a0,a0,1276 # 200154fc <pinmux_sifive_driver_api+0x1ac>
200128b4:	929ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	LOG_ERR("  mtval: %lx", mtval);
200128b8:	20015537          	lui	a0,0x20015
200128bc:	04500593          	li	a1,69
200128c0:	51450513          	addi	a0,a0,1300 # 20015514 <pinmux_sifive_driver_api+0x1c4>
200128c4:	00098613          	mv	a2,s3
200128c8:	915ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
#endif

	z_riscv_fatal_error(K_ERR_CPU_EXCEPTION, esf);
200128cc:	00090593          	mv	a1,s2
200128d0:	00000513          	li	a0,0
200128d4:	e25ff0ef          	jal	ra,200126f8 <z_riscv_fatal_error>
	LOG_ERR("");
200128d8:	200156b7          	lui	a3,0x20015
200128dc:	4f468693          	addi	a3,a3,1268 # 200154f4 <pinmux_sifive_driver_api+0x1a4>
200128e0:	fc9ff06f          	j	200128a8 <_Fault+0x68>

200128e4 <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
200128e4:	ff010113          	addi	sp,sp,-16
200128e8:	00112623          	sw	ra,12(sp)
200128ec:	00812423          	sw	s0,8(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
200128f0:	34202473          	csrr	s0,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;
200128f4:	00141413          	slli	s0,s0,0x1
200128f8:	00145413          	srli	s0,s0,0x1

	LOG_ERR("Spurious interrupt detected! IRQ: %ld", mcause);
200128fc:	20015537          	lui	a0,0x20015
20012900:	00040613          	mv	a2,s0
20012904:	04500593          	li	a1,69
20012908:	6c850513          	addi	a0,a0,1736 # 200156c8 <CSWTCH.915+0x40>
2001290c:	8d1ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
#if defined(CONFIG_RISCV_HAS_PLIC)
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
20012910:	00b00793          	li	a5,11
20012914:	00f41e63          	bne	s0,a5,20012930 <z_irq_spurious+0x4c>
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
20012918:	b11ff0ef          	jal	ra,20012428 <riscv_plic_get_irq>
2001291c:	00050613          	mv	a2,a0
20012920:	20015537          	lui	a0,0x20015
20012924:	04500593          	li	a1,69
20012928:	6f450513          	addi	a0,a0,1780 # 200156f4 <CSWTCH.915+0x6c>
2001292c:	8b1ff0ef          	jal	ra,200121dc <z_log_minimal_printk>
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
20012930:	00000593          	li	a1,0
20012934:	00100513          	li	a0,1
20012938:	dc1ff0ef          	jal	ra,200126f8 <z_riscv_fatal_error>

2001293c <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
2001293c:	ff010113          	addi	sp,sp,-16
20012940:	00112623          	sw	ra,12(sp)
	z_bss_zero();
20012944:	371000ef          	jal	ra,200134b4 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
20012948:	581010ef          	jal	ra,200146c8 <z_data_copy>
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
2001294c:	83dff0ef          	jal	ra,20012188 <soc_interrupt_init>
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
20012950:	3d5000ef          	jal	ra,20013524 <z_cstart>

20012954 <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
20012954:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
20012958:	00050663          	beqz	a0,20012964 <boot_master_core>

2001295c <loop_slave_core>:

loop_slave_core:
	wfi
2001295c:	10500073          	wfi
	j loop_slave_core
20012960:	ffdff06f          	j	2001295c <loop_slave_core>

20012964 <boot_master_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
20012964:	5ffef117          	auipc	sp,0x5ffef
20012968:	44c10113          	addi	sp,sp,1100 # 80001db0 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
2001296c:	000012b7          	lui	t0,0x1
20012970:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
20012974:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
20012978:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
2001297c:	fc1ff0ef          	jal	ra,2001293c <_PrepC>

20012980 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
20012980:	ef4fe06f          	j	20011074 <z_thread_entry>

20012984 <arch_new_thread>:
	stack_init = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
20012984:	fef62023          	sw	a5,-32(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
20012988:	000027b7          	lui	a5,0x2
2001298c:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_ISR_STACK_SIZE+0x1080>
20012990:	fef62e23          	sw	a5,-4(a2)
		stack_init->mstatus |= MSTATUS_FS_INIT;
	}
	stack_init->fp_state = 0;
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
20012994:	200137b7          	lui	a5,0x20013
20012998:	98078793          	addi	a5,a5,-1664 # 20012980 <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
2001299c:	fcd62c23          	sw	a3,-40(a2)
	stack_init->a1 = (ulong_t)p1;
200129a0:	fce62e23          	sw	a4,-36(a2)
	stack_init->a3 = (ulong_t)p3;
200129a4:	ff062223          	sw	a6,-28(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
200129a8:	fef62c23          	sw	a5,-8(a2)
	stack_init = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);
200129ac:	fb060613          	addi	a2,a2,-80

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
200129b0:	02c52823          	sw	a2,48(a0)
}
200129b4:	00008067          	ret

200129b8 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
200129b8:	00050793          	mv	a5,a0
	size_t n = 0;
200129bc:	00000513          	li	a0,0

	while (*s != '\0') {
200129c0:	00a78733          	add	a4,a5,a0
200129c4:	00074703          	lbu	a4,0(a4)
200129c8:	00071463          	bnez	a4,200129d0 <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
200129cc:	00008067          	ret
		n++;
200129d0:	00150513          	addi	a0,a0,1
200129d4:	fedff06f          	j	200129c0 <strlen+0x8>

200129d8 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
200129d8:	00050793          	mv	a5,a0
	size_t n = 0;
200129dc:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
200129e0:	00a78733          	add	a4,a5,a0
200129e4:	00074703          	lbu	a4,0(a4)
200129e8:	00070463          	beqz	a4,200129f0 <strnlen+0x18>
200129ec:	00b51463          	bne	a0,a1,200129f4 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
200129f0:	00008067          	ret
		n++;
200129f4:	00150513          	addi	a0,a0,1
200129f8:	fe9ff06f          	j	200129e0 <strnlen+0x8>

200129fc <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
200129fc:	00054783          	lbu	a5,0(a0)
20012a00:	0005c703          	lbu	a4,0(a1)
20012a04:	00e79463          	bne	a5,a4,20012a0c <strcmp+0x10>
20012a08:	00079663          	bnez	a5,20012a14 <strcmp+0x18>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
20012a0c:	40e78533          	sub	a0,a5,a4
20012a10:	00008067          	ret
		s1++;
20012a14:	00150513          	addi	a0,a0,1
		s2++;
20012a18:	00158593          	addi	a1,a1,1
20012a1c:	fe1ff06f          	j	200129fc <strcmp>

20012a20 <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
20012a20:	02060863          	beqz	a2,20012a50 <memcmp+0x30>
20012a24:	fff60613          	addi	a2,a2,-1
20012a28:	00000713          	li	a4,0
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
20012a2c:	00e507b3          	add	a5,a0,a4
20012a30:	00e586b3          	add	a3,a1,a4
20012a34:	0007c783          	lbu	a5,0(a5)
20012a38:	0006c683          	lbu	a3,0(a3)
20012a3c:	00e60663          	beq	a2,a4,20012a48 <memcmp+0x28>
20012a40:	00170713          	addi	a4,a4,1
20012a44:	fed784e3          	beq	a5,a3,20012a2c <memcmp+0xc>
		c1++;
		c2++;
	}

	return *c1 - *c2;
20012a48:	40d78533          	sub	a0,a5,a3
20012a4c:	00008067          	ret
		return 0;
20012a50:	00000513          	li	a0,0
}
20012a54:	00008067          	ret

20012a58 <memcpy>:

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
20012a58:	00b547b3          	xor	a5,a0,a1
20012a5c:	0037f793          	andi	a5,a5,3
20012a60:	06078063          	beqz	a5,20012ac0 <memcpy+0x68>
	unsigned char *d_byte = (unsigned char *)d;
20012a64:	00050793          	mv	a5,a0
20012a68:	00000713          	li	a4,0
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
20012a6c:	06e61a63          	bne	a2,a4,20012ae0 <memcpy+0x88>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
20012a70:	00008067          	ret
			if (n == 0) {
20012a74:	fe060ee3          	beqz	a2,20012a70 <memcpy+0x18>
			*(d_byte++) = *(s_byte++);
20012a78:	0005c703          	lbu	a4,0(a1)
20012a7c:	00158593          	addi	a1,a1,1
20012a80:	00178793          	addi	a5,a5,1
			n--;
20012a84:	fff60613          	addi	a2,a2,-1
			*(d_byte++) = *(s_byte++);
20012a88:	fee78fa3          	sb	a4,-1(a5)
		while (((uintptr_t)d_byte) & mask) {
20012a8c:	0037f713          	andi	a4,a5,3
20012a90:	fe0712e3          	bnez	a4,20012a74 <memcpy+0x1c>
		while (n >= sizeof(mem_word_t)) {
20012a94:	00300693          	li	a3,3
20012a98:	40e60833          	sub	a6,a2,a4
20012a9c:	0306e663          	bltu	a3,a6,20012ac8 <memcpy+0x70>
20012aa0:	00265713          	srli	a4,a2,0x2
20012aa4:	ffc00693          	li	a3,-4
20012aa8:	02d706b3          	mul	a3,a4,a3
20012aac:	00271713          	slli	a4,a4,0x2
		d_byte = (unsigned char *)d_word;
20012ab0:	00e787b3          	add	a5,a5,a4
		s_byte = (unsigned char *)s_word;
20012ab4:	00e585b3          	add	a1,a1,a4
20012ab8:	00d60633          	add	a2,a2,a3
20012abc:	fadff06f          	j	20012a68 <memcpy+0x10>
	unsigned char *d_byte = (unsigned char *)d;
20012ac0:	00050793          	mv	a5,a0
20012ac4:	fc9ff06f          	j	20012a8c <memcpy+0x34>
			*(d_word++) = *(s_word++);
20012ac8:	00e588b3          	add	a7,a1,a4
20012acc:	0008a883          	lw	a7,0(a7)
20012ad0:	00e78833          	add	a6,a5,a4
20012ad4:	00470713          	addi	a4,a4,4
20012ad8:	01182023          	sw	a7,0(a6)
			n -= sizeof(mem_word_t);
20012adc:	fbdff06f          	j	20012a98 <memcpy+0x40>
		*(d_byte++) = *(s_byte++);
20012ae0:	00e58833          	add	a6,a1,a4
20012ae4:	00084803          	lbu	a6,0(a6)
20012ae8:	00e786b3          	add	a3,a5,a4
20012aec:	00170713          	addi	a4,a4,1
20012af0:	01068023          	sb	a6,0(a3)
		n--;
20012af4:	f79ff06f          	j	20012a6c <memcpy+0x14>

20012af8 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
20012af8:	0ff5f693          	andi	a3,a1,255
	unsigned char *d_byte = (unsigned char *)buf;
20012afc:	00050793          	mv	a5,a0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
20012b00:	0037f713          	andi	a4,a5,3
20012b04:	04071863          	bnez	a4,20012b54 <memset+0x5c>
	}

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
20012b08:	0ff5f593          	andi	a1,a1,255

	c_word |= c_word << 8;
20012b0c:	00859713          	slli	a4,a1,0x8
20012b10:	00b765b3          	or	a1,a4,a1
	c_word |= c_word << 16;
20012b14:	01059713          	slli	a4,a1,0x10
20012b18:	00b765b3          	or	a1,a4,a1
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
20012b1c:	00c78333          	add	t1,a5,a2
20012b20:	00078713          	mv	a4,a5
20012b24:	00300813          	li	a6,3
20012b28:	40e308b3          	sub	a7,t1,a4
20012b2c:	03186e63          	bltu	a6,a7,20012b68 <memset+0x70>
20012b30:	ffc67593          	andi	a1,a2,-4
20012b34:	00265713          	srli	a4,a2,0x2
20012b38:	00b787b3          	add	a5,a5,a1
20012b3c:	ffc00593          	li	a1,-4
20012b40:	02b70733          	mul	a4,a4,a1
20012b44:	00c70633          	add	a2,a4,a2
20012b48:	00c78633          	add	a2,a5,a2

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
20012b4c:	02c79463          	bne	a5,a2,20012b74 <memset+0x7c>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
20012b50:	00008067          	ret
		if (n == 0) {
20012b54:	fe060ee3          	beqz	a2,20012b50 <memset+0x58>
		*(d_byte++) = c_byte;
20012b58:	00178793          	addi	a5,a5,1
		n--;
20012b5c:	fff60613          	addi	a2,a2,-1
		*(d_byte++) = c_byte;
20012b60:	fed78fa3          	sb	a3,-1(a5)
		n--;
20012b64:	f9dff06f          	j	20012b00 <memset+0x8>
		*(d_word++) = c_word;
20012b68:	00470713          	addi	a4,a4,4
20012b6c:	feb72e23          	sw	a1,-4(a4)
		n -= sizeof(mem_word_t);
20012b70:	fb9ff06f          	j	20012b28 <memset+0x30>
		*(d_byte++) = c_byte;
20012b74:	00178793          	addi	a5,a5,1
20012b78:	fed78fa3          	sb	a3,-1(a5)
		n--;
20012b7c:	fd1ff06f          	j	20012b4c <memset+0x54>

20012b80 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
20012b80:	fff00513          	li	a0,-1
20012b84:	00008067          	ret

20012b88 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
20012b88:	800027b7          	lui	a5,0x80002
20012b8c:	64a7ae23          	sw	a0,1628(a5) # 8000265c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000265d>
}
20012b90:	00008067          	ret

20012b94 <hifive1_revb_pinmux_init>:
#include <init.h>
#include <drivers/pinmux.h>
#include <soc.h>

static int hifive1_revb_pinmux_init(const struct device *dev)
{
20012b94:	ff010113          	addi	sp,sp,-16
20012b98:	00812423          	sw	s0,8(sp)
};

static inline int pinmux_pin_set(const struct device *dev, uint32_t pin,
				 uint32_t func)
{
	const struct pinmux_driver_api *api =
20012b9c:	80002437          	lui	s0,0x80002
20012ba0:	66840793          	addi	a5,s0,1640 # 80002668 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002669>
20012ba4:	00912223          	sw	s1,4(sp)
20012ba8:	0087a483          	lw	s1,8(a5)
20012bac:	00112623          	sw	ra,12(sp)
		(const struct pinmux_driver_api *)dev->api;

	return api->set(dev, pin, func);
20012bb0:	00000613          	li	a2,0
20012bb4:	0004a783          	lw	a5,0(s1) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
20012bb8:	01000593          	li	a1,16
20012bbc:	66840513          	addi	a0,s0,1640
20012bc0:	000780e7          	jalr	a5
20012bc4:	0004a783          	lw	a5,0(s1)
20012bc8:	66840513          	addi	a0,s0,1640
20012bcc:	00000613          	li	a2,0
20012bd0:	01100593          	li	a1,17
20012bd4:	000780e7          	jalr	a5
	pinmux_pin_set(p, 12, SIFIVE_PINMUX_IOF0);
	pinmux_pin_set(p, 13, SIFIVE_PINMUX_IOF0);
#endif /* CONFIG_I2C_SIFIVE */

	return 0;
}
20012bd8:	00c12083          	lw	ra,12(sp)
20012bdc:	00812403          	lw	s0,8(sp)
20012be0:	00412483          	lw	s1,4(sp)
20012be4:	00000513          	li	a0,0
20012be8:	01010113          	addi	sp,sp,16
20012bec:	00008067          	ret

20012bf0 <gpio_sifive_config>:
 */
static int gpio_sifive_config(const struct device *dev,
			      gpio_pin_t pin,
			      gpio_flags_t flags)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012bf0:	00452783          	lw	a5,4(a0)
20012bf4:	0047a703          	lw	a4,4(a5)

	if (pin >= SIFIVE_PINMUX_PINS) {
20012bf8:	01f00793          	li	a5,31
20012bfc:	0ab7ec63          	bltu	a5,a1,20012cb4 <gpio_sifive_config+0xc4>
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
		return -ENOTSUP;
	}

	/* We only support pull-ups, not pull-downs */
	if ((flags & GPIO_PULL_DOWN) != 0) {
20012c00:	02267793          	andi	a5,a2,34
		return -ENOTSUP;
20012c04:	f7a00513          	li	a0,-134
	if ((flags & GPIO_PULL_DOWN) != 0) {
20012c08:	0a079863          	bnez	a5,20012cb8 <gpio_sifive_config+0xc8>
	}

	/* Set pull-up if requested */
	WRITE_BIT(gpio->pue, pin, flags & GPIO_PULL_UP);
20012c0c:	00100793          	li	a5,1
20012c10:	00b795b3          	sll	a1,a5,a1
20012c14:	01067793          	andi	a5,a2,16
20012c18:	06078863          	beqz	a5,20012c88 <gpio_sifive_config+0x98>
20012c1c:	01072783          	lw	a5,16(a4)
20012c20:	00b7e7b3          	or	a5,a5,a1
20012c24:	00f72823          	sw	a5,16(a4)

	/* Set the initial output value before enabling output to avoid
	 * glitches
	 */
	if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
20012c28:	00b65793          	srli	a5,a2,0xb
20012c2c:	0017f793          	andi	a5,a5,1
20012c30:	00078863          	beqz	a5,20012c40 <gpio_sifive_config+0x50>
		gpio->out_val |= BIT(pin);
20012c34:	00c72783          	lw	a5,12(a4)
20012c38:	00b7e7b3          	or	a5,a5,a1
20012c3c:	00f72623          	sw	a5,12(a4)
	}
	if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
20012c40:	40067793          	andi	a5,a2,1024
20012c44:	00078a63          	beqz	a5,20012c58 <gpio_sifive_config+0x68>
		gpio->out_val &= ~BIT(pin);
20012c48:	00c72683          	lw	a3,12(a4)
20012c4c:	fff5c793          	not	a5,a1
20012c50:	00d7f7b3          	and	a5,a5,a3
20012c54:	00f72623          	sw	a5,12(a4)
	}

	/* Enable input/output */
	WRITE_BIT(gpio->out_en, pin, flags & GPIO_OUTPUT);
20012c58:	20067793          	andi	a5,a2,512
20012c5c:	02078e63          	beqz	a5,20012c98 <gpio_sifive_config+0xa8>
20012c60:	00872783          	lw	a5,8(a4)
20012c64:	00b7e7b3          	or	a5,a5,a1
20012c68:	00f72423          	sw	a5,8(a4)
	WRITE_BIT(gpio->in_en, pin, flags & GPIO_INPUT);
20012c6c:	00472783          	lw	a5,4(a4)
20012c70:	10067613          	andi	a2,a2,256
20012c74:	02060a63          	beqz	a2,20012ca8 <gpio_sifive_config+0xb8>
20012c78:	00b7e5b3          	or	a1,a5,a1
20012c7c:	00b72223          	sw	a1,4(a4)

	return 0;
20012c80:	00000513          	li	a0,0
20012c84:	00008067          	ret
	WRITE_BIT(gpio->pue, pin, flags & GPIO_PULL_UP);
20012c88:	01072683          	lw	a3,16(a4)
20012c8c:	fff5c793          	not	a5,a1
20012c90:	00d7f7b3          	and	a5,a5,a3
20012c94:	f91ff06f          	j	20012c24 <gpio_sifive_config+0x34>
	WRITE_BIT(gpio->out_en, pin, flags & GPIO_OUTPUT);
20012c98:	00872683          	lw	a3,8(a4)
20012c9c:	fff5c793          	not	a5,a1
20012ca0:	00d7f7b3          	and	a5,a5,a3
20012ca4:	fc5ff06f          	j	20012c68 <gpio_sifive_config+0x78>
	WRITE_BIT(gpio->in_en, pin, flags & GPIO_INPUT);
20012ca8:	fff5c593          	not	a1,a1
20012cac:	00f5f5b3          	and	a1,a1,a5
20012cb0:	fcdff06f          	j	20012c7c <gpio_sifive_config+0x8c>
		return -EINVAL;
20012cb4:	fea00513          	li	a0,-22
}
20012cb8:	00008067          	ret

20012cbc <gpio_sifive_port_get_raw>:

static int gpio_sifive_port_get_raw(const struct device *dev,
				    gpio_port_value_t *value)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012cbc:	00452783          	lw	a5,4(a0)

	*value = gpio->in_val;

	return 0;
}
20012cc0:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012cc4:	0047a783          	lw	a5,4(a5)
	*value = gpio->in_val;
20012cc8:	0007a783          	lw	a5,0(a5)
20012ccc:	00f5a023          	sw	a5,0(a1)
}
20012cd0:	00008067          	ret

20012cd4 <gpio_sifive_port_set_masked_raw>:

static int gpio_sifive_port_set_masked_raw(const struct device *dev,
					   gpio_port_pins_t mask,
					   gpio_port_value_t value)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012cd4:	00452783          	lw	a5,4(a0)

	gpio->out_val = (gpio->out_val & ~mask) | (value & mask);

	return 0;
}
20012cd8:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012cdc:	0047a783          	lw	a5,4(a5)
	gpio->out_val = (gpio->out_val & ~mask) | (value & mask);
20012ce0:	00c7a703          	lw	a4,12(a5)
20012ce4:	00c74633          	xor	a2,a4,a2
20012ce8:	00b67633          	and	a2,a2,a1
20012cec:	00e64633          	xor	a2,a2,a4
20012cf0:	00c7a623          	sw	a2,12(a5)
}
20012cf4:	00008067          	ret

20012cf8 <gpio_sifive_port_set_bits_raw>:

static int gpio_sifive_port_set_bits_raw(const struct device *dev,
					 gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012cf8:	00452783          	lw	a5,4(a0)

	gpio->out_val |= mask;

	return 0;
}
20012cfc:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012d00:	0047a703          	lw	a4,4(a5)
	gpio->out_val |= mask;
20012d04:	00c72783          	lw	a5,12(a4)
20012d08:	00b7e7b3          	or	a5,a5,a1
20012d0c:	00f72623          	sw	a5,12(a4)
}
20012d10:	00008067          	ret

20012d14 <gpio_sifive_port_clear_bits_raw>:

static int gpio_sifive_port_clear_bits_raw(const struct device *dev,
					   gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012d14:	00452783          	lw	a5,4(a0)

	gpio->out_val &= ~mask;
20012d18:	fff5c593          	not	a1,a1

	return 0;
}
20012d1c:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012d20:	0047a783          	lw	a5,4(a5)
	gpio->out_val &= ~mask;
20012d24:	00c7a703          	lw	a4,12(a5)
20012d28:	00e5f5b3          	and	a1,a1,a4
20012d2c:	00b7a623          	sw	a1,12(a5)
}
20012d30:	00008067          	ret

20012d34 <gpio_sifive_port_toggle_bits>:

static int gpio_sifive_port_toggle_bits(const struct device *dev,
					gpio_port_pins_t mask)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012d34:	00452783          	lw	a5,4(a0)

	gpio->out_val ^= mask;

	return 0;
}
20012d38:	00000513          	li	a0,0
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012d3c:	0047a703          	lw	a4,4(a5)
	gpio->out_val ^= mask;
20012d40:	00c72783          	lw	a5,12(a4)
20012d44:	00b7c7b3          	xor	a5,a5,a1
20012d48:	00f72623          	sw	a5,12(a4)
}
20012d4c:	00008067          	ret

20012d50 <gpio_sifive_manage_callback>:

static int gpio_sifive_manage_callback(const struct device *dev,
				       struct gpio_callback *callback,
				       bool set)
{
	struct gpio_sifive_data *data = DEV_GPIO_DATA(dev);
20012d50:	01052783          	lw	a5,16(a0)
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20012d54:	00000693          	li	a3,0
	return list->head;
20012d58:	0047a703          	lw	a4,4(a5)
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
20012d5c:	00071a63          	bnez	a4,20012d70 <gpio_sifive_manage_callback+0x20>
				return -EINVAL;
			}
		}
	}

	if (set) {
20012d60:	04061c63          	bnez	a2,20012db8 <gpio_sifive_manage_callback+0x68>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
20012d64:	00000513          	li	a0,0

	return gpio_manage_callback(&data->cb, callback, set);
}
20012d68:	00008067          	ret
20012d6c:	00050713          	mv	a4,a0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20012d70:	02e59a63          	bne	a1,a4,20012da4 <gpio_sifive_manage_callback+0x54>
	return node->next;
20012d74:	0005a703          	lw	a4,0(a1)
	return list->tail;
20012d78:	0087a503          	lw	a0,8(a5)
Z_GENLIST_REMOVE(slist, snode)
20012d7c:	00069c63          	bnez	a3,20012d94 <gpio_sifive_manage_callback+0x44>
	list->head = node;
20012d80:	00e7a223          	sw	a4,4(a5)
Z_GENLIST_REMOVE(slist, snode)
20012d84:	00b51463          	bne	a0,a1,20012d8c <gpio_sifive_manage_callback+0x3c>
	list->tail = node;
20012d88:	00e7a423          	sw	a4,8(a5)
	parent->next = child;
20012d8c:	0005a023          	sw	zero,0(a1)
20012d90:	fd1ff06f          	j	20012d60 <gpio_sifive_manage_callback+0x10>
20012d94:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
20012d98:	feb51ae3          	bne	a0,a1,20012d8c <gpio_sifive_manage_callback+0x3c>
	list->tail = node;
20012d9c:	00d7a423          	sw	a3,8(a5)
}
20012da0:	fedff06f          	j	20012d8c <gpio_sifive_manage_callback+0x3c>
	return node->next;
20012da4:	00072503          	lw	a0,0(a4)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
20012da8:	00070693          	mv	a3,a4
20012dac:	fc0510e3          	bnez	a0,20012d6c <gpio_sifive_manage_callback+0x1c>
				return -EINVAL;
20012db0:	fea00513          	li	a0,-22
			if (!set) {
20012db4:	fa060ae3          	beqz	a2,20012d68 <gpio_sifive_manage_callback+0x18>
	parent->next = child;
20012db8:	0047a703          	lw	a4,4(a5)
20012dbc:	00e5a023          	sw	a4,0(a1)
Z_GENLIST_PREPEND(slist, snode)
20012dc0:	0087a703          	lw	a4,8(a5)
	list->head = node;
20012dc4:	00b7a223          	sw	a1,4(a5)
Z_GENLIST_PREPEND(slist, snode)
20012dc8:	f8071ee3          	bnez	a4,20012d64 <gpio_sifive_manage_callback+0x14>
	list->tail = node;
20012dcc:	00b7a423          	sw	a1,8(a5)
20012dd0:	f95ff06f          	j	20012d64 <gpio_sifive_manage_callback+0x14>

20012dd4 <gpio_sifive_init>:
 *
 * @return 0
 */
static int gpio_sifive_init(const struct device *dev)
{
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012dd4:	00452703          	lw	a4,4(a0)
{
20012dd8:	ff010113          	addi	sp,sp,-16
20012ddc:	00112623          	sw	ra,12(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012de0:	00472783          	lw	a5,4(a4)
	const struct gpio_sifive_config *cfg = DEV_GPIO_CFG(dev);

	/* Ensure that all gpio registers are reset to 0 initially */
	gpio->in_en   = 0U;
20012de4:	0007a223          	sw	zero,4(a5)
	gpio->out_en  = 0U;
20012de8:	0007a423          	sw	zero,8(a5)
	gpio->pue     = 0U;
20012dec:	0007a823          	sw	zero,16(a5)
	gpio->rise_ie = 0U;
20012df0:	0007ac23          	sw	zero,24(a5)
	gpio->fall_ie = 0U;
20012df4:	0207a023          	sw	zero,32(a5)
	gpio->high_ie = 0U;
20012df8:	0207a423          	sw	zero,40(a5)
	gpio->low_ie  = 0U;
20012dfc:	0207a823          	sw	zero,48(a5)
	gpio->invert  = 0U;
20012e00:	0407a023          	sw	zero,64(a5)

	/* Setup IRQ handler for each gpio pin */
	cfg->gpio_cfg_func();
20012e04:	00c72783          	lw	a5,12(a4)
20012e08:	000780e7          	jalr	a5

	return 0;
}
20012e0c:	00c12083          	lw	ra,12(sp)
20012e10:	00000513          	li	a0,0
20012e14:	01010113          	addi	sp,sp,16
20012e18:	00008067          	ret

20012e1c <gpio_sifive_cfg_0>:
		gpio_sifive_irq_handler,			\
		DEVICE_DT_INST_GET(0),				\
		0);

static void gpio_sifive_cfg_0(void)
{
20012e1c:	ff010113          	addi	sp,sp,-16
20012e20:	00812423          	sw	s0,8(sp)
#if DT_INST_IRQ_HAS_IDX(0, 0)
	IRQ_INIT(0);
20012e24:	00001437          	lui	s0,0x1
20012e28:	90b40513          	addi	a0,s0,-1781 # 90b <CONFIG_ISR_STACK_SIZE+0x10b>
20012e2c:	00100593          	li	a1,1
{
20012e30:	00112623          	sw	ra,12(sp)
	IRQ_INIT(0);
20012e34:	b3cff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 1)
	IRQ_INIT(1);
20012e38:	a0b40513          	addi	a0,s0,-1525
20012e3c:	00100593          	li	a1,1
20012e40:	b30ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 2)
	IRQ_INIT(2);
20012e44:	b0b40513          	addi	a0,s0,-1269
20012e48:	00100593          	li	a1,1
20012e4c:	b24ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 3)
	IRQ_INIT(3);
20012e50:	c0b40513          	addi	a0,s0,-1013
20012e54:	00100593          	li	a1,1
20012e58:	b18ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 4)
	IRQ_INIT(4);
20012e5c:	d0b40513          	addi	a0,s0,-757
20012e60:	00100593          	li	a1,1
20012e64:	b0cff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 5)
	IRQ_INIT(5);
20012e68:	e0b40513          	addi	a0,s0,-501
20012e6c:	00100593          	li	a1,1
20012e70:	b00ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 6)
	IRQ_INIT(6);
20012e74:	f0b40513          	addi	a0,s0,-245
20012e78:	00100593          	li	a1,1
20012e7c:	af4ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 7)
	IRQ_INIT(7);
20012e80:	00b40513          	addi	a0,s0,11
20012e84:	00100593          	li	a1,1
20012e88:	ae8ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 8)
	IRQ_INIT(8);
20012e8c:	10b40513          	addi	a0,s0,267
20012e90:	00100593          	li	a1,1
20012e94:	adcff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 9)
	IRQ_INIT(9);
20012e98:	20b40513          	addi	a0,s0,523
20012e9c:	00100593          	li	a1,1
20012ea0:	ad0ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 10)
	IRQ_INIT(10);
20012ea4:	30b40513          	addi	a0,s0,779
20012ea8:	00100593          	li	a1,1
20012eac:	ac4ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 11)
	IRQ_INIT(11);
20012eb0:	40b40513          	addi	a0,s0,1035
20012eb4:	00100593          	li	a1,1
20012eb8:	ab8ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 12)
	IRQ_INIT(12);
20012ebc:	50b40513          	addi	a0,s0,1291
20012ec0:	00100593          	li	a1,1
20012ec4:	aacff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 13)
	IRQ_INIT(13);
20012ec8:	60b40513          	addi	a0,s0,1547
20012ecc:	00100593          	li	a1,1
20012ed0:	aa0ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 14)
	IRQ_INIT(14);
20012ed4:	70b40513          	addi	a0,s0,1803
20012ed8:	00100593          	li	a1,1
#endif
#if DT_INST_IRQ_HAS_IDX(0, 15)
	IRQ_INIT(15);
20012edc:	00002437          	lui	s0,0x2
	IRQ_INIT(14);
20012ee0:	a90ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
	IRQ_INIT(15);
20012ee4:	80b40513          	addi	a0,s0,-2037 # 180b <CONFIG_ISR_STACK_SIZE+0x100b>
20012ee8:	00100593          	li	a1,1
20012eec:	a84ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 16)
	IRQ_INIT(16);
20012ef0:	90b40513          	addi	a0,s0,-1781
20012ef4:	00100593          	li	a1,1
20012ef8:	a78ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 17)
	IRQ_INIT(17);
20012efc:	a0b40513          	addi	a0,s0,-1525
20012f00:	00100593          	li	a1,1
20012f04:	a6cff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 18)
	IRQ_INIT(18);
20012f08:	b0b40513          	addi	a0,s0,-1269
20012f0c:	00100593          	li	a1,1
20012f10:	a60ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 19)
	IRQ_INIT(19);
20012f14:	c0b40513          	addi	a0,s0,-1013
20012f18:	00100593          	li	a1,1
20012f1c:	a54ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 20)
	IRQ_INIT(20);
20012f20:	d0b40513          	addi	a0,s0,-757
20012f24:	00100593          	li	a1,1
20012f28:	a48ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 21)
	IRQ_INIT(21);
20012f2c:	e0b40513          	addi	a0,s0,-501
20012f30:	00100593          	li	a1,1
20012f34:	a3cff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 22)
	IRQ_INIT(22);
20012f38:	f0b40513          	addi	a0,s0,-245
20012f3c:	00100593          	li	a1,1
20012f40:	a30ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 23)
	IRQ_INIT(23);
20012f44:	00b40513          	addi	a0,s0,11
20012f48:	00100593          	li	a1,1
20012f4c:	a24ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 24)
	IRQ_INIT(24);
20012f50:	10b40513          	addi	a0,s0,267
20012f54:	00100593          	li	a1,1
20012f58:	a18ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 25)
	IRQ_INIT(25);
20012f5c:	20b40513          	addi	a0,s0,523
20012f60:	00100593          	li	a1,1
20012f64:	a0cff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 26)
	IRQ_INIT(26);
20012f68:	30b40513          	addi	a0,s0,779
20012f6c:	00100593          	li	a1,1
20012f70:	a00ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 27)
	IRQ_INIT(27);
20012f74:	40b40513          	addi	a0,s0,1035
20012f78:	00100593          	li	a1,1
20012f7c:	9f4ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 28)
	IRQ_INIT(28);
20012f80:	50b40513          	addi	a0,s0,1291
20012f84:	00100593          	li	a1,1
20012f88:	9e8ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 29)
	IRQ_INIT(29);
20012f8c:	60b40513          	addi	a0,s0,1547
20012f90:	00100593          	li	a1,1
20012f94:	9dcff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 30)
	IRQ_INIT(30);
20012f98:	70b40513          	addi	a0,s0,1803
20012f9c:	00100593          	li	a1,1
20012fa0:	9d0ff0ef          	jal	ra,20012170 <arch_irq_priority_set>
#endif
#if DT_INST_IRQ_HAS_IDX(0, 31)
	IRQ_INIT(31);
#endif
}
20012fa4:	00812403          	lw	s0,8(sp)
20012fa8:	00c12083          	lw	ra,12(sp)
	IRQ_INIT(31);
20012fac:	00003537          	lui	a0,0x3
20012fb0:	00100593          	li	a1,1
20012fb4:	80b50513          	addi	a0,a0,-2037 # 280b <CONFIG_ISR_STACK_SIZE+0x200b>
}
20012fb8:	01010113          	addi	sp,sp,16
	IRQ_INIT(31);
20012fbc:	9b4ff06f          	j	20012170 <arch_irq_priority_set>

20012fc0 <gpio_sifive_irq_handler>:
{
20012fc0:	fe010113          	addi	sp,sp,-32
20012fc4:	00812c23          	sw	s0,24(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012fc8:	00452403          	lw	s0,4(a0)
{
20012fcc:	00912a23          	sw	s1,20(sp)
20012fd0:	01212823          	sw	s2,16(sp)
20012fd4:	01312623          	sw	s3,12(sp)
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20012fd8:	00442903          	lw	s2,4(s0)
	struct gpio_sifive_data *data = DEV_GPIO_DATA(dev);
20012fdc:	01052983          	lw	s3,16(a0)
{
20012fe0:	00112e23          	sw	ra,28(sp)
20012fe4:	00050493          	mv	s1,a0
	uint8_t pin = 1 + (riscv_plic_get_irq() - (uint8_t)(cfg->gpio_irq_base >> 8));
20012fe8:	c40ff0ef          	jal	ra,20012428 <riscv_plic_get_irq>
20012fec:	00842403          	lw	s0,8(s0)
20012ff0:	0049a583          	lw	a1,4(s3)
20012ff4:	00845413          	srli	s0,s0,0x8
20012ff8:	40850533          	sub	a0,a0,s0
20012ffc:	00150513          	addi	a0,a0,1
	gpio->rise_ip = BIT(pin);
20013000:	00100413          	li	s0,1
20013004:	00a41433          	sll	s0,s0,a0
20013008:	00892e23          	sw	s0,28(s2)
	gpio->fall_ip = BIT(pin);
2001300c:	02892223          	sw	s0,36(s2)
	gpio->high_ip = BIT(pin);
20013010:	02892623          	sw	s0,44(s2)
	gpio->low_ip = BIT(pin);
20013014:	02892a23          	sw	s0,52(s2)
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
20013018:	02058863          	beqz	a1,20013048 <gpio_sifive_irq_handler+0x88>
	return node->next;
2001301c:	0005a903          	lw	s2,0(a1)
		if (cb->pin_mask & pins) {
20013020:	0085a603          	lw	a2,8(a1)
20013024:	00c47633          	and	a2,s0,a2
20013028:	00060863          	beqz	a2,20013038 <gpio_sifive_irq_handler+0x78>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
2001302c:	0045a783          	lw	a5,4(a1)
20013030:	00048513          	mv	a0,s1
20013034:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
20013038:	00090863          	beqz	s2,20013048 <gpio_sifive_irq_handler+0x88>
2001303c:	00090593          	mv	a1,s2
20013040:	00092903          	lw	s2,0(s2)
20013044:	fddff06f          	j	20013020 <gpio_sifive_irq_handler+0x60>
}
20013048:	01c12083          	lw	ra,28(sp)
2001304c:	01812403          	lw	s0,24(sp)
20013050:	01412483          	lw	s1,20(sp)
20013054:	01012903          	lw	s2,16(sp)
20013058:	00c12983          	lw	s3,12(sp)
2001305c:	02010113          	addi	sp,sp,32
20013060:	00008067          	ret

20013064 <gpio_sifive_pin_interrupt_configure>:
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20013064:	00452803          	lw	a6,4(a0)
	gpio->rise_ie &= ~BIT(pin);
20013068:	00100713          	li	a4,1
2001306c:	00b71733          	sll	a4,a4,a1
	volatile struct gpio_sifive_t *gpio = DEV_GPIO(dev);
20013070:	00482783          	lw	a5,4(a6)
	gpio->rise_ie &= ~BIT(pin);
20013074:	fff74513          	not	a0,a4
{
20013078:	ff010113          	addi	sp,sp,-16
	gpio->rise_ie &= ~BIT(pin);
2001307c:	0187a883          	lw	a7,24(a5)
{
20013080:	00112623          	sw	ra,12(sp)
	gpio->rise_ie &= ~BIT(pin);
20013084:	00a8f8b3          	and	a7,a7,a0
20013088:	0117ac23          	sw	a7,24(a5)
	gpio->fall_ie &= ~BIT(pin);
2001308c:	0207a883          	lw	a7,32(a5)
20013090:	011578b3          	and	a7,a0,a7
20013094:	0317a023          	sw	a7,32(a5)
	gpio->high_ie &= ~BIT(pin);
20013098:	0287a883          	lw	a7,40(a5)
2001309c:	011578b3          	and	a7,a0,a7
200130a0:	0317a423          	sw	a7,40(a5)
	gpio->low_ie  &= ~BIT(pin);
200130a4:	0307a883          	lw	a7,48(a5)
200130a8:	01157533          	and	a0,a0,a7
200130ac:	02a7a823          	sw	a0,48(a5)
	switch (mode) {
200130b0:	00004537          	lui	a0,0x4
200130b4:	04a60263          	beq	a2,a0,200130f8 <gpio_sifive_pin_interrupt_configure+0x94>
200130b8:	00014537          	lui	a0,0x14
200130bc:	08a60463          	beq	a2,a0,20013144 <gpio_sifive_pin_interrupt_configure+0xe0>
200130c0:	000027b7          	lui	a5,0x2
200130c4:	f7a00513          	li	a0,-134
200130c8:	00f61e63          	bne	a2,a5,200130e4 <gpio_sifive_pin_interrupt_configure+0x80>
		irq_disable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
200130cc:	00882783          	lw	a5,8(a6)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
200130d0:	0087d713          	srli	a4,a5,0x8
200130d4:	00071e63          	bnez	a4,200130f0 <gpio_sifive_pin_interrupt_configure+0x8c>
		pin_irq = base_irq + (pin << 8);
200130d8:	00f58533          	add	a0,a1,a5
		irq_disable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
200130dc:	870ff0ef          	jal	ra,2001214c <arch_irq_disable>
	return 0;
200130e0:	00000513          	li	a0,0
}
200130e4:	00c12083          	lw	ra,12(sp)
200130e8:	01010113          	addi	sp,sp,16
200130ec:	00008067          	ret
		pin_irq = base_irq + (pin << 8);
200130f0:	00859593          	slli	a1,a1,0x8
200130f4:	fe5ff06f          	j	200130d8 <gpio_sifive_pin_interrupt_configure+0x74>
		if (trig == GPIO_INT_TRIG_HIGH) {
200130f8:	00040637          	lui	a2,0x40
200130fc:	02c69663          	bne	a3,a2,20013128 <gpio_sifive_pin_interrupt_configure+0xc4>
			gpio->high_ip = BIT(pin);
20013100:	02e7a623          	sw	a4,44(a5) # 202c <CONFIG_ISR_STACK_SIZE+0x182c>
			gpio->high_ie |= BIT(pin);
20013104:	0287a683          	lw	a3,40(a5)
20013108:	00d76733          	or	a4,a4,a3
2001310c:	02e7a423          	sw	a4,40(a5)
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20013110:	00882783          	lw	a5,8(a6)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
20013114:	0087d713          	srli	a4,a5,0x8
20013118:	02071263          	bnez	a4,2001313c <gpio_sifive_pin_interrupt_configure+0xd8>
		pin_irq = base_irq + (pin << 8);
2001311c:	00f58533          	add	a0,a1,a5
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
20013120:	808ff0ef          	jal	ra,20012128 <arch_irq_enable>
20013124:	fbdff06f          	j	200130e0 <gpio_sifive_pin_interrupt_configure+0x7c>
			gpio->low_ip = BIT(pin);
20013128:	02e7aa23          	sw	a4,52(a5)
			gpio->low_ie  |= BIT(pin);
2001312c:	0307a683          	lw	a3,48(a5)
20013130:	00d76733          	or	a4,a4,a3
20013134:	02e7a823          	sw	a4,48(a5)
20013138:	fd9ff06f          	j	20013110 <gpio_sifive_pin_interrupt_configure+0xac>
		pin_irq = base_irq + (pin << 8);
2001313c:	00859593          	slli	a1,a1,0x8
20013140:	fddff06f          	j	2001311c <gpio_sifive_pin_interrupt_configure+0xb8>
		if ((trig & GPIO_INT_HIGH_1) != 0) {
20013144:	00040637          	lui	a2,0x40
20013148:	00c6f633          	and	a2,a3,a2
2001314c:	00060a63          	beqz	a2,20013160 <gpio_sifive_pin_interrupt_configure+0xfc>
			gpio->rise_ip = BIT(pin);
20013150:	00e7ae23          	sw	a4,28(a5)
			gpio->rise_ie |= BIT(pin);
20013154:	0187a603          	lw	a2,24(a5)
20013158:	00c76633          	or	a2,a4,a2
2001315c:	00c7ac23          	sw	a2,24(a5)
		if ((trig & GPIO_INT_LOW_0) != 0) {
20013160:	00020637          	lui	a2,0x20
20013164:	00c6f6b3          	and	a3,a3,a2
20013168:	00068a63          	beqz	a3,2001317c <gpio_sifive_pin_interrupt_configure+0x118>
			gpio->fall_ip = BIT(pin);
2001316c:	02e7a223          	sw	a4,36(a5)
			gpio->fall_ie |= BIT(pin);
20013170:	0207a683          	lw	a3,32(a5)
20013174:	00d76733          	or	a4,a4,a3
20013178:	02e7a023          	sw	a4,32(a5)
		irq_enable(gpio_sifive_pin_irq(cfg->gpio_irq_base, pin));
2001317c:	00882503          	lw	a0,8(a6)
	return ((irq >> 8) && 0xff) == 0U ? 1 : 2;
20013180:	00855793          	srli	a5,a0,0x8
20013184:	00079663          	bnez	a5,20013190 <gpio_sifive_pin_interrupt_configure+0x12c>
		pin_irq = base_irq + (pin << 8);
20013188:	00a58533          	add	a0,a1,a0
2001318c:	f95ff06f          	j	20013120 <gpio_sifive_pin_interrupt_configure+0xbc>
20013190:	00859593          	slli	a1,a1,0x8
20013194:	ff5ff06f          	j	20013188 <gpio_sifive_pin_interrupt_configure+0x124>

20013198 <uart_sifive_poll_out>:
 * @param c Character to send
 */
static void uart_sifive_poll_out(const struct device *dev,
					 unsigned char c)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
20013198:	00452783          	lw	a5,4(a0) # 14004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc004>
2001319c:	0007a783          	lw	a5,0(a5)

	/* Wait while TX FIFO is full */
	while (uart->tx & TXDATA_FULL) {
200131a0:	0007a703          	lw	a4,0(a5)
200131a4:	fe074ee3          	bltz	a4,200131a0 <uart_sifive_poll_out+0x8>
	}

	uart->tx = (int)c;
200131a8:	00b7a023          	sw	a1,0(a5)
}
200131ac:	00008067          	ret

200131b0 <uart_sifive_poll_in>:
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_sifive_poll_in(const struct device *dev, unsigned char *c)
{
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
200131b0:	00452783          	lw	a5,4(a0)
200131b4:	0007a783          	lw	a5,0(a5)
	uint32_t val = uart->rx;
200131b8:	0047a783          	lw	a5,4(a5)

	if (val & RXDATA_EMPTY) {
200131bc:	0007c863          	bltz	a5,200131cc <uart_sifive_poll_in+0x1c>
		return -1;
	}

	*c = (unsigned char)(val & RXDATA_MASK);
200131c0:	00f58023          	sb	a5,0(a1)

	return 0;
200131c4:	00000513          	li	a0,0
200131c8:	00008067          	ret
		return -1;
200131cc:	fff00513          	li	a0,-1
}
200131d0:	00008067          	ret

200131d4 <uart_sifive_init>:
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */


static int uart_sifive_init(const struct device *dev)
{
	const struct uart_sifive_device_config * const cfg = DEV_CFG(dev);
200131d4:	00452683          	lw	a3,4(a0)
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);

	/* Enable TX and RX channels */
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
200131d8:	000705b7          	lui	a1,0x70
	/* Setup IRQ handler */
	cfg->cfg_func();
#endif

	return 0;
}
200131dc:	00000513          	li	a0,0
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
200131e0:	0106a703          	lw	a4,16(a3)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
200131e4:	00c6a783          	lw	a5,12(a3)
	volatile struct uart_sifive_regs_t *uart = DEV_UART(dev);
200131e8:	0006a603          	lw	a2,0(a3)
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
200131ec:	01071713          	slli	a4,a4,0x10
200131f0:	00b77733          	and	a4,a4,a1
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
200131f4:	01079793          	slli	a5,a5,0x10
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
200131f8:	00176713          	ori	a4,a4,1
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
200131fc:	00b7f7b3          	and	a5,a5,a1
	uart->txctrl = TXCTRL_TXEN | CTRL_CNT(cfg->txcnt_irq);
20013200:	00e62423          	sw	a4,8(a2) # 20008 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x18008>
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
20013204:	0017e793          	ori	a5,a5,1
	uart->div = cfg->sys_clk_freq / cfg->baud_rate - 1;
20013208:	0086a703          	lw	a4,8(a3)
	uart->rxctrl = RXCTRL_RXEN | CTRL_CNT(cfg->rxcnt_irq);
2001320c:	00f62623          	sw	a5,12(a2)
	uart->div = cfg->sys_clk_freq / cfg->baud_rate - 1;
20013210:	0046a783          	lw	a5,4(a3)
20013214:	02e7d7b3          	divu	a5,a5,a4
20013218:	fff78793          	addi	a5,a5,-1
2001321c:	00f62c23          	sw	a5,24(a2)
}
20013220:	00008067          	ret

20013224 <z_device_state_init>:
	while (dev < __device_end) {
		device_pm_state_init(dev);
		z_object_init(dev);
		++dev;
	}
}
20013224:	00008067          	ret

20013228 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20013228:	00251713          	slli	a4,a0,0x2
2001322c:	200157b7          	lui	a5,0x20015
20013230:	00150513          	addi	a0,a0,1
20013234:	78878793          	addi	a5,a5,1928 # 20015788 <levels.0>
20013238:	00251513          	slli	a0,a0,0x2
{
2001323c:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20013240:	00e78733          	add	a4,a5,a4
20013244:	00a78533          	add	a0,a5,a0
{
20013248:	00812c23          	sw	s0,24(sp)
2001324c:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20013250:	00072403          	lw	s0,0(a4)
20013254:	00052903          	lw	s2,0(a0)
{
20013258:	01312623          	sw	s3,12(sp)
2001325c:	00112e23          	sw	ra,28(sp)
20013260:	00912a23          	sw	s1,20(sp)
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
20013264:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
20013268:	03246063          	bltu	s0,s2,20013288 <z_sys_init_run_level+0x60>
			}
			dev->state->initialized = true;
		}
	}
}
2001326c:	01c12083          	lw	ra,28(sp)
20013270:	01812403          	lw	s0,24(sp)
20013274:	01412483          	lw	s1,20(sp)
20013278:	01012903          	lw	s2,16(sp)
2001327c:	00c12983          	lw	s3,12(sp)
20013280:	02010113          	addi	sp,sp,32
20013284:	00008067          	ret
		const struct device *dev = entry->dev;
20013288:	00442483          	lw	s1,4(s0)
		int rc = entry->init(dev);
2001328c:	00042783          	lw	a5,0(s0)
20013290:	00048513          	mv	a0,s1
20013294:	000780e7          	jalr	a5
		if (dev != NULL) {
20013298:	02048863          	beqz	s1,200132c8 <z_sys_init_run_level+0xa0>
				dev->state->init_res = rc;
2001329c:	00c4a783          	lw	a5,12(s1)
			if (rc != 0) {
200132a0:	00050e63          	beqz	a0,200132bc <z_sys_init_run_level+0x94>
				if (rc < 0) {
200132a4:	41f55713          	srai	a4,a0,0x1f
200132a8:	00a74533          	xor	a0,a4,a0
200132ac:	40e50533          	sub	a0,a0,a4
				dev->state->init_res = rc;
200132b0:	00a9d463          	bge	s3,a0,200132b8 <z_sys_init_run_level+0x90>
200132b4:	0ff00513          	li	a0,255
200132b8:	00a78023          	sb	a0,0(a5)
			dev->state->initialized = true;
200132bc:	0007d703          	lhu	a4,0(a5)
200132c0:	10076713          	ori	a4,a4,256
200132c4:	00e79023          	sh	a4,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
200132c8:	00840413          	addi	s0,s0,8
200132cc:	f9dff06f          	j	20013268 <z_sys_init_run_level+0x40>

200132d0 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
200132d0:	00050e63          	beqz	a0,200132ec <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
200132d4:	00c52783          	lw	a5,12(a0)
200132d8:	0007a503          	lw	a0,0(a5)
200132dc:	1ff57513          	andi	a0,a0,511
200132e0:	f0050513          	addi	a0,a0,-256
200132e4:	00153513          	seqz	a0,a0
200132e8:	00008067          	ret
		return false;
200132ec:	00000513          	li	a0,0
}
200132f0:	00008067          	ret

200132f4 <z_impl_device_get_binding>:
{
200132f4:	fe010113          	addi	sp,sp,-32
200132f8:	00112e23          	sw	ra,28(sp)
200132fc:	00812c23          	sw	s0,24(sp)
20013300:	00912a23          	sw	s1,20(sp)
20013304:	01212823          	sw	s2,16(sp)
20013308:	01312623          	sw	s3,12(sp)
	if ((name == NULL) || (name[0] == '\0')) {
2001330c:	02051463          	bnez	a0,20013334 <z_impl_device_get_binding+0x40>
		return NULL;
20013310:	00000413          	li	s0,0
}
20013314:	01c12083          	lw	ra,28(sp)
20013318:	00040513          	mv	a0,s0
2001331c:	01812403          	lw	s0,24(sp)
20013320:	01412483          	lw	s1,20(sp)
20013324:	01012903          	lw	s2,16(sp)
20013328:	00c12983          	lw	s3,12(sp)
2001332c:	02010113          	addi	sp,sp,32
20013330:	00008067          	ret
	if ((name == NULL) || (name[0] == '\0')) {
20013334:	00054783          	lbu	a5,0(a0)
20013338:	00050493          	mv	s1,a0
2001333c:	fc078ae3          	beqz	a5,20013310 <z_impl_device_get_binding+0x1c>
	for (dev = __device_start; dev != __device_end; dev++) {
20013340:	800027b7          	lui	a5,0x80002
20013344:	80002937          	lui	s2,0x80002
20013348:	66878413          	addi	s0,a5,1640 # 80002668 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002669>
2001334c:	66878993          	addi	s3,a5,1640
20013350:	6c890913          	addi	s2,s2,1736 # 800026c8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800026c9>
20013354:	03241063          	bne	s0,s2,20013374 <z_impl_device_get_binding+0x80>
	for (dev = __device_start; dev != __device_end; dev++) {
20013358:	00098413          	mv	s0,s3
2001335c:	fb240ae3          	beq	s0,s2,20013310 <z_impl_device_get_binding+0x1c>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
20013360:	00040513          	mv	a0,s0
20013364:	f6dff0ef          	jal	ra,200132d0 <z_device_ready>
20013368:	02051463          	bnez	a0,20013390 <z_impl_device_get_binding+0x9c>
	for (dev = __device_start; dev != __device_end; dev++) {
2001336c:	01840413          	addi	s0,s0,24
20013370:	fedff06f          	j	2001335c <z_impl_device_get_binding+0x68>
		if (z_device_ready(dev) && (dev->name == name)) {
20013374:	00040513          	mv	a0,s0
20013378:	f59ff0ef          	jal	ra,200132d0 <z_device_ready>
2001337c:	00050663          	beqz	a0,20013388 <z_impl_device_get_binding+0x94>
20013380:	00042783          	lw	a5,0(s0)
20013384:	f89788e3          	beq	a5,s1,20013314 <z_impl_device_get_binding+0x20>
	for (dev = __device_start; dev != __device_end; dev++) {
20013388:	01840413          	addi	s0,s0,24
2001338c:	fc9ff06f          	j	20013354 <z_impl_device_get_binding+0x60>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
20013390:	00042583          	lw	a1,0(s0)
20013394:	00048513          	mv	a0,s1
20013398:	e64ff0ef          	jal	ra,200129fc <strcmp>
2001339c:	fc0518e3          	bnez	a0,2001336c <z_impl_device_get_binding+0x78>
200133a0:	f75ff06f          	j	20013314 <z_impl_device_get_binding+0x20>

200133a4 <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
200133a4:	00800793          	li	a5,8
200133a8:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
200133ac:	0000006f          	j	200133ac <arch_system_halt+0x8>

200133b0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
200133b0:	ff010113          	addi	sp,sp,-16
200133b4:	00812423          	sw	s0,8(sp)
200133b8:	00050413          	mv	s0,a0
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
200133bc:	20015537          	lui	a0,0x20015
200133c0:	79c50513          	addi	a0,a0,1948 # 2001579c <levels.0+0x14>
200133c4:	04500593          	li	a1,69
{
200133c8:	00112623          	sw	ra,12(sp)
	LOG_ERR("Halting system");
200133cc:	e11fe0ef          	jal	ra,200121dc <z_log_minimal_printk>
	arch_system_halt(reason);
200133d0:	00040513          	mv	a0,s0
200133d4:	fd1ff0ef          	jal	ra,200133a4 <arch_system_halt>

200133d8 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
200133d8:	fe010113          	addi	sp,sp,-32
200133dc:	00912a23          	sw	s1,20(sp)
200133e0:	01212823          	sw	s2,16(sp)
200133e4:	01312623          	sw	s3,12(sp)
200133e8:	00112e23          	sw	ra,28(sp)
200133ec:	00812c23          	sw	s0,24(sp)
200133f0:	00050913          	mv	s2,a0
200133f4:	00058993          	mv	s3,a1
200133f8:	00800493          	li	s1,8
200133fc:	3004b4f3          	csrrc	s1,mstatus,s1
	key = (mstatus & MSTATUS_IEN);
20013400:	0084f493          	andi	s1,s1,8
	return z_impl_k_current_get();
20013404:	1c0010ef          	jal	ra,200145c4 <z_impl_k_current_get>
20013408:	00400793          	li	a5,4
2001340c:	00050413          	mv	s0,a0
	switch (reason) {
20013410:	0927ec63          	bltu	a5,s2,200134a8 <z_fatal_error+0xd0>
20013414:	20016737          	lui	a4,0x20016
20013418:	00291793          	slli	a5,s2,0x2
2001341c:	86070713          	addi	a4,a4,-1952 # 20015860 <CSWTCH.190>
20013420:	00f707b3          	add	a5,a4,a5
20013424:	0007a683          	lw	a3,0(a5)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
20013428:	20015537          	lui	a0,0x20015
2001342c:	00000713          	li	a4,0
20013430:	00090613          	mv	a2,s2
20013434:	04500593          	li	a1,69
20013438:	7c050513          	addi	a0,a0,1984 # 200157c0 <levels.0+0x38>
2001343c:	da1fe0ef          	jal	ra,200121dc <z_log_minimal_printk>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
20013440:	00040e63          	beqz	s0,2001345c <z_fatal_error+0x84>
20013444:	00040513          	mv	a0,s0
20013448:	208000ef          	jal	ra,20013650 <k_thread_name_get>
2001344c:	00050693          	mv	a3,a0
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
20013450:	00050663          	beqz	a0,2001345c <z_fatal_error+0x84>
20013454:	00054783          	lbu	a5,0(a0)
20013458:	00079663          	bnez	a5,20013464 <z_fatal_error+0x8c>
		thread_name = "unknown";
2001345c:	200156b7          	lui	a3,0x20015
20013460:	4f468693          	addi	a3,a3,1268 # 200154f4 <pinmux_sifive_driver_api+0x1a4>
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
20013464:	20015537          	lui	a0,0x20015
20013468:	00040613          	mv	a2,s0
2001346c:	04500593          	li	a1,69
20013470:	7f050513          	addi	a0,a0,2032 # 200157f0 <levels.0+0x68>
20013474:	d69fe0ef          	jal	ra,200121dc <z_log_minimal_printk>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
20013478:	00098593          	mv	a1,s3
2001347c:	00090513          	mv	a0,s2
20013480:	f31ff0ef          	jal	ra,200133b0 <k_sys_fatal_error_handler>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013484:	3004a4f3          	csrrs	s1,mstatus,s1
	z_impl_k_thread_abort(thread);
20013488:	00040513          	mv	a0,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
2001348c:	01812403          	lw	s0,24(sp)
20013490:	01c12083          	lw	ra,28(sp)
20013494:	01412483          	lw	s1,20(sp)
20013498:	01012903          	lw	s2,16(sp)
2001349c:	00c12983          	lw	s3,12(sp)
200134a0:	02010113          	addi	sp,sp,32
200134a4:	2200106f          	j	200146c4 <z_impl_k_thread_abort>
	return z_impl_k_current_get();
200134a8:	200156b7          	lui	a3,0x20015
200134ac:	7b068693          	addi	a3,a3,1968 # 200157b0 <levels.0+0x28>
200134b0:	f79ff06f          	j	20013428 <z_fatal_error+0x50>

200134b4 <z_bss_zero>:
 * @return N/A
 */
__boot_func
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
200134b4:	80000537          	lui	a0,0x80000
200134b8:	800007b7          	lui	a5,0x80000
200134bc:	00050613          	mv	a2,a0
200134c0:	3a878793          	addi	a5,a5,936 # 800003a8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a9>
200134c4:	40c78633          	sub	a2,a5,a2
200134c8:	00000593          	li	a1,0
200134cc:	00050513          	mv	a0,a0
200134d0:	e28ff06f          	j	20012af8 <memset>

200134d4 <bg_thread_main>:
 *
 * @return N/A
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
200134d4:	ff010113          	addi	sp,sp,-16
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
200134d8:	800007b7          	lui	a5,0x80000
200134dc:	00100713          	li	a4,1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
200134e0:	00200513          	li	a0,2
{
200134e4:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
200134e8:	02e78c23          	sb	a4,56(a5) # 80000038 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000039>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
200134ec:	d3dff0ef          	jal	ra,20013228 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
200134f0:	6ec010ef          	jal	ra,20014bdc <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
200134f4:	00300513          	li	a0,3
200134f8:	d31ff0ef          	jal	ra,20013228 <z_sys_init_run_level>

	z_init_static_threads();
200134fc:	1ec000ef          	jal	ra,200136e8 <z_init_static_threads>
	z_sys_init_run_level(_SYS_INIT_LEVEL_SMP);
#endif

	extern void main(void);

	main();
20013500:	989fd0ef          	jal	ra,20010e88 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
20013504:	800007b7          	lui	a5,0x80000
20013508:	2e878793          	addi	a5,a5,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
2001350c:	00c7c703          	lbu	a4,12(a5)
20013510:	ffe77713          	andi	a4,a4,-2
20013514:	00e78623          	sb	a4,12(a5)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
20013518:	00c12083          	lw	ra,12(sp)
2001351c:	01010113          	addi	sp,sp,16
20013520:	00008067          	ret

20013524 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
20013524:	f4010113          	addi	sp,sp,-192
20013528:	0b312623          	sw	s3,172(sp)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
2001352c:	10100793          	li	a5,257
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
20013530:	800009b7          	lui	s3,0x80000
20013534:	0a812c23          	sw	s0,184(sp)
	dummy_thread->base.user_options = K_ESSENTIAL;
20013538:	02f11223          	sh	a5,36(sp)
	_current_cpu->current = dummy_thread;
2001353c:	37c98413          	addi	s0,s3,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20013540:	01810793          	addi	a5,sp,24
20013544:	0a112e23          	sw	ra,188(sp)
20013548:	00f42423          	sw	a5,8(s0)
2001354c:	0a912a23          	sw	s1,180(sp)
20013550:	0b212823          	sw	s2,176(sp)
20013554:	0b412423          	sw	s4,168(sp)
	dummy_thread->stack_info.start = 0U;
20013558:	08012623          	sw	zero,140(sp)
	dummy_thread->stack_info.size = 0U;
2001355c:	08012823          	sw	zero,144(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
20013560:	cc5ff0ef          	jal	ra,20013224 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
20013564:	00000513          	li	a0,0
20013568:	cc1ff0ef          	jal	ra,20013228 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
2001356c:	00100513          	li	a0,1
20013570:	cb9ff0ef          	jal	ra,20013228 <z_sys_init_run_level>
	z_sched_init();
20013574:	611000ef          	jal	ra,20014384 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20013578:	200167b7          	lui	a5,0x20016
	_kernel.ready_q.cache = &z_main_thread;
2001357c:	800004b7          	lui	s1,0x80000
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20013580:	00100a13          	li	s4,1
20013584:	87478793          	addi	a5,a5,-1932 # 20015874 <CSWTCH.190+0x14>
20013588:	200136b7          	lui	a3,0x20013
2001358c:	800015b7          	lui	a1,0x80001
	_kernel.ready_q.cache = &z_main_thread;
20013590:	2e848913          	addi	s2,s1,744 # 800002e8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800002e9>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
20013594:	00f12223          	sw	a5,4(sp)
20013598:	00000893          	li	a7,0
2001359c:	00000813          	li	a6,0
200135a0:	00000713          	li	a4,0
200135a4:	4d468693          	addi	a3,a3,1236 # 200134d4 <bg_thread_main>
200135a8:	40000613          	li	a2,1024
200135ac:	7b058593          	addi	a1,a1,1968 # 800017b0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800017b1>
200135b0:	01412023          	sw	s4,0(sp)
200135b4:	00000793          	li	a5,0
200135b8:	2e848513          	addi	a0,s1,744
	_kernel.ready_q.cache = &z_main_thread;
200135bc:	03242023          	sw	s2,32(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
200135c0:	098000ef          	jal	ra,20013658 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
200135c4:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
200135c8:	2e848513          	addi	a0,s1,744
200135cc:	ffb7f793          	andi	a5,a5,-5
200135d0:	00f906a3          	sb	a5,13(s2)
200135d4:	475000ef          	jal	ra,20014248 <z_ready_thread>
	z_setup_new_thread(thread, stack,
200135d8:	80000537          	lui	a0,0x80000
200135dc:	200146b7          	lui	a3,0x20014
200135e0:	800025b7          	lui	a1,0x80002
200135e4:	26050493          	addi	s1,a0,608 # 80000260 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000261>
200135e8:	00012223          	sw	zero,4(sp)
200135ec:	01412023          	sw	s4,0(sp)
200135f0:	00f00893          	li	a7,15
200135f4:	00000813          	li	a6,0
200135f8:	00000793          	li	a5,0
200135fc:	37c98713          	addi	a4,s3,892
20013600:	81068693          	addi	a3,a3,-2032 # 20013810 <idle>
20013604:	20000613          	li	a2,512
20013608:	bb058593          	addi	a1,a1,-1104 # 80001bb0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001bb1>
2001360c:	26050513          	addi	a0,a0,608
20013610:	048000ef          	jal	ra,20013658 <z_setup_new_thread>
20013614:	00d4c783          	lbu	a5,13(s1)
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
20013618:	00942623          	sw	s1,12(s0)
		_kernel.cpus[i].id = i;
2001361c:	00040a23          	sb	zero,20(s0)
20013620:	ffb7f793          	andi	a5,a5,-5
20013624:	00f486a3          	sb	a5,13(s1)
		_kernel.cpus[i].irq_stack =
20013628:	800027b7          	lui	a5,0x80002
2001362c:	5b078793          	addi	a5,a5,1456 # 800025b0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800025b1>
20013630:	00f42223          	sw	a5,4(s0)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
20013634:	01840793          	addi	a5,s0,24
20013638:	00f42c23          	sw	a5,24(s0)
	list->tail = (sys_dnode_t *)list;
2001363c:	00f42e23          	sw	a5,28(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013640:	00800513          	li	a0,8
20013644:	30053573          	csrrc	a0,mstatus,a0
	ret = arch_swap(key);
20013648:	00857513          	andi	a0,a0,8
2001364c:	c59fc0ef          	jal	ra,200102a4 <arch_swap>

20013650 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
20013650:	00000513          	li	a0,0
20013654:	00008067          	ret

20013658 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
20013658:	ff010113          	addi	sp,sp,-16
2001365c:	00812423          	sw	s0,8(sp)
20013660:	00912223          	sw	s1,4(sp)
20013664:	00112623          	sw	ra,12(sp)
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
20013668:	06850e13          	addi	t3,a0,104
	list->head = (sys_dnode_t *)list;
2001366c:	07c52423          	sw	t3,104(a0)
	list->tail = (sys_dnode_t *)list;
20013670:	07c52623          	sw	t3,108(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
20013674:	01012e03          	lw	t3,16(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
20013678:	00f60613          	addi	a2,a2,15
	thread_base->thread_state = (uint8_t)initial_state;

	thread_base->prio = priority;
2001367c:	01150723          	sb	a7,14(a0)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
20013680:	ff067893          	andi	a7,a2,-16
	stack_ptr = (char *)stack + stack_obj_size;
20013684:	011584b3          	add	s1,a1,a7
	thread_base->user_options = (uint8_t)options;
20013688:	01c50623          	sb	t3,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
2001368c:	00400e13          	li	t3,4
	thread_base->pended_on = NULL;
20013690:	00052423          	sw	zero,8(a0)
	thread_base->thread_state = (uint8_t)initial_state;
20013694:	01c506a3          	sb	t3,13(a0)

	thread_base->sched_locked = 0U;
20013698:	000507a3          	sb	zero,15(a0)
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
2001369c:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
200136a0:	00052e23          	sw	zero,28(a0)
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
200136a4:	06b52a23          	sw	a1,116(a0)
	new_thread->stack_info.size = stack_buf_size;
200136a8:	07152c23          	sw	a7,120(a0)
	new_thread->stack_info.delta = delta;
200136ac:	06052e23          	sw	zero,124(a0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
200136b0:	00048613          	mv	a2,s1
{
200136b4:	00050413          	mv	s0,a0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
200136b8:	accff0ef          	jal	ra,20012984 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
200136bc:	800007b7          	lui	a5,0x80000
200136c0:	3847a783          	lw	a5,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
}
200136c4:	00c12083          	lw	ra,12(sp)
	new_thread->init_data = NULL;
200136c8:	06042223          	sw	zero,100(s0)
	new_thread->resource_pool = _current->resource_pool;
200136cc:	0807a783          	lw	a5,128(a5)
}
200136d0:	00048513          	mv	a0,s1
200136d4:	00412483          	lw	s1,4(sp)
	new_thread->resource_pool = _current->resource_pool;
200136d8:	08f42023          	sw	a5,128(s0)
}
200136dc:	00812403          	lw	s0,8(sp)
200136e0:	01010113          	addi	sp,sp,16
200136e4:	00008067          	ret

200136e8 <z_init_static_threads>:
{
200136e8:	fd010113          	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
200136ec:	800027b7          	lui	a5,0x80002
{
200136f0:	03212023          	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
200136f4:	80002937          	lui	s2,0x80002
{
200136f8:	02812423          	sw	s0,40(sp)
200136fc:	02912223          	sw	s1,36(sp)
20013700:	02112623          	sw	ra,44(sp)
20013704:	01312e23          	sw	s3,28(sp)
20013708:	01412c23          	sw	s4,24(sp)
2001370c:	01512a23          	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
20013710:	6c878413          	addi	s0,a5,1736 # 800026c8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800026c9>
20013714:	6c878493          	addi	s1,a5,1736
20013718:	78890913          	addi	s2,s2,1928 # 80002788 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002789>
2001371c:	05246063          	bltu	s0,s2,2001375c <z_init_static_threads+0x74>
	_FOREACH_STATIC_THREAD(thread_data) {
20013720:	00048413          	mv	s0,s1
	k_sched_lock();
20013724:	5d0000ef          	jal	ra,20013cf4 <k_sched_lock>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
20013728:	fff00493          	li	s1,-1
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
2001372c:	3e700993          	li	s3,999

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
20013730:	20014a37          	lui	s4,0x20014
	_FOREACH_STATIC_THREAD(thread_data) {
20013734:	07246663          	bltu	s0,s2,200137a0 <z_init_static_threads+0xb8>
}
20013738:	02812403          	lw	s0,40(sp)
2001373c:	02c12083          	lw	ra,44(sp)
20013740:	02412483          	lw	s1,36(sp)
20013744:	02012903          	lw	s2,32(sp)
20013748:	01c12983          	lw	s3,28(sp)
2001374c:	01812a03          	lw	s4,24(sp)
20013750:	01412a83          	lw	s5,20(sp)
20013754:	03010113          	addi	sp,sp,48
	k_sched_unlock();
20013758:	0a90006f          	j	20014000 <k_sched_unlock>
		z_setup_new_thread(
2001375c:	02c42783          	lw	a5,44(s0)
20013760:	00f12223          	sw	a5,4(sp)
20013764:	02042783          	lw	a5,32(s0)
20013768:	00f12023          	sw	a5,0(sp)
2001376c:	01442783          	lw	a5,20(s0)
20013770:	01c42883          	lw	a7,28(s0)
20013774:	01842803          	lw	a6,24(s0)
20013778:	01042703          	lw	a4,16(s0)
2001377c:	00c42683          	lw	a3,12(s0)
20013780:	00842603          	lw	a2,8(s0)
20013784:	00442583          	lw	a1,4(s0)
20013788:	00042503          	lw	a0,0(s0)
2001378c:	ecdff0ef          	jal	ra,20013658 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
20013790:	00042783          	lw	a5,0(s0)
20013794:	0687a223          	sw	s0,100(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
20013798:	03040413          	addi	s0,s0,48
2001379c:	f81ff06f          	j	2001371c <z_init_static_threads+0x34>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
200137a0:	02442783          	lw	a5,36(s0)
200137a4:	04978063          	beq	a5,s1,200137e4 <z_init_static_threads+0xfc>
			schedule_new_thread(thread_data->init_thread,
200137a8:	00042a83          	lw	s5,0(s0)
					    K_MSEC(thread_data->init_delay));
200137ac:	0007d463          	bgez	a5,200137b4 <z_init_static_threads+0xcc>
200137b0:	00000793          	li	a5,0
200137b4:	41f7d593          	srai	a1,a5,0x1f
200137b8:	0197d713          	srli	a4,a5,0x19
200137bc:	00779793          	slli	a5,a5,0x7
200137c0:	00759593          	slli	a1,a1,0x7
200137c4:	3e778513          	addi	a0,a5,999
200137c8:	00b765b3          	or	a1,a4,a1
200137cc:	00f537b3          	sltu	a5,a0,a5
200137d0:	00b785b3          	add	a1,a5,a1
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
200137d4:	01351c63          	bne	a0,s3,200137ec <z_init_static_threads+0x104>
200137d8:	00059a63          	bnez	a1,200137ec <z_init_static_threads+0x104>
	z_sched_start(thread);
200137dc:	000a8513          	mv	a0,s5
200137e0:	299000ef          	jal	ra,20014278 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
200137e4:	03040413          	addi	s0,s0,48
200137e8:	f4dff06f          	j	20013734 <z_init_static_threads+0x4c>
200137ec:	3e800613          	li	a2,1000
200137f0:	00000693          	li	a3,0
200137f4:	b21fc0ef          	jal	ra,20010314 <__udivdi3>
200137f8:	00050613          	mv	a2,a0
200137fc:	00058693          	mv	a3,a1
20013800:	018a8513          	addi	a0,s5,24
20013804:	2c8a0593          	addi	a1,s4,712 # 200142c8 <z_thread_timeout>
20013808:	7e5000ef          	jal	ra,200147ec <z_add_timeout>
2001380c:	fd9ff06f          	j	200137e4 <z_init_static_threads+0xfc>

20013810 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
20013810:	ff010113          	addi	sp,sp,-16
20013814:	00812423          	sw	s0,8(sp)
20013818:	00112623          	sw	ra,12(sp)
2001381c:	00800413          	li	s0,8
20013820:	300437f3          	csrrc	a5,mstatus,s0
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
20013824:	8e1fe0ef          	jal	ra,20012104 <arch_cpu_idle>
20013828:	ff9ff06f          	j	20013820 <idle+0x10>

2001382c <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
2001382c:	fd010113          	addi	sp,sp,-48
20013830:	02812423          	sw	s0,40(sp)
20013834:	02912223          	sw	s1,36(sp)
20013838:	01312e23          	sw	s3,28(sp)
2001383c:	02112623          	sw	ra,44(sp)
20013840:	03212023          	sw	s2,32(sp)
20013844:	00050413          	mv	s0,a0
20013848:	00068713          	mv	a4,a3

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
2001384c:	00850993          	addi	s3,a0,8
20013850:	00800493          	li	s1,8
20013854:	3004b4f3          	csrrc	s1,mstatus,s1

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
20013858:	02052683          	lw	a3,32(a0)
2001385c:	00c52783          	lw	a5,12(a0)
	key = (mstatus & MSTATUS_IEN);
20013860:	0084f493          	andi	s1,s1,8
20013864:	08f6fe63          	bgeu	a3,a5,20013900 <z_impl_k_msgq_put+0xd4>
20013868:	00b12623          	sw	a1,12(sp)
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
2001386c:	2c9000ef          	jal	ra,20014334 <z_unpend_first_thread>
20013870:	00842603          	lw	a2,8(s0)
		if (pending_thread != NULL) {
20013874:	00c12583          	lw	a1,12(sp)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
20013878:	00050913          	mv	s2,a0
		if (pending_thread != NULL) {
2001387c:	04050263          	beqz	a0,200138c0 <z_impl_k_msgq_put+0x94>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
20013880:	01452503          	lw	a0,20(a0)
20013884:	9d4ff0ef          	jal	ra,20012a58 <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
20013888:	00090513          	mv	a0,s2
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
2001388c:	08092223          	sw	zero,132(s2)
20013890:	1b9000ef          	jal	ra,20014248 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
20013894:	00098513          	mv	a0,s3
20013898:	00048593          	mv	a1,s1
2001389c:	3f4000ef          	jal	ra,20013c90 <z_reschedule>
			return 0;
200138a0:	00000513          	li	a0,0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
200138a4:	02c12083          	lw	ra,44(sp)
200138a8:	02812403          	lw	s0,40(sp)
200138ac:	02412483          	lw	s1,36(sp)
200138b0:	02012903          	lw	s2,32(sp)
200138b4:	01c12983          	lw	s3,28(sp)
200138b8:	03010113          	addi	sp,sp,48
200138bc:	00008067          	ret
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
200138c0:	01c42503          	lw	a0,28(s0)
200138c4:	994ff0ef          	jal	ra,20012a58 <memcpy>
			msgq->write_ptr += msgq->msg_size;
200138c8:	01c42783          	lw	a5,28(s0)
200138cc:	00842703          	lw	a4,8(s0)
200138d0:	00e787b3          	add	a5,a5,a4
			if (msgq->write_ptr == msgq->buffer_end) {
200138d4:	01442703          	lw	a4,20(s0)
			msgq->write_ptr += msgq->msg_size;
200138d8:	00f42e23          	sw	a5,28(s0)
			if (msgq->write_ptr == msgq->buffer_end) {
200138dc:	00e79663          	bne	a5,a4,200138e8 <z_impl_k_msgq_put+0xbc>
				msgq->write_ptr = msgq->buffer_start;
200138e0:	01042783          	lw	a5,16(s0)
200138e4:	00f42e23          	sw	a5,28(s0)
			msgq->used_msgs++;
200138e8:	02042783          	lw	a5,32(s0)
		result = 0;
200138ec:	00000513          	li	a0,0
			msgq->used_msgs++;
200138f0:	00178793          	addi	a5,a5,1
200138f4:	02f42023          	sw	a5,32(s0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
200138f8:	3004a4f3          	csrrs	s1,mstatus,s1
	return result;
200138fc:	fa9ff06f          	j	200138a4 <z_impl_k_msgq_put+0x78>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20013900:	00e667b3          	or	a5,a2,a4
		result = -ENOMSG;
20013904:	fdd00513          	li	a0,-35
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20013908:	fe0788e3          	beqz	a5,200138f8 <z_impl_k_msgq_put+0xcc>
		_current->base.swap_data = (void *) data;
2001390c:	800007b7          	lui	a5,0x80000
20013910:	3847a783          	lw	a5,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
20013914:	00060693          	mv	a3,a2
20013918:	00040613          	mv	a2,s0
}
2001391c:	02812403          	lw	s0,40(sp)
20013920:	02c12083          	lw	ra,44(sp)
20013924:	02012903          	lw	s2,32(sp)
		_current->base.swap_data = (void *) data;
20013928:	00b7aa23          	sw	a1,20(a5)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
2001392c:	00098513          	mv	a0,s3
20013930:	00048593          	mv	a1,s1
}
20013934:	01c12983          	lw	s3,28(sp)
20013938:	02412483          	lw	s1,36(sp)
2001393c:	03010113          	addi	sp,sp,48
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
20013940:	5d80006f          	j	20013f18 <z_pend_curr>

20013944 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
20013944:	fe010113          	addi	sp,sp,-32
20013948:	00812c23          	sw	s0,24(sp)
2001394c:	00050413          	mv	s0,a0
20013950:	00912a23          	sw	s1,20(sp)
20013954:	01312623          	sw	s3,12(sp)
20013958:	00112e23          	sw	ra,28(sp)
2001395c:	01212823          	sw	s2,16(sp)
20013960:	00058513          	mv	a0,a1

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
20013964:	00840993          	addi	s3,s0,8
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013968:	00800493          	li	s1,8
2001396c:	3004b4f3          	csrrc	s1,mstatus,s1

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
20013970:	02042783          	lw	a5,32(s0)
	key = (mstatus & MSTATUS_IEN);
20013974:	0084f493          	andi	s1,s1,8
20013978:	0c078463          	beqz	a5,20013a40 <z_impl_k_msgq_get+0xfc>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
2001397c:	00842603          	lw	a2,8(s0)
20013980:	01842583          	lw	a1,24(s0)
20013984:	8d4ff0ef          	jal	ra,20012a58 <memcpy>
		msgq->read_ptr += msgq->msg_size;
20013988:	01842783          	lw	a5,24(s0)
2001398c:	00842703          	lw	a4,8(s0)
20013990:	00e787b3          	add	a5,a5,a4
		if (msgq->read_ptr == msgq->buffer_end) {
20013994:	01442703          	lw	a4,20(s0)
		msgq->read_ptr += msgq->msg_size;
20013998:	00f42c23          	sw	a5,24(s0)
		if (msgq->read_ptr == msgq->buffer_end) {
2001399c:	00e79663          	bne	a5,a4,200139a8 <z_impl_k_msgq_get+0x64>
			msgq->read_ptr = msgq->buffer_start;
200139a0:	01042783          	lw	a5,16(s0)
200139a4:	00f42c23          	sw	a5,24(s0)
		}
		msgq->used_msgs--;
200139a8:	02042783          	lw	a5,32(s0)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
200139ac:	00040513          	mv	a0,s0
		msgq->used_msgs--;
200139b0:	fff78793          	addi	a5,a5,-1
200139b4:	02f42023          	sw	a5,32(s0)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
200139b8:	17d000ef          	jal	ra,20014334 <z_unpend_first_thread>
200139bc:	00050913          	mv	s2,a0

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
		}
		result = 0;
200139c0:	00000793          	li	a5,0
		if (pending_thread != NULL) {
200139c4:	0c050263          	beqz	a0,20013a88 <z_impl_k_msgq_get+0x144>
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
200139c8:	01452583          	lw	a1,20(a0)
200139cc:	00842603          	lw	a2,8(s0)
200139d0:	01c42503          	lw	a0,28(s0)
200139d4:	884ff0ef          	jal	ra,20012a58 <memcpy>
			msgq->write_ptr += msgq->msg_size;
200139d8:	01c42783          	lw	a5,28(s0)
200139dc:	00842703          	lw	a4,8(s0)
200139e0:	00e787b3          	add	a5,a5,a4
			if (msgq->write_ptr == msgq->buffer_end) {
200139e4:	01442703          	lw	a4,20(s0)
			msgq->write_ptr += msgq->msg_size;
200139e8:	00f42e23          	sw	a5,28(s0)
			if (msgq->write_ptr == msgq->buffer_end) {
200139ec:	00e79663          	bne	a5,a4,200139f8 <z_impl_k_msgq_get+0xb4>
				msgq->write_ptr = msgq->buffer_start;
200139f0:	01042783          	lw	a5,16(s0)
200139f4:	00f42e23          	sw	a5,28(s0)
			msgq->used_msgs++;
200139f8:	02042783          	lw	a5,32(s0)
			z_ready_thread(pending_thread);
200139fc:	00090513          	mv	a0,s2
			msgq->used_msgs++;
20013a00:	00178793          	addi	a5,a5,1
20013a04:	02f42023          	sw	a5,32(s0)
20013a08:	08092223          	sw	zero,132(s2)
			z_ready_thread(pending_thread);
20013a0c:	03d000ef          	jal	ra,20014248 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
20013a10:	00048593          	mv	a1,s1
20013a14:	00098513          	mv	a0,s3
20013a18:	278000ef          	jal	ra,20013c90 <z_reschedule>
			return 0;
20013a1c:	00000793          	li	a5,0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
20013a20:	01c12083          	lw	ra,28(sp)
20013a24:	01812403          	lw	s0,24(sp)
20013a28:	01412483          	lw	s1,20(sp)
20013a2c:	01012903          	lw	s2,16(sp)
20013a30:	00c12983          	lw	s3,12(sp)
20013a34:	00078513          	mv	a0,a5
20013a38:	02010113          	addi	sp,sp,32
20013a3c:	00008067          	ret
20013a40:	00068713          	mv	a4,a3
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20013a44:	00d666b3          	or	a3,a2,a3
		result = -ENOMSG;
20013a48:	fdd00793          	li	a5,-35
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20013a4c:	02068e63          	beqz	a3,20013a88 <z_impl_k_msgq_get+0x144>
		_current->base.swap_data = data;
20013a50:	800007b7          	lui	a5,0x80000
20013a54:	3847a783          	lw	a5,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
20013a58:	00060693          	mv	a3,a2
20013a5c:	00040613          	mv	a2,s0
}
20013a60:	01812403          	lw	s0,24(sp)
20013a64:	01c12083          	lw	ra,28(sp)
20013a68:	01012903          	lw	s2,16(sp)
		_current->base.swap_data = data;
20013a6c:	00b7aa23          	sw	a1,20(a5)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
20013a70:	00098513          	mv	a0,s3
20013a74:	00048593          	mv	a1,s1
}
20013a78:	00c12983          	lw	s3,12(sp)
20013a7c:	01412483          	lw	s1,20(sp)
20013a80:	02010113          	addi	sp,sp,32
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
20013a84:	4940006f          	j	20013f18 <z_pend_curr>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013a88:	3004a4f3          	csrrs	s1,mstatus,s1
	return result;
20013a8c:	f95ff06f          	j	20013a20 <z_impl_k_msgq_get+0xdc>

20013a90 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
20013a90:	ff010113          	addi	sp,sp,-16
20013a94:	00812423          	sw	s0,8(sp)
20013a98:	00912223          	sw	s1,4(sp)
20013a9c:	00112623          	sw	ra,12(sp)
20013aa0:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013aa4:	00800413          	li	s0,8
20013aa8:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & MSTATUS_IEN);
20013aac:	00847413          	andi	s0,s0,8
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
20013ab0:	085000ef          	jal	ra,20014334 <z_unpend_first_thread>

	if (thread != NULL) {
20013ab4:	02050663          	beqz	a0,20013ae0 <z_impl_k_sem_give+0x50>
20013ab8:	08052223          	sw	zero,132(a0)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
20013abc:	78c000ef          	jal	ra,20014248 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
20013ac0:	00040593          	mv	a1,s0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
20013ac4:	00812403          	lw	s0,8(sp)
20013ac8:	00c12083          	lw	ra,12(sp)
20013acc:	00412483          	lw	s1,4(sp)
	z_reschedule(&lock, key);
20013ad0:	80000537          	lui	a0,0x80000
20013ad4:	3a850513          	addi	a0,a0,936 # 800003a8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a9>
}
20013ad8:	01010113          	addi	sp,sp,16
	z_reschedule(&lock, key);
20013adc:	1b40006f          	j	20013c90 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
20013ae0:	0084a703          	lw	a4,8(s1)
20013ae4:	00c4a783          	lw	a5,12(s1)
20013ae8:	40e787b3          	sub	a5,a5,a4
20013aec:	00f037b3          	snez	a5,a5
20013af0:	00e787b3          	add	a5,a5,a4
20013af4:	00f4a423          	sw	a5,8(s1)
}
20013af8:	fc9ff06f          	j	20013ac0 <z_impl_k_sem_give+0x30>

20013afc <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
20013afc:	00058693          	mv	a3,a1
20013b00:	00060713          	mv	a4,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013b04:	00800793          	li	a5,8
20013b08:	3007b7f3          	csrrc	a5,mstatus,a5
	key = (mstatus & MSTATUS_IEN);
20013b0c:	0087f593          	andi	a1,a5,8

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
20013b10:	00852783          	lw	a5,8(a0)
20013b14:	00078c63          	beqz	a5,20013b2c <z_impl_k_sem_take+0x30>
		sem->count--;
20013b18:	fff78793          	addi	a5,a5,-1
20013b1c:	00f52423          	sw	a5,8(a0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013b20:	3005a5f3          	csrrs	a1,mstatus,a1
		k_spin_unlock(&lock, key);
		ret = 0;
20013b24:	00000513          	li	a0,0
		goto out;
20013b28:	00008067          	ret
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
20013b2c:	00c6e7b3          	or	a5,a3,a2
20013b30:	00079863          	bnez	a5,20013b40 <z_impl_k_sem_take+0x44>
20013b34:	3005a5f3          	csrrs	a1,mstatus,a1
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
20013b38:	ff000513          	li	a0,-16

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
20013b3c:	00008067          	ret
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
20013b40:	00050613          	mv	a2,a0
20013b44:	80000537          	lui	a0,0x80000
20013b48:	3a850513          	addi	a0,a0,936 # 800003a8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a9>
20013b4c:	3cc0006f          	j	20013f18 <z_pend_curr>

20013b50 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
20013b50:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
20013b54:	00052783          	lw	a5,0(a0)

	prev->next = next;
20013b58:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
20013b5c:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
20013b60:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
20013b64:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
20013b68:	00008067          	ret

20013b6c <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
20013b6c:	ff010113          	addi	sp,sp,-16
20013b70:	00812423          	sw	s0,8(sp)
20013b74:	00112623          	sw	ra,12(sp)
20013b78:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
20013b7c:	fd5ff0ef          	jal	ra,20013b50 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
20013b80:	00d44783          	lbu	a5,13(s0)
}
20013b84:	00c12083          	lw	ra,12(sp)
	thread->base.pended_on = NULL;
20013b88:	00042423          	sw	zero,8(s0)
20013b8c:	ffd7f793          	andi	a5,a5,-3
20013b90:	00f406a3          	sb	a5,13(s0)
}
20013b94:	00812403          	lw	s0,8(sp)
20013b98:	01010113          	addi	sp,sp,16
20013b9c:	00008067          	ret

20013ba0 <z_reset_time_slice>:
{
20013ba0:	ff010113          	addi	sp,sp,-16
20013ba4:	00812423          	sw	s0,8(sp)
	if (slice_time != 0) {
20013ba8:	80000437          	lui	s0,0x80000
20013bac:	03040413          	addi	s0,s0,48 # 80000030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000031>
20013bb0:	00042783          	lw	a5,0(s0)
{
20013bb4:	00112623          	sw	ra,12(sp)
	if (slice_time != 0) {
20013bb8:	02078863          	beqz	a5,20013be8 <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
20013bbc:	afdfe0ef          	jal	ra,200126b8 <sys_clock_elapsed>
20013bc0:	00050793          	mv	a5,a0
20013bc4:	00042503          	lw	a0,0(s0)
}
20013bc8:	00812403          	lw	s0,8(sp)
20013bcc:	00c12083          	lw	ra,12(sp)
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
20013bd0:	00f507b3          	add	a5,a0,a5
20013bd4:	80000737          	lui	a4,0x80000
20013bd8:	38f72623          	sw	a5,908(a4) # 8000038c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000038d>
		z_set_timeout_expiry(slice_time, false);
20013bdc:	00000593          	li	a1,0
}
20013be0:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
20013be4:	5fd0006f          	j	200149e0 <z_set_timeout_expiry>
}
20013be8:	00c12083          	lw	ra,12(sp)
20013bec:	00812403          	lw	s0,8(sp)
20013bf0:	01010113          	addi	sp,sp,16
20013bf4:	00008067          	ret

20013bf8 <k_sched_time_slice_set>:
{
20013bf8:	ff010113          	addi	sp,sp,-16
20013bfc:	00812423          	sw	s0,8(sp)
20013c00:	00912223          	sw	s1,4(sp)
20013c04:	01212023          	sw	s2,0(sp)
20013c08:	00112623          	sw	ra,12(sp)
20013c0c:	00050493          	mv	s1,a0
20013c10:	00058913          	mv	s2,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013c14:	00800413          	li	s0,8
20013c18:	30043473          	csrrc	s0,mstatus,s0
		_current_cpu->slice_ticks = 0;
20013c1c:	800007b7          	lui	a5,0x80000
20013c20:	3807a623          	sw	zero,908(a5) # 8000038c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000038d>
			return (uint32_t)((t * to_hz + off) / from_hz);
20013c24:	00751793          	slli	a5,a0,0x7
20013c28:	01955593          	srli	a1,a0,0x19
20013c2c:	3e778513          	addi	a0,a5,999
20013c30:	00f537b3          	sltu	a5,a0,a5
20013c34:	00b785b3          	add	a1,a5,a1
20013c38:	3e800613          	li	a2,1000
20013c3c:	00000693          	li	a3,0
20013c40:	ed4fc0ef          	jal	ra,20010314 <__udivdi3>
20013c44:	800007b7          	lui	a5,0x80000
	key = (mstatus & MSTATUS_IEN);
20013c48:	00847413          	andi	s0,s0,8
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
20013c4c:	03078793          	addi	a5,a5,48 # 80000030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000031>
20013c50:	02904863          	bgtz	s1,20013c80 <k_sched_time_slice_set+0x88>
			slice_time = MAX(2, slice_time);
20013c54:	00a7a023          	sw	a0,0(a5)
		slice_max_prio = prio;
20013c58:	800007b7          	lui	a5,0x80000
20013c5c:	0327a623          	sw	s2,44(a5) # 8000002c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000002d>
		z_reset_time_slice();
20013c60:	f41ff0ef          	jal	ra,20013ba0 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013c64:	30042473          	csrrs	s0,mstatus,s0
}
20013c68:	00c12083          	lw	ra,12(sp)
20013c6c:	00812403          	lw	s0,8(sp)
20013c70:	00412483          	lw	s1,4(sp)
20013c74:	00012903          	lw	s2,0(sp)
20013c78:	01010113          	addi	sp,sp,16
20013c7c:	00008067          	ret
			slice_time = MAX(2, slice_time);
20013c80:	00200713          	li	a4,2
20013c84:	fce558e3          	bge	a0,a4,20013c54 <k_sched_time_slice_set+0x5c>
20013c88:	00200513          	li	a0,2
20013c8c:	fc9ff06f          	j	20013c54 <k_sched_time_slice_set+0x5c>

20013c90 <z_reschedule>:
	 * have the single bit set).  But there is a mask applied to
	 * the argument in arch_irq_unlock() that has me worried
	 * that something elseswhere might try to set a bit?  Do it
	 * the safe way for now.
	 */
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
20013c90:	0085f713          	andi	a4,a1,8
{
20013c94:	00058513          	mv	a0,a1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
20013c98:	02070263          	beqz	a4,20013cbc <z_reschedule+0x2c>
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
20013c9c:	800007b7          	lui	a5,0x80000
20013ca0:	37c78793          	addi	a5,a5,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
	if (resched(key.key) && need_swap()) {
20013ca4:	0007a683          	lw	a3,0(a5)
20013ca8:	00069a63          	bnez	a3,20013cbc <z_reschedule+0x2c>
20013cac:	0207a683          	lw	a3,32(a5)
20013cb0:	0087a783          	lw	a5,8(a5)
20013cb4:	00f68463          	beq	a3,a5,20013cbc <z_reschedule+0x2c>
20013cb8:	decfc06f          	j	200102a4 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013cbc:	30072773          	csrrs	a4,mstatus,a4
}
20013cc0:	00008067          	ret

20013cc4 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
20013cc4:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
20013cc8:	00078a63          	beqz	a5,20013cdc <z_reschedule_irqlock+0x18>
	if (resched(key)) {
20013ccc:	80000737          	lui	a4,0x80000
20013cd0:	37c72703          	lw	a4,892(a4) # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20013cd4:	00071463          	bnez	a4,20013cdc <z_reschedule_irqlock+0x18>
20013cd8:	dccfc06f          	j	200102a4 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013cdc:	3007a7f3          	csrrs	a5,mstatus,a5
}
20013ce0:	00008067          	ret

20013ce4 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013ce4:	00800513          	li	a0,8
20013ce8:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
20013cec:	00857513          	andi	a0,a0,8
20013cf0:	fd5ff06f          	j	20013cc4 <z_reschedule_irqlock>

20013cf4 <k_sched_lock>:
20013cf4:	00800793          	li	a5,8
20013cf8:	3007b7f3          	csrrc	a5,mstatus,a5
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
20013cfc:	80000737          	lui	a4,0x80000
20013d00:	38472683          	lw	a3,900(a4) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
20013d04:	00f6c703          	lbu	a4,15(a3)
20013d08:	fff70713          	addi	a4,a4,-1
20013d0c:	00e687a3          	sb	a4,15(a3)
	key = (mstatus & MSTATUS_IEN);
20013d10:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013d14:	3007a7f3          	csrrs	a5,mstatus,a5
}
20013d18:	00008067          	ret

20013d1c <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
20013d1c:	00050793          	mv	a5,a0
	return list->head == list;
20013d20:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20013d24:	00a79463          	bne	a5,a0,20013d2c <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
20013d28:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
20013d2c:	00008067          	ret

20013d30 <update_cache>:
{
20013d30:	ff010113          	addi	sp,sp,-16
20013d34:	01212023          	sw	s2,0(sp)
20013d38:	00050913          	mv	s2,a0
	thread = _priq_run_best(&_kernel.ready_q.runq);
20013d3c:	80000537          	lui	a0,0x80000
20013d40:	3a050513          	addi	a0,a0,928 # 800003a0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a1>
{
20013d44:	00812423          	sw	s0,8(sp)
20013d48:	00912223          	sw	s1,4(sp)
20013d4c:	00112623          	sw	ra,12(sp)
20013d50:	80000437          	lui	s0,0x80000
	thread = _priq_run_best(&_kernel.ready_q.runq);
20013d54:	fc9ff0ef          	jal	ra,20013d1c <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
20013d58:	37c40413          	addi	s0,s0,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20013d5c:	00050493          	mv	s1,a0
20013d60:	00051463          	bnez	a0,20013d68 <update_cache+0x38>
20013d64:	00c42483          	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
20013d68:	00842783          	lw	a5,8(s0)
	if (preempt_ok != 0) {
20013d6c:	02091c63          	bnez	s2,20013da4 <update_cache+0x74>
	if (z_is_thread_prevented_from_running(_current)) {
20013d70:	00d7c703          	lbu	a4,13(a5)
20013d74:	01f77713          	andi	a4,a4,31
20013d78:	02071663          	bnez	a4,20013da4 <update_cache+0x74>
	if (is_preempt(_current) || is_metairq(thread)) {
20013d7c:	00e7d683          	lhu	a3,14(a5)
20013d80:	07f00713          	li	a4,127
20013d84:	02d77063          	bgeu	a4,a3,20013da4 <update_cache+0x74>
		_kernel.ready_q.cache = _current;
20013d88:	02f42023          	sw	a5,32(s0)
}
20013d8c:	00c12083          	lw	ra,12(sp)
20013d90:	00812403          	lw	s0,8(sp)
20013d94:	00412483          	lw	s1,4(sp)
20013d98:	00012903          	lw	s2,0(sp)
20013d9c:	01010113          	addi	sp,sp,16
20013da0:	00008067          	ret
		if (thread != _current) {
20013da4:	00f48463          	beq	s1,a5,20013dac <update_cache+0x7c>
			z_reset_time_slice();
20013da8:	df9ff0ef          	jal	ra,20013ba0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
20013dac:	02942023          	sw	s1,32(s0)
}
20013db0:	fddff06f          	j	20013d8c <update_cache+0x5c>

20013db4 <unready_thread>:
{
20013db4:	ff010113          	addi	sp,sp,-16
20013db8:	00812423          	sw	s0,8(sp)
20013dbc:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
20013dc0:	00d54783          	lbu	a5,13(a0)
20013dc4:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
20013dc8:	01879713          	slli	a4,a5,0x18
20013dcc:	41875713          	srai	a4,a4,0x18
20013dd0:	00075863          	bgez	a4,20013de0 <unready_thread+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20013dd4:	07f7f793          	andi	a5,a5,127
20013dd8:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
20013ddc:	d75ff0ef          	jal	ra,20013b50 <sys_dlist_remove>
	update_cache(thread == _current);
20013de0:	800007b7          	lui	a5,0x80000
20013de4:	3847a503          	lw	a0,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
}
20013de8:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
20013dec:	40850533          	sub	a0,a0,s0
}
20013df0:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
20013df4:	00153513          	seqz	a0,a0
}
20013df8:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
20013dfc:	f35ff06f          	j	20013d30 <update_cache>

20013e00 <add_to_waitq_locked>:
{
20013e00:	ff010113          	addi	sp,sp,-16
20013e04:	00812423          	sw	s0,8(sp)
20013e08:	00912223          	sw	s1,4(sp)
20013e0c:	00050413          	mv	s0,a0
20013e10:	00112623          	sw	ra,12(sp)
20013e14:	00058493          	mv	s1,a1
	unready_thread(thread);
20013e18:	f9dff0ef          	jal	ra,20013db4 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
20013e1c:	00d44783          	lbu	a5,13(s0)
20013e20:	0027e793          	ori	a5,a5,2
20013e24:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
20013e28:	02048e63          	beqz	s1,20013e64 <add_to_waitq_locked+0x64>
	return list->head == list;
20013e2c:	0004a783          	lw	a5,0(s1)
		thread->base.pended_on = wait_q;
20013e30:	00942423          	sw	s1,8(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20013e34:	04f48a63          	beq	s1,a5,20013e88 <add_to_waitq_locked+0x88>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20013e38:	04078863          	beqz	a5,20013e88 <add_to_waitq_locked+0x88>
	int32_t b1 = thread_1->base.prio;
20013e3c:	00e40683          	lb	a3,14(s0)
	int32_t b2 = thread_2->base.prio;
20013e40:	00e78703          	lb	a4,14(a5)
	if (b1 != b2) {
20013e44:	02e68a63          	beq	a3,a4,20013e78 <add_to_waitq_locked+0x78>
		return b2 - b1;
20013e48:	40d70733          	sub	a4,a4,a3
		if (z_sched_prio_cmp(thread, t) > 0) {
20013e4c:	02e05663          	blez	a4,20013e78 <add_to_waitq_locked+0x78>
	sys_dnode_t *const prev = successor->prev;
20013e50:	0047a703          	lw	a4,4(a5)
	node->next = successor;
20013e54:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20013e58:	00e42223          	sw	a4,4(s0)
	prev->next = node;
20013e5c:	00872023          	sw	s0,0(a4)
	successor->prev = node;
20013e60:	0087a223          	sw	s0,4(a5)
}
20013e64:	00c12083          	lw	ra,12(sp)
20013e68:	00812403          	lw	s0,8(sp)
20013e6c:	00412483          	lw	s1,4(sp)
20013e70:	01010113          	addi	sp,sp,16
20013e74:	00008067          	ret
	return (node == list->tail) ? NULL : node->next;
20013e78:	0044a703          	lw	a4,4(s1)
20013e7c:	00e78663          	beq	a5,a4,20013e88 <add_to_waitq_locked+0x88>
20013e80:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20013e84:	fa079ee3          	bnez	a5,20013e40 <add_to_waitq_locked+0x40>
	sys_dnode_t *const tail = list->tail;
20013e88:	0044a783          	lw	a5,4(s1)
	node->next = list;
20013e8c:	00942023          	sw	s1,0(s0)
	node->prev = tail;
20013e90:	00f42223          	sw	a5,4(s0)
	tail->next = node;
20013e94:	0087a023          	sw	s0,0(a5)
	list->tail = node;
20013e98:	0084a223          	sw	s0,4(s1)
}
20013e9c:	fc9ff06f          	j	20013e64 <add_to_waitq_locked+0x64>

20013ea0 <pend>:
{
20013ea0:	fe010113          	addi	sp,sp,-32
20013ea4:	00812c23          	sw	s0,24(sp)
20013ea8:	00912a23          	sw	s1,20(sp)
20013eac:	00112e23          	sw	ra,28(sp)
20013eb0:	00050493          	mv	s1,a0
20013eb4:	00c12623          	sw	a2,12(sp)
20013eb8:	00d12423          	sw	a3,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013ebc:	00800413          	li	s0,8
20013ec0:	30043473          	csrrc	s0,mstatus,s0
		add_to_waitq_locked(thread, wait_q);
20013ec4:	f3dff0ef          	jal	ra,20013e00 <add_to_waitq_locked>
	key = (mstatus & MSTATUS_IEN);
20013ec8:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013ecc:	30042473          	csrrs	s0,mstatus,s0
	add_thread_timeout(thread, timeout);
20013ed0:	00c12603          	lw	a2,12(sp)
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20013ed4:	fff00593          	li	a1,-1
20013ed8:	00812683          	lw	a3,8(sp)
20013edc:	00b61463          	bne	a2,a1,20013ee4 <pend+0x44>
20013ee0:	02c68263          	beq	a3,a2,20013f04 <pend+0x64>
}
20013ee4:	01812403          	lw	s0,24(sp)
20013ee8:	01c12083          	lw	ra,28(sp)
20013eec:	01848513          	addi	a0,s1,24
20013ef0:	01412483          	lw	s1,20(sp)
20013ef4:	200145b7          	lui	a1,0x20014
20013ef8:	2c858593          	addi	a1,a1,712 # 200142c8 <z_thread_timeout>
20013efc:	02010113          	addi	sp,sp,32
20013f00:	0ed0006f          	j	200147ec <z_add_timeout>
20013f04:	01c12083          	lw	ra,28(sp)
20013f08:	01812403          	lw	s0,24(sp)
20013f0c:	01412483          	lw	s1,20(sp)
20013f10:	02010113          	addi	sp,sp,32
20013f14:	00008067          	ret

20013f18 <z_pend_curr>:
	pend(_current, wait_q, timeout);
20013f18:	800007b7          	lui	a5,0x80000
20013f1c:	3847a503          	lw	a0,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
{
20013f20:	ff010113          	addi	sp,sp,-16
20013f24:	00812423          	sw	s0,8(sp)
20013f28:	00058413          	mv	s0,a1
20013f2c:	00060593          	mv	a1,a2
20013f30:	00068613          	mv	a2,a3
20013f34:	00070693          	mv	a3,a4
20013f38:	00112623          	sw	ra,12(sp)
	pend(_current, wait_q, timeout);
20013f3c:	f65ff0ef          	jal	ra,20013ea0 <pend>
20013f40:	00040513          	mv	a0,s0
}
20013f44:	00812403          	lw	s0,8(sp)
20013f48:	00c12083          	lw	ra,12(sp)
20013f4c:	01010113          	addi	sp,sp,16
20013f50:	b54fc06f          	j	200102a4 <arch_swap>

20013f54 <z_impl_k_thread_suspend>:
{
20013f54:	ff010113          	addi	sp,sp,-16
20013f58:	00812423          	sw	s0,8(sp)
20013f5c:	00050413          	mv	s0,a0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
20013f60:	01850513          	addi	a0,a0,24
20013f64:	00912223          	sw	s1,4(sp)
20013f68:	00112623          	sw	ra,12(sp)
20013f6c:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20013f70:	00800493          	li	s1,8
20013f74:	229000ef          	jal	ra,2001499c <z_abort_timeout>
20013f78:	3004b4f3          	csrrc	s1,mstatus,s1
	return (thread->base.thread_state & state) != 0U;
20013f7c:	00d44783          	lbu	a5,13(s0)
	key = (mstatus & MSTATUS_IEN);
20013f80:	0084f493          	andi	s1,s1,8
		if (z_is_thread_queued(thread)) {
20013f84:	01879713          	slli	a4,a5,0x18
20013f88:	41875713          	srai	a4,a4,0x18
20013f8c:	00075a63          	bgez	a4,20013fa0 <z_impl_k_thread_suspend+0x4c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20013f90:	07f7f793          	andi	a5,a5,127
20013f94:	00f406a3          	sb	a5,13(s0)
	sys_dlist_remove(&thread->base.qnode_dlist);
20013f98:	00040513          	mv	a0,s0
20013f9c:	bb5ff0ef          	jal	ra,20013b50 <sys_dlist_remove>
		update_cache(thread == _current);
20013fa0:	80000937          	lui	s2,0x80000
20013fa4:	37c90913          	addi	s2,s2,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
	thread->base.thread_state |= _THREAD_SUSPENDED;
20013fa8:	00d44783          	lbu	a5,13(s0)
20013fac:	00892503          	lw	a0,8(s2)
20013fb0:	0107e793          	ori	a5,a5,16
20013fb4:	40850533          	sub	a0,a0,s0
20013fb8:	00f406a3          	sb	a5,13(s0)
20013fbc:	00153513          	seqz	a0,a0
20013fc0:	d71ff0ef          	jal	ra,20013d30 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20013fc4:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current) {
20013fc8:	00892783          	lw	a5,8(s2)
20013fcc:	00879e63          	bne	a5,s0,20013fe8 <z_impl_k_thread_suspend+0x94>
}
20013fd0:	00812403          	lw	s0,8(sp)
20013fd4:	00c12083          	lw	ra,12(sp)
20013fd8:	00412483          	lw	s1,4(sp)
20013fdc:	00012903          	lw	s2,0(sp)
20013fe0:	01010113          	addi	sp,sp,16
		z_reschedule_unlocked();
20013fe4:	d01ff06f          	j	20013ce4 <z_reschedule_unlocked>
}
20013fe8:	00c12083          	lw	ra,12(sp)
20013fec:	00812403          	lw	s0,8(sp)
20013ff0:	00412483          	lw	s1,4(sp)
20013ff4:	00012903          	lw	s2,0(sp)
20013ff8:	01010113          	addi	sp,sp,16
20013ffc:	00008067          	ret

20014000 <k_sched_unlock>:
{
20014000:	ff010113          	addi	sp,sp,-16
20014004:	00812423          	sw	s0,8(sp)
20014008:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
2001400c:	00800413          	li	s0,8
20014010:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
20014014:	800007b7          	lui	a5,0x80000
20014018:	3847a703          	lw	a4,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
		update_cache(0);
2001401c:	00000513          	li	a0,0
	key = (mstatus & MSTATUS_IEN);
20014020:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
20014024:	00f74783          	lbu	a5,15(a4)
20014028:	00178793          	addi	a5,a5,1
2001402c:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
20014030:	d01ff0ef          	jal	ra,20013d30 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014034:	30042473          	csrrs	s0,mstatus,s0
}
20014038:	00812403          	lw	s0,8(sp)
2001403c:	00c12083          	lw	ra,12(sp)
20014040:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
20014044:	ca1ff06f          	j	20013ce4 <z_reschedule_unlocked>

20014048 <move_thread_to_end_of_prio_q>:
{
20014048:	ff010113          	addi	sp,sp,-16
2001404c:	00812423          	sw	s0,8(sp)
20014050:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
20014054:	00d54783          	lbu	a5,13(a0)
20014058:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
2001405c:	01879713          	slli	a4,a5,0x18
20014060:	41875713          	srai	a4,a4,0x18
20014064:	00075863          	bgez	a4,20014074 <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20014068:	07f7f793          	andi	a5,a5,127
2001406c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
20014070:	ae1ff0ef          	jal	ra,20013b50 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
20014074:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
20014078:	80000737          	lui	a4,0x80000
2001407c:	37c70693          	addi	a3,a4,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20014080:	f807e793          	ori	a5,a5,-128
20014084:	00f406a3          	sb	a5,13(s0)
20014088:	0246a783          	lw	a5,36(a3)
	return (node == list->tail) ? NULL : node->next;
2001408c:	0286a583          	lw	a1,40(a3)
20014090:	800006b7          	lui	a3,0x80000
20014094:	3a068693          	addi	a3,a3,928 # 800003a0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a1>
20014098:	37c70713          	addi	a4,a4,892
	return sys_dlist_is_empty(list) ? NULL : list->head;
2001409c:	04d78c63          	beq	a5,a3,200140f4 <move_thread_to_end_of_prio_q+0xac>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
200140a0:	04078a63          	beqz	a5,200140f4 <move_thread_to_end_of_prio_q+0xac>
	int32_t b1 = thread_1->base.prio;
200140a4:	00e40503          	lb	a0,14(s0)
	int32_t b2 = thread_2->base.prio;
200140a8:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
200140ac:	02c50e63          	beq	a0,a2,200140e8 <move_thread_to_end_of_prio_q+0xa0>
		return b2 - b1;
200140b0:	40a60633          	sub	a2,a2,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
200140b4:	02c05a63          	blez	a2,200140e8 <move_thread_to_end_of_prio_q+0xa0>
	sys_dnode_t *const prev = successor->prev;
200140b8:	0047a683          	lw	a3,4(a5)
	node->next = successor;
200140bc:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
200140c0:	00d42223          	sw	a3,4(s0)
	prev->next = node;
200140c4:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
200140c8:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
200140cc:	00872503          	lw	a0,8(a4)
}
200140d0:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
200140d4:	40850533          	sub	a0,a0,s0
}
200140d8:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
200140dc:	00153513          	seqz	a0,a0
}
200140e0:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
200140e4:	c4dff06f          	j	20013d30 <update_cache>
	return (node == list->tail) ? NULL : node->next;
200140e8:	00b78663          	beq	a5,a1,200140f4 <move_thread_to_end_of_prio_q+0xac>
200140ec:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
200140f0:	fa079ce3          	bnez	a5,200140a8 <move_thread_to_end_of_prio_q+0x60>
	node->next = list;
200140f4:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
200140f8:	00b42223          	sw	a1,4(s0)
	tail->next = node;
200140fc:	0085a023          	sw	s0,0(a1)
	list->tail = node;
20014100:	02872423          	sw	s0,40(a4)
}
20014104:	fc9ff06f          	j	200140cc <move_thread_to_end_of_prio_q+0x84>

20014108 <z_time_slice>:
{
20014108:	ff010113          	addi	sp,sp,-16
2001410c:	00812423          	sw	s0,8(sp)
20014110:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014114:	00800413          	li	s0,8
20014118:	30043473          	csrrc	s0,mstatus,s0
	if (slice_time && sliceable(_current)) {
2001411c:	800007b7          	lui	a5,0x80000
20014120:	0307a703          	lw	a4,48(a5) # 80000030 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000031>
20014124:	800007b7          	lui	a5,0x80000
	key = (mstatus & MSTATUS_IEN);
20014128:	00847413          	andi	s0,s0,8
2001412c:	37c78793          	addi	a5,a5,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20014130:	06070863          	beqz	a4,200141a0 <z_time_slice+0x98>
20014134:	00050693          	mv	a3,a0
20014138:	0087a503          	lw	a0,8(a5)
		&& !z_is_idle_thread_object(thread);
2001413c:	07f00713          	li	a4,127
20014140:	00e55603          	lhu	a2,14(a0)
20014144:	04c76e63          	bltu	a4,a2,200141a0 <z_time_slice+0x98>
		&& !z_is_thread_prevented_from_running(thread)
20014148:	00d54703          	lbu	a4,13(a0)
2001414c:	01f77713          	andi	a4,a4,31
20014150:	04071863          	bnez	a4,200141a0 <z_time_slice+0x98>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
20014154:	80000737          	lui	a4,0x80000
20014158:	00e50603          	lb	a2,14(a0)
2001415c:	02c72703          	lw	a4,44(a4) # 8000002c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000002d>
20014160:	04e64063          	blt	a2,a4,200141a0 <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
20014164:	80000737          	lui	a4,0x80000
20014168:	26070713          	addi	a4,a4,608 # 80000260 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000261>
2001416c:	02e50a63          	beq	a0,a4,200141a0 <z_time_slice+0x98>
		if (ticks >= _current_cpu->slice_ticks) {
20014170:	0107a703          	lw	a4,16(a5)
20014174:	02e6c063          	blt	a3,a4,20014194 <z_time_slice+0x8c>
			move_thread_to_end_of_prio_q(_current);
20014178:	ed1ff0ef          	jal	ra,20014048 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
2001417c:	a25ff0ef          	jal	ra,20013ba0 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014180:	30042473          	csrrs	s0,mstatus,s0
}
20014184:	00c12083          	lw	ra,12(sp)
20014188:	00812403          	lw	s0,8(sp)
2001418c:	01010113          	addi	sp,sp,16
20014190:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
20014194:	40d70733          	sub	a4,a4,a3
20014198:	00e7a823          	sw	a4,16(a5)
2001419c:	fe5ff06f          	j	20014180 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
200141a0:	0007a823          	sw	zero,16(a5)
200141a4:	fddff06f          	j	20014180 <z_time_slice+0x78>

200141a8 <ready_thread>:
200141a8:	00d54783          	lbu	a5,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
200141ac:	01879713          	slli	a4,a5,0x18
200141b0:	41875713          	srai	a4,a4,0x18
200141b4:	08074863          	bltz	a4,20014244 <ready_thread+0x9c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
200141b8:	01f7f713          	andi	a4,a5,31
200141bc:	08071463          	bnez	a4,20014244 <ready_thread+0x9c>
200141c0:	01852703          	lw	a4,24(a0)
200141c4:	08071063          	bnez	a4,20014244 <ready_thread+0x9c>
	thread->base.thread_state |= _THREAD_QUEUED;
200141c8:	f807e793          	ori	a5,a5,-128
	return list->head == list;
200141cc:	80000737          	lui	a4,0x80000
200141d0:	37c70693          	addi	a3,a4,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
200141d4:	00f506a3          	sb	a5,13(a0)
200141d8:	0246a783          	lw	a5,36(a3)
	return (node == list->tail) ? NULL : node->next;
200141dc:	0286a583          	lw	a1,40(a3)
200141e0:	800006b7          	lui	a3,0x80000
200141e4:	3a068693          	addi	a3,a3,928 # 800003a0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a1>
200141e8:	37c70713          	addi	a4,a4,892
	return sys_dlist_is_empty(list) ? NULL : list->head;
200141ec:	04d78263          	beq	a5,a3,20014230 <ready_thread+0x88>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
200141f0:	04078063          	beqz	a5,20014230 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
200141f4:	00e50803          	lb	a6,14(a0)
	int32_t b2 = thread_2->base.prio;
200141f8:	00e78603          	lb	a2,14(a5)
	if (b1 != b2) {
200141fc:	02c80463          	beq	a6,a2,20014224 <ready_thread+0x7c>
		return b2 - b1;
20014200:	41060633          	sub	a2,a2,a6
		if (z_sched_prio_cmp(thread, t) > 0) {
20014204:	02c05063          	blez	a2,20014224 <ready_thread+0x7c>
	sys_dnode_t *const prev = successor->prev;
20014208:	0047a703          	lw	a4,4(a5)
	node->next = successor;
2001420c:	00f52023          	sw	a5,0(a0)
	node->prev = prev;
20014210:	00e52223          	sw	a4,4(a0)
	prev->next = node;
20014214:	00a72023          	sw	a0,0(a4)
	successor->prev = node;
20014218:	00a7a223          	sw	a0,4(a5)
		update_cache(0);
2001421c:	00000513          	li	a0,0
20014220:	b11ff06f          	j	20013d30 <update_cache>
	return (node == list->tail) ? NULL : node->next;
20014224:	00b78663          	beq	a5,a1,20014230 <ready_thread+0x88>
20014228:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
2001422c:	fc0796e3          	bnez	a5,200141f8 <ready_thread+0x50>
	node->next = list;
20014230:	00d52023          	sw	a3,0(a0)
	node->prev = tail;
20014234:	00b52223          	sw	a1,4(a0)
	tail->next = node;
20014238:	00a5a023          	sw	a0,0(a1)
	list->tail = node;
2001423c:	02a72423          	sw	a0,40(a4)
}
20014240:	fddff06f          	j	2001421c <ready_thread+0x74>
}
20014244:	00008067          	ret

20014248 <z_ready_thread>:
{
20014248:	ff010113          	addi	sp,sp,-16
2001424c:	00812423          	sw	s0,8(sp)
20014250:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014254:	00800413          	li	s0,8
20014258:	30043473          	csrrc	s0,mstatus,s0
			ready_thread(thread);
2001425c:	f4dff0ef          	jal	ra,200141a8 <ready_thread>
	key = (mstatus & MSTATUS_IEN);
20014260:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014264:	30042473          	csrrs	s0,mstatus,s0
}
20014268:	00c12083          	lw	ra,12(sp)
2001426c:	00812403          	lw	s0,8(sp)
20014270:	01010113          	addi	sp,sp,16
20014274:	00008067          	ret

20014278 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014278:	00800593          	li	a1,8
2001427c:	3005b5f3          	csrrc	a1,mstatus,a1
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
20014280:	00d54703          	lbu	a4,13(a0)
	key = (mstatus & MSTATUS_IEN);
20014284:	0085f593          	andi	a1,a1,8
	if (z_has_thread_started(thread)) {
20014288:	00477693          	andi	a3,a4,4
2001428c:	00069663          	bnez	a3,20014298 <z_sched_start+0x20>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014290:	3005a5f3          	csrrs	a1,mstatus,a1
		return;
20014294:	00008067          	ret
{
20014298:	fe010113          	addi	sp,sp,-32
2001429c:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
200142a0:	ffb77713          	andi	a4,a4,-5
200142a4:	00e506a3          	sb	a4,13(a0)
200142a8:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
200142ac:	efdff0ef          	jal	ra,200141a8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
200142b0:	00c12583          	lw	a1,12(sp)
}
200142b4:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
200142b8:	80000537          	lui	a0,0x80000
200142bc:	3a850513          	addi	a0,a0,936 # 800003a8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a9>
}
200142c0:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
200142c4:	9cdff06f          	j	20013c90 <z_reschedule>

200142c8 <z_thread_timeout>:
{
200142c8:	fe010113          	addi	sp,sp,-32
200142cc:	00912a23          	sw	s1,20(sp)
200142d0:	00112e23          	sw	ra,28(sp)
200142d4:	00812c23          	sw	s0,24(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
200142d8:	00800493          	li	s1,8
200142dc:	3004b4f3          	csrrc	s1,mstatus,s1
		if (!killed) {
200142e0:	ff554783          	lbu	a5,-11(a0)
	key = (mstatus & MSTATUS_IEN);
200142e4:	0084f493          	andi	s1,s1,8
200142e8:	0287f793          	andi	a5,a5,40
200142ec:	02079863          	bnez	a5,2001431c <z_thread_timeout+0x54>
200142f0:	00050413          	mv	s0,a0
			if (thread->base.pended_on != NULL) {
200142f4:	ff042783          	lw	a5,-16(s0)
	struct k_thread *thread = CONTAINER_OF(timeout,
200142f8:	fe850513          	addi	a0,a0,-24
			if (thread->base.pended_on != NULL) {
200142fc:	00078863          	beqz	a5,2001430c <z_thread_timeout+0x44>
				unpend_thread_no_timeout(thread);
20014300:	00a12623          	sw	a0,12(sp)
20014304:	869ff0ef          	jal	ra,20013b6c <unpend_thread_no_timeout>
20014308:	00c12503          	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
2001430c:	ff544783          	lbu	a5,-11(s0)
20014310:	feb7f793          	andi	a5,a5,-21
20014314:	fef40aa3          	sb	a5,-11(s0)
			ready_thread(thread);
20014318:	e91ff0ef          	jal	ra,200141a8 <ready_thread>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2001431c:	3004a4f3          	csrrs	s1,mstatus,s1
}
20014320:	01c12083          	lw	ra,28(sp)
20014324:	01812403          	lw	s0,24(sp)
20014328:	01412483          	lw	s1,20(sp)
2001432c:	02010113          	addi	sp,sp,32
20014330:	00008067          	ret

20014334 <z_unpend_first_thread>:
{
20014334:	ff010113          	addi	sp,sp,-16
20014338:	00812423          	sw	s0,8(sp)
2001433c:	00112623          	sw	ra,12(sp)
20014340:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014344:	00800413          	li	s0,8
20014348:	30043473          	csrrc	s0,mstatus,s0
		thread = _priq_wait_best(&wait_q->waitq);
2001434c:	9d1ff0ef          	jal	ra,20013d1c <z_priq_dumb_best>
	key = (mstatus & MSTATUS_IEN);
20014350:	00847413          	andi	s0,s0,8
20014354:	00050493          	mv	s1,a0
		if (thread != NULL) {
20014358:	00050863          	beqz	a0,20014368 <z_unpend_first_thread+0x34>
			unpend_thread_no_timeout(thread);
2001435c:	811ff0ef          	jal	ra,20013b6c <unpend_thread_no_timeout>
20014360:	01848513          	addi	a0,s1,24
20014364:	638000ef          	jal	ra,2001499c <z_abort_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014368:	30042473          	csrrs	s0,mstatus,s0
}
2001436c:	00c12083          	lw	ra,12(sp)
20014370:	00812403          	lw	s0,8(sp)
20014374:	00048513          	mv	a0,s1
20014378:	00412483          	lw	s1,4(sp)
2001437c:	01010113          	addi	sp,sp,16
20014380:	00008067          	ret

20014384 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
20014384:	800007b7          	lui	a5,0x80000
20014388:	80000737          	lui	a4,0x80000
2001438c:	37c78793          	addi	a5,a5,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20014390:	3a070713          	addi	a4,a4,928 # 800003a0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a1>
20014394:	02e7a223          	sw	a4,36(a5)
	list->tail = (sys_dnode_t *)list;
20014398:	02e7a423          	sw	a4,40(a5)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
2001439c:	00000593          	li	a1,0
200143a0:	00000513          	li	a0,0
200143a4:	855ff06f          	j	20013bf8 <k_sched_time_slice_set>

200143a8 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
200143a8:	ff010113          	addi	sp,sp,-16
200143ac:	00912223          	sw	s1,4(sp)
200143b0:	00112623          	sw	ra,12(sp)
200143b4:	00812423          	sw	s0,8(sp)
200143b8:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
200143bc:	00800493          	li	s1,8
200143c0:	3004b4f3          	csrrc	s1,mstatus,s1

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(&_kernel.ready_q.runq,
200143c4:	80000437          	lui	s0,0x80000
200143c8:	37c40913          	addi	s2,s0,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
200143cc:	00892503          	lw	a0,8(s2)
	key = (mstatus & MSTATUS_IEN);
200143d0:	0084f493          	andi	s1,s1,8
	thread->base.thread_state &= ~_THREAD_QUEUED;
200143d4:	00d54783          	lbu	a5,13(a0)
200143d8:	07f7f793          	andi	a5,a5,127
200143dc:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
200143e0:	f70ff0ef          	jal	ra,20013b50 <sys_dlist_remove>
			       _current);
	}
	queue_thread(&_kernel.ready_q.runq, _current);
200143e4:	00892783          	lw	a5,8(s2)
	thread->base.thread_state |= _THREAD_QUEUED;
200143e8:	80000637          	lui	a2,0x80000
200143ec:	3a060613          	addi	a2,a2,928 # 800003a0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800003a1>
200143f0:	00d7c703          	lbu	a4,13(a5)
200143f4:	37c40693          	addi	a3,s0,892
200143f8:	f8076713          	ori	a4,a4,-128
200143fc:	00e786a3          	sb	a4,13(a5)
	return list->head == list;
20014400:	02492703          	lw	a4,36(s2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20014404:	06c70263          	beq	a4,a2,20014468 <z_impl_k_yield+0xc0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20014408:	06070063          	beqz	a4,20014468 <z_impl_k_yield+0xc0>
	return (node == list->tail) ? NULL : node->next;
2001440c:	0286a803          	lw	a6,40(a3)
	int32_t b1 = thread_1->base.prio;
20014410:	00e78503          	lb	a0,14(a5)
	int32_t b2 = thread_2->base.prio;
20014414:	00e70583          	lb	a1,14(a4)
	if (b1 != b2) {
20014418:	04b50263          	beq	a0,a1,2001445c <z_impl_k_yield+0xb4>
		return b2 - b1;
2001441c:	40a585b3          	sub	a1,a1,a0
		if (z_sched_prio_cmp(thread, t) > 0) {
20014420:	02b05e63          	blez	a1,2001445c <z_impl_k_yield+0xb4>
	sys_dnode_t *const prev = successor->prev;
20014424:	00472683          	lw	a3,4(a4)
	node->next = successor;
20014428:	00e7a023          	sw	a4,0(a5)
	node->prev = prev;
2001442c:	00d7a223          	sw	a3,4(a5)
	prev->next = node;
20014430:	00f6a023          	sw	a5,0(a3)
	successor->prev = node;
20014434:	00f72223          	sw	a5,4(a4)
	update_cache(1);
20014438:	00100513          	li	a0,1
2001443c:	8f5ff0ef          	jal	ra,20013d30 <update_cache>
	z_swap(&sched_spinlock, key);
}
20014440:	00812403          	lw	s0,8(sp)
20014444:	00c12083          	lw	ra,12(sp)
20014448:	00012903          	lw	s2,0(sp)
2001444c:	00048513          	mv	a0,s1
20014450:	00412483          	lw	s1,4(sp)
20014454:	01010113          	addi	sp,sp,16
20014458:	e4dfb06f          	j	200102a4 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
2001445c:	01070663          	beq	a4,a6,20014468 <z_impl_k_yield+0xc0>
20014460:	00072703          	lw	a4,0(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
20014464:	fa0718e3          	bnez	a4,20014414 <z_impl_k_yield+0x6c>
	sys_dnode_t *const tail = list->tail;
20014468:	0286a703          	lw	a4,40(a3)
	node->next = list;
2001446c:	00c7a023          	sw	a2,0(a5)
	node->prev = tail;
20014470:	00e7a223          	sw	a4,4(a5)
	tail->next = node;
20014474:	00f72023          	sw	a5,0(a4)
	list->tail = node;
20014478:	02f6a423          	sw	a5,40(a3)
}
2001447c:	fbdff06f          	j	20014438 <z_impl_k_yield+0x90>

20014480 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
20014480:	fe010113          	addi	sp,sp,-32
20014484:	00112e23          	sw	ra,28(sp)
20014488:	00812c23          	sw	s0,24(sp)
2001448c:	00912a23          	sw	s1,20(sp)
20014490:	01212823          	sw	s2,16(sp)
20014494:	01312623          	sw	s3,12(sp)
20014498:	01412423          	sw	s4,8(sp)
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
2001449c:	00b567b3          	or	a5,a0,a1
200144a0:	00079863          	bnez	a5,200144b0 <z_tick_sleep+0x30>
	z_impl_k_yield();
200144a4:	f05ff0ef          	jal	ra,200143a8 <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
200144a8:	00000513          	li	a0,0
200144ac:	09c0006f          	j	20014548 <z_tick_sleep+0xc8>
	if (Z_TICK_ABS(ticks) <= 0) {
200144b0:	ffe00793          	li	a5,-2
200144b4:	40a786b3          	sub	a3,a5,a0
200144b8:	00d7b733          	sltu	a4,a5,a3
200144bc:	fff5c793          	not	a5,a1
200144c0:	40e787b3          	sub	a5,a5,a4
200144c4:	00050493          	mv	s1,a0
200144c8:	00058993          	mv	s3,a1
200144cc:	08f04e63          	bgtz	a5,20014568 <z_tick_sleep+0xe8>
200144d0:	00079463          	bnez	a5,200144d8 <z_tick_sleep+0x58>
200144d4:	08069a63          	bnez	a3,20014568 <z_tick_sleep+0xe8>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
200144d8:	6ec000ef          	jal	ra,20014bc4 <sys_clock_tick_get_32>
200144dc:	00950433          	add	s0,a0,s1
	__asm__ volatile ("csrrc %0, mstatus, %1"
200144e0:	00800a13          	li	s4,8
200144e4:	300a3a73          	csrrc	s4,mstatus,s4
	unready_thread(_current);
200144e8:	80000937          	lui	s2,0x80000
200144ec:	37c90913          	addi	s2,s2,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
200144f0:	00892503          	lw	a0,8(s2)
200144f4:	8c1ff0ef          	jal	ra,20013db4 <unready_thread>
	z_add_thread_timeout(_current, timeout);
200144f8:	00892503          	lw	a0,8(s2)
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
200144fc:	200145b7          	lui	a1,0x20014
20014500:	00048613          	mv	a2,s1
20014504:	00098693          	mv	a3,s3
20014508:	2c858593          	addi	a1,a1,712 # 200142c8 <z_thread_timeout>
2001450c:	01850513          	addi	a0,a0,24
20014510:	2dc000ef          	jal	ra,200147ec <z_add_timeout>
	z_mark_thread_as_suspended(_current);
20014514:	00892703          	lw	a4,8(s2)
20014518:	008a7513          	andi	a0,s4,8
	thread->base.thread_state |= _THREAD_SUSPENDED;
2001451c:	00d74783          	lbu	a5,13(a4)
20014520:	0107e793          	ori	a5,a5,16
20014524:	00f706a3          	sb	a5,13(a4)
20014528:	d7dfb0ef          	jal	ra,200102a4 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
2001452c:	698000ef          	jal	ra,20014bc4 <sys_clock_tick_get_32>
20014530:	40a407b3          	sub	a5,s0,a0
20014534:	00f43433          	sltu	s0,s0,a5
20014538:	40800433          	neg	s0,s0
	if (ticks > 0) {
2001453c:	f60416e3          	bnez	s0,200144a8 <z_tick_sleep+0x28>
		return ticks;
20014540:	00078513          	mv	a0,a5
	if (ticks > 0) {
20014544:	f60782e3          	beqz	a5,200144a8 <z_tick_sleep+0x28>
}
20014548:	01c12083          	lw	ra,28(sp)
2001454c:	01812403          	lw	s0,24(sp)
20014550:	01412483          	lw	s1,20(sp)
20014554:	01012903          	lw	s2,16(sp)
20014558:	00c12983          	lw	s3,12(sp)
2001455c:	00812a03          	lw	s4,8(sp)
20014560:	02010113          	addi	sp,sp,32
20014564:	00008067          	ret
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
20014568:	ffe00413          	li	s0,-2
2001456c:	40940433          	sub	s0,s0,s1
20014570:	f71ff06f          	j	200144e0 <z_tick_sleep+0x60>

20014574 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
20014574:	ff010113          	addi	sp,sp,-16
20014578:	00112623          	sw	ra,12(sp)
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
2001457c:	fff00693          	li	a3,-1
20014580:	02d51263          	bne	a0,a3,200145a4 <z_impl_k_sleep+0x30>
20014584:	02a59063          	bne	a1,a0,200145a4 <z_impl_k_sleep+0x30>
		k_thread_suspend(_current);
20014588:	800007b7          	lui	a5,0x80000
2001458c:	3847a503          	lw	a0,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
	z_impl_k_thread_suspend(thread);
20014590:	9c5ff0ef          	jal	ra,20013f54 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
20014594:	fff00513          	li	a0,-1
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
20014598:	00c12083          	lw	ra,12(sp)
2001459c:	01010113          	addi	sp,sp,16
200145a0:	00008067          	ret
	ticks = z_tick_sleep(ticks);
200145a4:	eddff0ef          	jal	ra,20014480 <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
200145a8:	3e800713          	li	a4,1000
200145ac:	02e507b3          	mul	a5,a0,a4
200145b0:	02e51533          	mulh	a0,a0,a4
200145b4:	0077d793          	srli	a5,a5,0x7
200145b8:	01951513          	slli	a0,a0,0x19
200145bc:	00f56533          	or	a0,a0,a5
	return ret;
200145c0:	fd9ff06f          	j	20014598 <z_impl_k_sleep+0x24>

200145c4 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
200145c4:	800007b7          	lui	a5,0x80000
200145c8:	3847a503          	lw	a0,900(a5) # 80000384 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000385>
200145cc:	00008067          	ret

200145d0 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
200145d0:	fe010113          	addi	sp,sp,-32
200145d4:	00912a23          	sw	s1,20(sp)
200145d8:	00112e23          	sw	ra,28(sp)
200145dc:	00812c23          	sw	s0,24(sp)
200145e0:	01212823          	sw	s2,16(sp)
200145e4:	01312623          	sw	s3,12(sp)
200145e8:	00800493          	li	s1,8
200145ec:	3004b4f3          	csrrc	s1,mstatus,s1
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
200145f0:	00d54783          	lbu	a5,13(a0)
	key = (mstatus & MSTATUS_IEN);
200145f4:	0084f493          	andi	s1,s1,8
200145f8:	0087f713          	andi	a4,a5,8
200145fc:	02070263          	beqz	a4,20014620 <z_thread_abort+0x50>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014600:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
20014604:	01c12083          	lw	ra,28(sp)
20014608:	01812403          	lw	s0,24(sp)
2001460c:	01412483          	lw	s1,20(sp)
20014610:	01012903          	lw	s2,16(sp)
20014614:	00c12983          	lw	s3,12(sp)
20014618:	02010113          	addi	sp,sp,32
2001461c:	00008067          	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
20014620:	fdf7f713          	andi	a4,a5,-33
20014624:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
20014628:	01871693          	slli	a3,a4,0x18
2001462c:	4186d693          	srai	a3,a3,0x18
20014630:	00050413          	mv	s0,a0
20014634:	0406ce63          	bltz	a3,20014690 <z_thread_abort+0xc0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
20014638:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
2001463c:	00842783          	lw	a5,8(s0)
20014640:	00078663          	beqz	a5,2001464c <z_thread_abort+0x7c>
			unpend_thread_no_timeout(thread);
20014644:	00040513          	mv	a0,s0
20014648:	d24ff0ef          	jal	ra,20013b6c <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
2001464c:	01840513          	addi	a0,s0,24
20014650:	34c000ef          	jal	ra,2001499c <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
20014654:	06840993          	addi	s3,s0,104
	return list->head == list;
20014658:	06842903          	lw	s2,104(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
2001465c:	01390463          	beq	s2,s3,20014664 <z_thread_abort+0x94>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
20014660:	04091263          	bnez	s2,200146a4 <z_thread_abort+0xd4>
		update_cache(1);
20014664:	00100513          	li	a0,1
20014668:	ec8ff0ef          	jal	ra,20013d30 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
2001466c:	800007b7          	lui	a5,0x80000
20014670:	37c78793          	addi	a5,a5,892 # 8000037c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000037d>
20014674:	0087a703          	lw	a4,8(a5)
20014678:	f88714e3          	bne	a4,s0,20014600 <z_thread_abort+0x30>
2001467c:	0007a783          	lw	a5,0(a5)
20014680:	f80790e3          	bnez	a5,20014600 <z_thread_abort+0x30>
20014684:	00048513          	mv	a0,s1
20014688:	c1dfb0ef          	jal	ra,200102a4 <arch_swap>
	return ret;
2001468c:	f75ff06f          	j	20014600 <z_thread_abort+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
20014690:	05f7f793          	andi	a5,a5,95
20014694:	0087e793          	ori	a5,a5,8
20014698:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
2001469c:	cb4ff0ef          	jal	ra,20013b50 <sys_dlist_remove>
}
200146a0:	f9dff06f          	j	2001463c <z_thread_abort+0x6c>
		unpend_thread_no_timeout(thread);
200146a4:	00090513          	mv	a0,s2
200146a8:	cc4ff0ef          	jal	ra,20013b6c <unpend_thread_no_timeout>
200146ac:	01890513          	addi	a0,s2,24
200146b0:	2ec000ef          	jal	ra,2001499c <z_abort_timeout>
		ready_thread(thread);
200146b4:	00090513          	mv	a0,s2
	thread->arch.swap_return_value = value;
200146b8:	08092223          	sw	zero,132(s2)
200146bc:	aedff0ef          	jal	ra,200141a8 <ready_thread>
200146c0:	f99ff06f          	j	20014658 <z_thread_abort+0x88>

200146c4 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
200146c4:	f0dff06f          	j	200145d0 <z_thread_abort>

200146c8 <z_data_copy>:
 * @return N/A
 */
void z_data_copy(void)
{
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
200146c8:	80002537          	lui	a0,0x80002
	(void)memcpy(&__data_ram_start, &__data_rom_start,
200146cc:	800037b7          	lui	a5,0x80003
		 __data_ram_end - __data_ram_start);
200146d0:	5e450613          	addi	a2,a0,1508 # 800025e4 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x800025e5>
	(void)memcpy(&__data_ram_start, &__data_rom_start,
200146d4:	83078793          	addi	a5,a5,-2000 # 80002830 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002831>
200146d8:	200165b7          	lui	a1,0x20016
200146dc:	40c78633          	sub	a2,a5,a2
200146e0:	8b858593          	addi	a1,a1,-1864 # 200158b8 <__data_rom_start>
200146e4:	5e450513          	addi	a0,a0,1508
200146e8:	b70fe06f          	j	20012a58 <memcpy>

200146ec <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
200146ec:	800007b7          	lui	a5,0x80000
200146f0:	0347a783          	lw	a5,52(a5) # 80000034 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000035>
200146f4:	00079463          	bnez	a5,200146fc <elapsed+0x10>
200146f8:	fc1fd06f          	j	200126b8 <sys_clock_elapsed>
}
200146fc:	00000513          	li	a0,0
20014700:	00008067          	ret

20014704 <next_timeout>:
	return list->head == list;
20014704:	800027b7          	lui	a5,0x80002

static int32_t next_timeout(void)
{
20014708:	ff010113          	addi	sp,sp,-16
2001470c:	66078793          	addi	a5,a5,1632 # 80002660 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002661>
20014710:	00812423          	sw	s0,8(sp)
20014714:	0007a403          	lw	s0,0(a5)
20014718:	00112623          	sw	ra,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
2001471c:	00f41463          	bne	s0,a5,20014724 <next_timeout+0x20>
20014720:	00000413          	li	s0,0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
20014724:	fc9ff0ef          	jal	ra,200146ec <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
20014728:	02040c63          	beqz	s0,20014760 <next_timeout+0x5c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
2001472c:	01042703          	lw	a4,16(s0)
20014730:	01442783          	lw	a5,20(s0)
20014734:	41f55693          	srai	a3,a0,0x1f
20014738:	40a70533          	sub	a0,a4,a0
2001473c:	00a73733          	sltu	a4,a4,a0
20014740:	40d787b3          	sub	a5,a5,a3
20014744:	40e787b3          	sub	a5,a5,a4
	int32_t ret = to == NULL ? MAX_WAIT
20014748:	00f04663          	bgtz	a5,20014754 <next_timeout+0x50>
2001474c:	04079063          	bnez	a5,2001478c <next_timeout+0x88>
20014750:	02050e63          	beqz	a0,2001478c <next_timeout+0x88>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
20014754:	00f04663          	bgtz	a5,20014760 <next_timeout+0x5c>
20014758:	00079863          	bnez	a5,20014768 <next_timeout+0x64>
2001475c:	00055663          	bgez	a0,20014768 <next_timeout+0x64>
	int32_t ret = to == NULL ? MAX_WAIT
20014760:	80000537          	lui	a0,0x80000
20014764:	fff54513          	not	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
20014768:	800007b7          	lui	a5,0x80000
2001476c:	38c7a783          	lw	a5,908(a5) # 8000038c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000038d>
20014770:	00078663          	beqz	a5,2001477c <next_timeout+0x78>
20014774:	00a7d463          	bge	a5,a0,2001477c <next_timeout+0x78>
20014778:	00078513          	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
2001477c:	00c12083          	lw	ra,12(sp)
20014780:	00812403          	lw	s0,8(sp)
20014784:	01010113          	addi	sp,sp,16
20014788:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
2001478c:	00000513          	li	a0,0
20014790:	fd9ff06f          	j	20014768 <next_timeout+0x64>

20014794 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
20014794:	00052783          	lw	a5,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
20014798:	02050e63          	beqz	a0,200147d4 <remove_timeout+0x40>
	return (node == list->tail) ? NULL : node->next;
2001479c:	80002737          	lui	a4,0x80002
200147a0:	66472703          	lw	a4,1636(a4) # 80002664 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002665>
200147a4:	02e50863          	beq	a0,a4,200147d4 <remove_timeout+0x40>
	if (next(t) != NULL) {
200147a8:	02078663          	beqz	a5,200147d4 <remove_timeout+0x40>
		next(t)->dticks += t->dticks;
200147ac:	0107a703          	lw	a4,16(a5)
200147b0:	01052683          	lw	a3,16(a0)
200147b4:	01452583          	lw	a1,20(a0)
200147b8:	0147a603          	lw	a2,20(a5)
200147bc:	00d706b3          	add	a3,a4,a3
200147c0:	00e6b733          	sltu	a4,a3,a4
200147c4:	00b60633          	add	a2,a2,a1
200147c8:	00c70733          	add	a4,a4,a2
200147cc:	00d7a823          	sw	a3,16(a5)
200147d0:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = node->prev;
200147d4:	00452703          	lw	a4,4(a0)
	prev->next = next;
200147d8:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
200147dc:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
200147e0:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
200147e4:	00052223          	sw	zero,4(a0)
}
200147e8:	00008067          	ret

200147ec <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
200147ec:	fe010113          	addi	sp,sp,-32
200147f0:	00812c23          	sw	s0,24(sp)
200147f4:	00912a23          	sw	s1,20(sp)
200147f8:	01312623          	sw	s3,12(sp)
200147fc:	00112e23          	sw	ra,28(sp)
20014800:	00068993          	mv	s3,a3
20014804:	01212823          	sw	s2,16(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20014808:	fff00693          	li	a3,-1
{
2001480c:	00050413          	mv	s0,a0
20014810:	00060493          	mv	s1,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
20014814:	00d61463          	bne	a2,a3,2001481c <z_add_timeout+0x30>
20014818:	16c98463          	beq	s3,a2,20014980 <z_add_timeout+0x194>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
2001481c:	00b42423          	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014820:	00800913          	li	s2,8
20014824:	30093973          	csrrc	s2,mstatus,s2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
20014828:	ffe00693          	li	a3,-2
2001482c:	409687b3          	sub	a5,a3,s1
20014830:	00f6b733          	sltu	a4,a3,a5
20014834:	fff9c793          	not	a5,s3
20014838:	40e787b3          	sub	a5,a5,a4
	key = (mstatus & MSTATUS_IEN);
2001483c:	00897913          	andi	s2,s2,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
20014840:	0607ce63          	bltz	a5,200148bc <z_add_timeout+0xd0>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
20014844:	800007b7          	lui	a5,0x80000
20014848:	00878793          	addi	a5,a5,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
2001484c:	0007a703          	lw	a4,0(a5)
20014850:	0047a783          	lw	a5,4(a5)
20014854:	40e68733          	sub	a4,a3,a4
20014858:	00e6b6b3          	sltu	a3,a3,a4
2001485c:	fff7c793          	not	a5,a5
20014860:	40d787b3          	sub	a5,a5,a3
20014864:	409704b3          	sub	s1,a4,s1
20014868:	00973733          	sltu	a4,a4,s1
2001486c:	413786b3          	sub	a3,a5,s3

			to->dticks = MAX(1, ticks);
20014870:	40e686b3          	sub	a3,a3,a4
20014874:	00d04a63          	bgtz	a3,20014888 <z_add_timeout+0x9c>
20014878:	00069463          	bnez	a3,20014880 <z_add_timeout+0x94>
2001487c:	00049663          	bnez	s1,20014888 <z_add_timeout+0x9c>
20014880:	00100493          	li	s1,1
20014884:	00000693          	li	a3,0
20014888:	00942823          	sw	s1,16(s0)
	return list->head == list;
2001488c:	80002637          	lui	a2,0x80002
20014890:	66060713          	addi	a4,a2,1632 # 80002660 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002661>
20014894:	00072783          	lw	a5,0(a4)
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
20014898:	00d42a23          	sw	a3,20(s0)
2001489c:	66060613          	addi	a2,a2,1632
	sys_dnode_t *const tail = list->tail;
200148a0:	00472803          	lw	a6,4(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
200148a4:	06c79263          	bne	a5,a2,20014908 <z_add_timeout+0x11c>
	node->next = list;
200148a8:	00c42023          	sw	a2,0(s0)
	node->prev = tail;
200148ac:	01042223          	sw	a6,4(s0)
	tail->next = node;
200148b0:	00882023          	sw	s0,0(a6)
	list->tail = node;
200148b4:	00862223          	sw	s0,4(a2)
}
200148b8:	09c0006f          	j	20014954 <z_add_timeout+0x168>
200148bc:	e31ff0ef          	jal	ra,200146ec <elapsed>
200148c0:	00148793          	addi	a5,s1,1
200148c4:	0097b4b3          	sltu	s1,a5,s1
200148c8:	013486b3          	add	a3,s1,s3
200148cc:	41f55493          	srai	s1,a0,0x1f
200148d0:	00a78533          	add	a0,a5,a0
200148d4:	00f537b3          	sltu	a5,a0,a5
200148d8:	009686b3          	add	a3,a3,s1
200148dc:	00d786b3          	add	a3,a5,a3
200148e0:	00a42823          	sw	a0,16(s0)
200148e4:	fa9ff06f          	j	2001488c <z_add_timeout+0xa0>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
200148e8:	40e68733          	sub	a4,a3,a4
200148ec:	00e6b6b3          	sltu	a3,a3,a4
200148f0:	40a585b3          	sub	a1,a1,a0
200148f4:	40d586b3          	sub	a3,a1,a3
200148f8:	00e42823          	sw	a4,16(s0)
200148fc:	00d42a23          	sw	a3,20(s0)
	return (node == list->tail) ? NULL : node->next;
20014900:	faf804e3          	beq	a6,a5,200148a8 <z_add_timeout+0xbc>
20014904:	0007a783          	lw	a5,0(a5)
		for (t = first(); t != NULL; t = next(t)) {
20014908:	fa0780e3          	beqz	a5,200148a8 <z_add_timeout+0xbc>
			if (t->dticks > to->dticks) {
2001490c:	0147a503          	lw	a0,20(a5)
20014910:	01442583          	lw	a1,20(s0)
20014914:	0107a703          	lw	a4,16(a5)
20014918:	01042683          	lw	a3,16(s0)
2001491c:	00a5c663          	blt	a1,a0,20014928 <z_add_timeout+0x13c>
20014920:	fcb514e3          	bne	a0,a1,200148e8 <z_add_timeout+0xfc>
20014924:	fce6f2e3          	bgeu	a3,a4,200148e8 <z_add_timeout+0xfc>
				t->dticks -= to->dticks;
20014928:	40d706b3          	sub	a3,a4,a3
2001492c:	00d73733          	sltu	a4,a4,a3
20014930:	40b505b3          	sub	a1,a0,a1
20014934:	40e58733          	sub	a4,a1,a4
20014938:	00e7aa23          	sw	a4,20(a5)
	sys_dnode_t *const prev = successor->prev;
2001493c:	0047a703          	lw	a4,4(a5)
20014940:	00d7a823          	sw	a3,16(a5)
	node->next = successor;
20014944:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
20014948:	00e42223          	sw	a4,4(s0)
	prev->next = node;
2001494c:	00872023          	sw	s0,0(a4)
	successor->prev = node;
20014950:	0087a223          	sw	s0,4(a5)
	return list->head == list;
20014954:	00062783          	lw	a5,0(a2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
20014958:	02c78263          	beq	a5,a2,2001497c <z_add_timeout+0x190>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
2001495c:	02f41063          	bne	s0,a5,2001497c <z_add_timeout+0x190>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
20014960:	da5ff0ef          	jal	ra,20014704 <next_timeout>

			if (next_time == 0 ||
20014964:	00050863          	beqz	a0,20014974 <z_add_timeout+0x188>
			    _current_cpu->slice_ticks != next_time) {
20014968:	800007b7          	lui	a5,0x80000
			if (next_time == 0 ||
2001496c:	38c7a783          	lw	a5,908(a5) # 8000038c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000038d>
20014970:	00a78663          	beq	a5,a0,2001497c <z_add_timeout+0x190>
				sys_clock_set_timeout(next_time, false);
20014974:	00000593          	li	a1,0
20014978:	c65fd0ef          	jal	ra,200125dc <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
2001497c:	30092973          	csrrs	s2,mstatus,s2
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
20014980:	01c12083          	lw	ra,28(sp)
20014984:	01812403          	lw	s0,24(sp)
20014988:	01412483          	lw	s1,20(sp)
2001498c:	01012903          	lw	s2,16(sp)
20014990:	00c12983          	lw	s3,12(sp)
20014994:	02010113          	addi	sp,sp,32
20014998:	00008067          	ret

2001499c <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
2001499c:	ff010113          	addi	sp,sp,-16
200149a0:	00812423          	sw	s0,8(sp)
200149a4:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
200149a8:	00800413          	li	s0,8
200149ac:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
200149b0:	00052783          	lw	a5,0(a0)
	key = (mstatus & MSTATUS_IEN);
200149b4:	00847413          	andi	s0,s0,8
200149b8:	02078063          	beqz	a5,200149d8 <z_abort_timeout+0x3c>
			remove_timeout(to);
200149bc:	dd9ff0ef          	jal	ra,20014794 <remove_timeout>
			ret = 0;
200149c0:	00000513          	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
200149c4:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
200149c8:	00c12083          	lw	ra,12(sp)
200149cc:	00812403          	lw	s0,8(sp)
200149d0:	01010113          	addi	sp,sp,16
200149d4:	00008067          	ret
	int ret = -EINVAL;
200149d8:	fea00513          	li	a0,-22
200149dc:	fe9ff06f          	j	200149c4 <z_abort_timeout+0x28>

200149e0 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
200149e0:	fe010113          	addi	sp,sp,-32
200149e4:	00812c23          	sw	s0,24(sp)
200149e8:	00912a23          	sw	s1,20(sp)
200149ec:	00112e23          	sw	ra,28(sp)
200149f0:	00050493          	mv	s1,a0
200149f4:	00b12623          	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
200149f8:	00800413          	li	s0,8
200149fc:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
20014a00:	d05ff0ef          	jal	ra,20014704 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
20014a04:	00100793          	li	a5,1
	key = (mstatus & MSTATUS_IEN);
20014a08:	00847413          	andi	s0,s0,8
20014a0c:	00a7da63          	bge	a5,a0,20014a20 <z_set_timeout_expiry+0x40>
20014a10:	00c12583          	lw	a1,12(sp)
20014a14:	00954663          	blt	a0,s1,20014a20 <z_set_timeout_expiry+0x40>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
20014a18:	00048513          	mv	a0,s1
20014a1c:	bc1fd0ef          	jal	ra,200125dc <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014a20:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
20014a24:	01c12083          	lw	ra,28(sp)
20014a28:	01812403          	lw	s0,24(sp)
20014a2c:	01412483          	lw	s1,20(sp)
20014a30:	02010113          	addi	sp,sp,32
20014a34:	00008067          	ret

20014a38 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
20014a38:	fd010113          	addi	sp,sp,-48
20014a3c:	02812423          	sw	s0,40(sp)
20014a40:	02912223          	sw	s1,36(sp)
20014a44:	02112623          	sw	ra,44(sp)
20014a48:	03212023          	sw	s2,32(sp)
20014a4c:	01312e23          	sw	s3,28(sp)
20014a50:	01412c23          	sw	s4,24(sp)
20014a54:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014a58:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
20014a5c:	eacff0ef          	jal	ra,20014108 <z_time_slice>
20014a60:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
20014a64:	80000937          	lui	s2,0x80000
20014a68:	02992a23          	sw	s1,52(s2) # 80000034 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000035>
	return list->head == list;
20014a6c:	800029b7          	lui	s3,0x80002

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
20014a70:	800004b7          	lui	s1,0x80000
	key = (mstatus & MSTATUS_IEN);
20014a74:	00847413          	andi	s0,s0,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
20014a78:	03490913          	addi	s2,s2,52
20014a7c:	66098993          	addi	s3,s3,1632 # 80002660 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002661>
		curr_tick += dt;
20014a80:	00848493          	addi	s1,s1,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014a84:	00800a13          	li	s4,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
20014a88:	00092783          	lw	a5,0(s2)
20014a8c:	0009a503          	lw	a0,0(s3)
		curr_tick += dt;
20014a90:	0004a683          	lw	a3,0(s1)
20014a94:	0044a883          	lw	a7,4(s1)
20014a98:	41f7d593          	srai	a1,a5,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
20014a9c:	03350a63          	beq	a0,s3,20014ad0 <sys_clock_announce+0x98>
	while (first() != NULL && first()->dticks <= announce_remaining) {
20014aa0:	02050863          	beqz	a0,20014ad0 <sys_clock_announce+0x98>
20014aa4:	01452603          	lw	a2,20(a0)
20014aa8:	01052703          	lw	a4,16(a0)
20014aac:	00c5c663          	blt	a1,a2,20014ab8 <sys_clock_announce+0x80>
20014ab0:	06b61663          	bne	a2,a1,20014b1c <sys_clock_announce+0xe4>
20014ab4:	06e7f463          	bgeu	a5,a4,20014b1c <sys_clock_announce+0xe4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
20014ab8:	40f70833          	sub	a6,a4,a5
20014abc:	01073733          	sltu	a4,a4,a6
20014ac0:	40b60633          	sub	a2,a2,a1
20014ac4:	40e60733          	sub	a4,a2,a4
20014ac8:	01052823          	sw	a6,16(a0)
20014acc:	00e52a23          	sw	a4,20(a0)
	}

	curr_tick += announce_remaining;
20014ad0:	00d786b3          	add	a3,a5,a3
20014ad4:	011585b3          	add	a1,a1,a7
20014ad8:	00f6b7b3          	sltu	a5,a3,a5
20014adc:	00b787b3          	add	a5,a5,a1
20014ae0:	00d4a023          	sw	a3,0(s1)
20014ae4:	00f4a223          	sw	a5,4(s1)
	announce_remaining = 0;
20014ae8:	00092023          	sw	zero,0(s2)

	sys_clock_set_timeout(next_timeout(), false);
20014aec:	c19ff0ef          	jal	ra,20014704 <next_timeout>
20014af0:	00000593          	li	a1,0
20014af4:	ae9fd0ef          	jal	ra,200125dc <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014af8:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
20014afc:	02c12083          	lw	ra,44(sp)
20014b00:	02812403          	lw	s0,40(sp)
20014b04:	02412483          	lw	s1,36(sp)
20014b08:	02012903          	lw	s2,32(sp)
20014b0c:	01c12983          	lw	s3,28(sp)
20014b10:	01812a03          	lw	s4,24(sp)
20014b14:	03010113          	addi	sp,sp,48
20014b18:	00008067          	ret
		curr_tick += dt;
20014b1c:	00d706b3          	add	a3,a4,a3
		announce_remaining -= dt;
20014b20:	40e787b3          	sub	a5,a5,a4
		curr_tick += dt;
20014b24:	41f75593          	srai	a1,a4,0x1f
20014b28:	00e6b633          	sltu	a2,a3,a4
20014b2c:	011585b3          	add	a1,a1,a7
		announce_remaining -= dt;
20014b30:	00f92023          	sw	a5,0(s2)
		t->dticks = 0;
20014b34:	00000813          	li	a6,0
20014b38:	00000793          	li	a5,0
		curr_tick += dt;
20014b3c:	00b605b3          	add	a1,a2,a1
		t->dticks = 0;
20014b40:	00f52823          	sw	a5,16(a0)
20014b44:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
20014b48:	00d4a023          	sw	a3,0(s1)
20014b4c:	00b4a223          	sw	a1,4(s1)
		remove_timeout(t);
20014b50:	00a12623          	sw	a0,12(sp)
20014b54:	c41ff0ef          	jal	ra,20014794 <remove_timeout>
20014b58:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
20014b5c:	00c12503          	lw	a0,12(sp)
20014b60:	00852783          	lw	a5,8(a0)
20014b64:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014b68:	300a3473          	csrrc	s0,mstatus,s4
	key = (mstatus & MSTATUS_IEN);
20014b6c:	00847413          	andi	s0,s0,8
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
20014b70:	f19ff06f          	j	20014a88 <sys_clock_announce+0x50>

20014b74 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
20014b74:	ff010113          	addi	sp,sp,-16
20014b78:	00812423          	sw	s0,8(sp)
20014b7c:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
20014b80:	00800413          	li	s0,8
20014b84:	30043473          	csrrc	s0,mstatus,s0
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
20014b88:	b31fd0ef          	jal	ra,200126b8 <sys_clock_elapsed>
20014b8c:	80000737          	lui	a4,0x80000
20014b90:	00870713          	addi	a4,a4,8 # 80000008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000009>
20014b94:	00050793          	mv	a5,a0
20014b98:	00072503          	lw	a0,0(a4)
20014b9c:	00472583          	lw	a1,4(a4)
	key = (mstatus & MSTATUS_IEN);
20014ba0:	00847413          	andi	s0,s0,8
20014ba4:	00a78533          	add	a0,a5,a0
20014ba8:	00f537b3          	sltu	a5,a0,a5
20014bac:	00b785b3          	add	a1,a5,a1
	__asm__ volatile ("csrrs %0, mstatus, %1"
20014bb0:	30042473          	csrrs	s0,mstatus,s0
	}
	return t;
}
20014bb4:	00c12083          	lw	ra,12(sp)
20014bb8:	00812403          	lw	s0,8(sp)
20014bbc:	01010113          	addi	sp,sp,16
20014bc0:	00008067          	ret

20014bc4 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
20014bc4:	ff010113          	addi	sp,sp,-16
20014bc8:	00112623          	sw	ra,12(sp)
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
20014bcc:	fa9ff0ef          	jal	ra,20014b74 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
20014bd0:	00c12083          	lw	ra,12(sp)
20014bd4:	01010113          	addi	sp,sp,16
20014bd8:	00008067          	ret

20014bdc <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
20014bdc:	20016637          	lui	a2,0x20016
20014be0:	200165b7          	lui	a1,0x20016
20014be4:	20016537          	lui	a0,0x20016
20014be8:	80c60613          	addi	a2,a2,-2036 # 2001580c <levels.0+0x84>
20014bec:	88058593          	addi	a1,a1,-1920 # 20015880 <CSWTCH.190+0x20>
20014bf0:	89050513          	addi	a0,a0,-1904 # 20015890 <CSWTCH.190+0x30>
20014bf4:	c44fc06f          	j	20011038 <printk>

20014bf8 <k_heap_init>:
	sys_dlist_init(&w->waitq);
20014bf8:	00c50713          	addi	a4,a0,12
	list->head = (sys_dnode_t *)list;
20014bfc:	00e52623          	sw	a4,12(a0)
	list->tail = (sys_dnode_t *)list;
20014c00:	00e52823          	sw	a4,16(a0)
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
20014c04:	ee0fc06f          	j	200112e4 <sys_heap_init>

20014c08 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
20014c08:	ff010113          	addi	sp,sp,-16
20014c0c:	00812423          	sw	s0,8(sp)
20014c10:	00912223          	sw	s1,4(sp)
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
20014c14:	80002437          	lui	s0,0x80002
20014c18:	800024b7          	lui	s1,0x80002
{
20014c1c:	00112623          	sw	ra,12(sp)
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
20014c20:	78840413          	addi	s0,s0,1928 # 80002788 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002789>
20014c24:	78848493          	addi	s1,s1,1928 # 80002788 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80002789>
20014c28:	00946e63          	bltu	s0,s1,20014c44 <statics_init+0x3c>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
20014c2c:	00c12083          	lw	ra,12(sp)
20014c30:	00812403          	lw	s0,8(sp)
20014c34:	00412483          	lw	s1,4(sp)
20014c38:	00000513          	li	a0,0
20014c3c:	01010113          	addi	sp,sp,16
20014c40:	00008067          	ret
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
20014c44:	00842603          	lw	a2,8(s0)
20014c48:	00442583          	lw	a1,4(s0)
20014c4c:	00040513          	mv	a0,s0
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
20014c50:	01440413          	addi	s0,s0,20
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
20014c54:	fa5ff0ef          	jal	ra,20014bf8 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
20014c58:	fd1ff06f          	j	20014c28 <statics_init+0x20>
